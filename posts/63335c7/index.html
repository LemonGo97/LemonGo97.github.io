<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Netty In Action -- 编解码器框架 | LemonGo97のBlog</title><meta name="description" content="就像很多标准的架构模式都被各种专用框架所支持一样，常见的数据处理模式往往也是目标实现的很好的候选对象，它可以节省开发人员大量的时间和精力。 这也适应于本章的主题： 编码和解码，或者数据从一种特定协议的格式到另一种格式的转换。这些任务将由通常称为编解码器的组件来处理。Netty 提供了多种组件，简化了为了支持广泛的协议而创建自定义的编解码器的过程。例如，如果你正在构建一个基于 Netty 的邮件服务"><meta name="keywords" content="Java,Netty"><meta name="author" content="LemonGo97"><meta name="copyright" content="LemonGo97"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.lemongo97.com/posts/63335c7/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><meta property="og:type" content="article"><meta property="og:title" content="Netty In Action -- 编解码器框架"><meta property="og:url" content="https://blog.lemongo97.com/posts/63335c7/"><meta property="og:site_name" content="LemonGo97のBlog"><meta property="og:description" content="就像很多标准的架构模式都被各种专用框架所支持一样，常见的数据处理模式往往也是目标实现的很好的候选对象，它可以节省开发人员大量的时间和精力。 这也适应于本章的主题： 编码和解码，或者数据从一种特定协议的格式到另一种格式的转换。这些任务将由通常称为编解码器的组件来处理。Netty 提供了多种组件，简化了为了支持广泛的协议而创建自定义的编解码器的过程。例如，如果你正在构建一个基于 Netty 的邮件服务"><meta property="og:image" content="https://image.lemongo97.com/Snipaste_2024-05-06_00-33-28%202.png"><meta property="article:published_time" content="2024-05-06T12:56:58.000Z"><meta property="article:modified_time" content="2024-05-06T12:56:58.000Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.1.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2024-05-06 20:56:58'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="LemonGo97のBlog" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="https://coding-net-production-static-ci.codehub.cn/d70d0fa9-08d5-4fc7-ba82-7b73fee22292.jpg?imageMogr2/auto-orient/format/jpeg/cut/700x700x0x0" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">65</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">39</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">什么是编解码器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">解码器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB-ByteToMessageDecoder"><span class="toc-number">2.1.</span> <span class="toc-text">抽象类 ByteToMessageDecoder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB-ReplayingDecoder"><span class="toc-number">2.2.</span> <span class="toc-text">抽象类 ReplayingDecoder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB-MessageToMessageDecoder"><span class="toc-number">2.3.</span> <span class="toc-text">抽象类 MessageToMessageDecoder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TooLongFrameException-%E7%B1%BB"><span class="toc-number">2.4.</span> <span class="toc-text">TooLongFrameException 类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">编码器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB-MessageToByteEncoder"><span class="toc-number">3.1.</span> <span class="toc-text">抽象类 MessageToByteEncoder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB-MessageToMessageEncode"><span class="toc-number">3.2.</span> <span class="toc-text">抽象类 MessageToMessageEncode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%9A%84%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">抽象的编解码器类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB-ByteToMessageCodec"><span class="toc-number">4.1.</span> <span class="toc-text">抽象类 ByteToMessageCodec</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB-MessageToMessageCodec"><span class="toc-number">4.2.</span> <span class="toc-text">抽象类 MessageToMessageCodec</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CombinedChannelDuplexHandler-%E7%B1%BB"><span class="toc-number">4.3.</span> <span class="toc-text">CombinedChannelDuplexHandler 类</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://image.lemongo97.com/Snipaste_2024-05-06_00-33-28%202.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">LemonGo97のBlog</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Netty In Action -- 编解码器框架</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-06T12:56:58.000Z" title="发表于 2024-05-06 20:56:58">2024-05-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-06T12:56:58.000Z" title="更新于 2024-05-06 20:56:58">2024-05-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Netty/">Netty</a></span></div><div class="meta-secondline"> </div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>就像很多标准的架构模式都被各种专用框架所支持一样，常见的数据处理模式往往也是目标实现的很好的候选对象，它可以节省开发人员大量的时间和精力。</p>
<p>这也适应于本章的主题： 编码和解码，或者数据从一种特定协议的格式到另一种格式的转换。这些任务将由通常称为编解码器的组件来处理。Netty 提供了多种组件，简化了为了支持广泛的协议而创建自定义的编解码器的过程。例如，如果你正在构建一个基于 Netty 的邮件服务器，那么你将会发现 Netty 对于编解码器的支持对于实现 POP3、 IMAP 和 SMTP 协议来说是多么的宝贵。</p>
<h2 id="什么是编解码器"><a href="#什么是编解码器" class="headerlink" title="什么是编解码器"></a>什么是编解码器</h2><p>每个网络应用程序都必须定义如何解析在两个节点之间来回传输的原始字节，以及如何将其和目标应用程序的数据格式做相互转换。这种转换逻辑由编解码器处理，编解码器由编码器和解码器组成，它们每种都可以将字节流从一种格式转换为另一种格式。那么它们的区别是什么呢？</p>
<p>如果将消息看作是对于特定的应用程序具有具体含义的结构化的字节序列—它的数据。那么编码器是将消息转换为适合于传输的格式（最有可能的就是字节流）；而对应的解码器则是将网络字节流转换回应用程序的消息格式。因此，编码器操作出站数据，而解码器处理入站数据。</p>
<p>记住这些背景信息，接下来让我们研究一下 Netty 所提供的用于实现这两种组件的类。</p>
<h2 id="解码器"><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h2><p>在这一节中，我们将研究 Netty 所提供的解码器类，并提供关于何时以及如何使用它们的具体示例。这些类覆盖了两个不同的用例：</p>
<ul>
<li>将字节解码为消息——<code>ByteToMessageDecoder</code>和 <code>ReplayingDecoder</code>；</li>
<li>将一种消息类型解码为另一种——<code>MessageToMessageDecoder</code></li>
</ul>
<p>因为解码器是负责将入站数据从一种格式转换到另一种格式的，所以知道 Netty 的解码器实现了 <code>ChannelInboundHandler</code>也不会让你感到意外。</p>
<p>什么时候会用到解码器呢？很简单：每当需要为 <code>ChannelPipeline</code>中的下一个 <code>ChannelInboundHandler</code> 转换入站数据时会用到。此外，得益于 <code>ChannelPipeline</code> 的设计，可以将多个解码器链接在一起，以实现任意复杂的转换逻辑，这也是 Netty 是如何支持代码的模块化以及复用的一个很好的例子。</p>
<h3 id="抽象类-ByteToMessageDecoder"><a href="#抽象类-ByteToMessageDecoder" class="headerlink" title="抽象类 ByteToMessageDecoder"></a>抽象类 <code>ByteToMessageDecoder</code></h3><p>将字节解码为消息（或者另一个字节序列）是一项如此常见的任务，以至于 Netty 为它提供了一个抽象的基类：<code>ByteToMessageDecoder</code>。由于你不可能知道远程节点是否会一次性地发送一个完整的消息，所以这个类会对入站数据进行缓冲，直到它准备好处理。下表解释了它最重要的两个方法。</p>
<table>
<thead>
<tr>
<th>方 法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</code></td>
<td>这是你必须实现的唯一抽象方法。<code>decode()</code>方法被调用时将会传入一个包含了传入数据的 <code>ByteBuf</code>，以及一个用来添加解码消息的 <code>List</code>。对这个方法的调用将会重复进行，直到确定没有新的元素被添加到该 <code>List</code>，或者该 <code>ByteBuf</code> 中没有更多可读取的字节时为止。然后，如果该 <code>List</code>不为空，那么它的内容将会被传递给 <code>ChannelPipeline</code>中的下一个 <code>ChannelInboundHandler</code></td>
</tr>
<tr>
<td><code>decodeLast(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</code></td>
<td>Netty 提供的这个默认实现只是简单地调用了 <code>decode()</code>方法。当 <code>Channel</code>的状态变为非活动时，这个方法将会被调用一次。可以重写该方法以提供特殊的处理(比如用来产生一个 <code>LastHttpContent</code>消息)</td>
</tr>
</tbody></table>
<p>下面举一个如何使用这个类的示例，假设你接收了一个包含简单 <code>int</code> 的字节流，每个 <code>int</code>都需要被单独处理。在这种情况下，你需要从入站 <code>ByteBuf</code> 中读取每个 <code>int</code>，并将它传递给<code>ChannelPipeline</code>中的下一个 <code>ChannelInboundHandler</code>。为了解码这个字节流，你要扩展<code>ByteToMessageDecoder</code>类。（需要注意的是，原始类型的 <code>int</code>在被添加到 <code>List</code>中时，会被自动装箱为 <code>Integer</code>。）</p>
<p>该设计如下图所示。</p>
<p>每次从入站 <code>ByteBuf</code>中读取 4 字节，将其解码为一个 <code>int</code>，然后将它添加到一个 <code>List</code>中。当没有更多的元素可以被添加到该 <code>List</code> 中时，它的内容将会被发送给下一个 <code>ChannelInboundHandler</code>。</p>
<img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/image-20240506210432742.png" alt="ToIntegerDecoder" style="zoom: 33%;" />

<p>下列代码展示了 <code>ToIntegerDecoder</code>的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展 ByteToMessageDecoder 类，以将字节解码为特定的格式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToIntegerDecoder</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageDecoder</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 检查是否至少有 4字节可读 （一个 int的字节长度）</span></span><br><span class="line">    <span class="keyword">if</span> (in.readableBytes() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="comment">// 从入站 ByteBuf 中读取一个 int，并将其添加到解码消息的 List 中</span></span><br><span class="line">      out.add(in.readInt());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然 <code>ByteToMessageDecoder</code>使得可以很简单地实现这种模式，但是你可能会发现，在调用 <code>readInt()</code>方法前不得不验证所输入的 <code>ByteBuf</code>是否具有足够的数据有点烦琐。 在下一节中，我们将讨论 <code>ReplayingDecoder</code>，它是一个特殊的解码器，以少量的开销消除了这个步骤。</p>
<blockquote>
<p><strong>编解码器中的引用计数</strong></p>
<p>引用计数需要特别的注意。对于编码器和解码器来说，其过程也是相当的简单：一旦消息被编码或者解码，它就会被 <code>ReferenceCountUtil.release(message)</code>调用自动释放。 如果你需要保留引用以便稍后使用， 那么你可以调用 <code>ReferenceCountUtil.retain(message)</code>方法。这将会增加该引用计数，从而防止该消息被释放。</p>
</blockquote>
<h3 id="抽象类-ReplayingDecoder"><a href="#抽象类-ReplayingDecoder" class="headerlink" title="抽象类 ReplayingDecoder"></a>抽象类 ReplayingDecoder</h3><p><code>ReplayingDecoder</code>扩展了 <code>ByteToMessageDecoder</code>类（如下列代码所示），使得我们不必调用 <code>readableBytes()</code>方法。它通过使用一个自定义的 <code>ByteBuf</code> 实现，<code>ReplayingDecoderByteBuf</code>， 包装传入的 <code>ByteBuf</code>实现了这一点， 其将在内部执行该调用(调用 <code>readableBytes()</code>方法)。</p>
<p>这个类的完整声明是：</p>
<p><code>public abstract class ReplayingDecoder&lt;S&gt; extends ByteToMessageDecoder</code></p>
<p>类型参数 <code>S</code> 指定了用于状态管理的类型，其中 <code>Void</code> 代表不需要状态管理。</p>
<p>以下代码展示了基于 <code>ReplayingDecoder</code>重新实现的 <code>ToIntegerDecoder</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展 ReplayingDecoder&lt;Void&gt;以将字节解码为消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToIntegerDecoder2</span> <span class="keyword">extends</span> <span class="title class_">ReplayingDecoder</span>&lt;Void&gt; &#123;</span><br><span class="line">  <span class="comment">// 传入的 ByteBuf 是 ReplayingDecoderByteBuf</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 从入站 ByteBuf 中读取一个 int，并将其添加到解码消息的 List 中</span></span><br><span class="line">    out.add(in.readInt());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和之前一样，从<code>ByteBuf</code>中提取的<code>int</code>将会被添加到<code>List</code>中。如果没有足够的字节可用，这个<code>readInt()</code>方法的实现将会抛出一个<code>Error</code>(这里实际上抛出的是一个 Signal，详见 <code>io.netty.util.Signal</code>类)，其将在基类中被捕获并处理。当有更多的数据可供读取时，该<code>decode()</code>方法将会被再次调用。</p>
<p>请注意 <code>ReplayingDecoderByteBuf</code>的下面这些方面：</p>
<ul>
<li>并不是所有的 <code>ByteBuf</code> 操作都被支持，如果调用了一个不被支持的方法，将会抛出一个 <code>UnsupportedOperationException</code>；</li>
<li><code>ReplayingDecoder</code>稍慢于 <code>ByteToMessageDecoder</code>。</li>
</ul>
<p>如果对比上述两段代码， 你会发现后者明显更简单。 示例本身是很基本的，所以请记住，在真实的、更加复杂的情况下，使用一种或者另一种作为基类所带来的差异可能是很显著的。这里有一个简单的准则：如果使用 <code>ByteToMessageDecoder</code> 不会引入太多的复杂性，那么请使用它；否则，请使用 <code>ReplayingDecoder</code>。</p>
<blockquote>
<p><strong>更多的解码器</strong></p>
<p>下面的这些类处理更加复杂的用例：</p>
<ul>
<li><code>io.netty.handler.codec.LineBasedFrameDecoder</code>—这个类在 Netty 内部也有使用，它使用了行尾控制字符（<code>\n</code>或者<code>\r\n</code>）来解析消息数据；</li>
<li><code>io.netty.handler.codec.http.HttpObjectDecoder</code>—一个 HTTP 数据的解码器。在 <code>io.netty.handler.codec</code>子包下面，你将会发现更多用于特定用例的编码器和解码器实现。</li>
</ul>
<p>更多有关信息参见 Netty 的 Javadoc。</p>
</blockquote>
<h3 id="抽象类-MessageToMessageDecoder"><a href="#抽象类-MessageToMessageDecoder" class="headerlink" title="抽象类 MessageToMessageDecoder"></a>抽象类 MessageToMessageDecoder</h3><p>在这一节中，我们将解释如何使用下面的抽象基类在两个消息格式之间进行转换（例如， 从一种 POJO 类型转换为另一种）：</p>
<p><code>public abstract class MessageToMessageDecoder&lt;I&gt; extends ChannelInboundHandlerAdapter</code></p>
<p>类型参数 <code>I</code> 指定了 <code>decode()</code>方法的输入参数 <code>msg</code> 的类型，它是你必须实现的唯一方法。下表展示了这个方法的详细信息。</p>
<table>
<thead>
<tr>
<th>方 法</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td><code>decode(ChannelHandlerContext ctx, I msg, List&lt;Object&gt; out)</code></td>
<td>对于每个需要被解码为另一种格式的入站消息来说，该方法都将会被调用。解码消息随后会被传递给 <code>ChannelPipeline</code>中的下一个 <code>ChannelInboundHandler</code></td>
</tr>
</tbody></table>
<p>在这个示例中，我们将编写一个 <code>IntegerToStringDecoder</code>解码器来扩展 <code>MessageToMessageDecoder&lt;Integer&gt;</code>。它的 <code>decode()</code>方法会把 <code>Integer</code> 参数转换为它的 <code>String</code>表示，并将拥有下列签名：</p>
<p><code>public void decode( ChannelHandlerContext ctx, Integer msg, List&lt;Object&gt; out ) throws Exception</code></p>
<p>和之前一样，解码的<code>String</code>将被添加到传出的<code>List</code>中， 并转发给下一个<code>ChannelInboundHandler</code>。</p>
<p>该设计如下图所示：</p>
<img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/image-20240506211721464.png" alt="IntegerToStringDecoder" style="zoom:33%;" />

<p>下列代码给出了 <code>IntegerToStringDecoder</code>的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展了 MessageToMessageDecoder&lt;Integer&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerToStringDecoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageDecoder</span>&lt;Integer&gt; &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, Integer msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 将 Integer 消息转换为它的 String 表示，并将其添加到输出的 List 中</span></span><br><span class="line">    out.add(String.valueOf(msg));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><code>HttpObjectAggregator</code></strong></p>
<p>有关更加复杂的例子，请研究 <code>io.netty.handler.codec.http.HttpObjectAggregator</code>类，它扩展了 <code>MessageToMessageDecoder&lt;HttpObject&gt;</code>。</p>
</blockquote>
<h3 id="TooLongFrameException-类"><a href="#TooLongFrameException-类" class="headerlink" title="TooLongFrameException 类"></a><code>TooLongFrameException</code> 类</h3><p>由于 Netty 是一个异步框架，所以需要在字节可以解码之前在内存中缓冲它们。因此，不能让解码器缓冲大量的数据以至于耗尽可用的内存。为了解除这个常见的顾虑，Netty 提供了<code>TooLongFrameException</code>类，其将由解码器在帧超出指定的大小限制时抛出。</p>
<p>为了避免这种情况，你可以设置一个最大字节数的阈值，如果超出该阈值，则会导致抛出一个 <code>TooLongFrameException</code>（随后会被 <code>ChannelHandler.exceptionCaught()</code>方法捕获）。然后，如何处理该异常则完全取决于该解码器的用户。某些协议（如 HTTP）可能允许你返回一个特殊的响应。而在其他的情况下，唯一的选择可能就是关闭对应的连接。</p>
<p>下列代码展示了 <code>ByteToMessageDecoder</code>是如何使用 <code>TooLongFrameException</code>来通知 <code>ChannelPipeline</code>中的其他 <code>ChannelHandler</code>发生了帧大小溢出的。需要注意的是，如果你正在使用一个可变帧大小的协议，那么这种保护措施将是尤为重要的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展 ByteToMessageDecoder以将字节解码为消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeByteToMessageDecoder</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageDecoder</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_FRAME_SIZE</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">readable</span> <span class="operator">=</span> in.readableBytes();</span><br><span class="line">    <span class="comment">// 检查缓冲区中是否有超过 MAX_FRAME_SIZE个字节</span></span><br><span class="line">    <span class="keyword">if</span> (readable &gt; MAX_FRAME_SIZE) &#123;</span><br><span class="line">      <span class="comment">// 跳过所有的可读字节，抛出 TooLongFrameException 并通知ChannelHandler</span></span><br><span class="line">      in.skipBytes(readable);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TooLongFrameException</span>(<span class="string">&quot;Frame too big!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到目前为止，我们已经探讨了解码器的常规用例，以及 Netty 所提供的用于构建它们的抽象基类。但是解码器只是硬币的一面。硬币的另一面是编码器， 它将消息转换为适合于传出传输的格式。这些编码器完备了编解码器 API，它们将是我们的下一个主题。</p>
<h2 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h2><p>回顾一下我们先前的定义，编码器实现了 <code>ChannelOutboundHandler</code>，并将出站数据从一种格式转换为另一种格式，和我们方才学习的解码器的功能正好相反。Netty 提供了一组类，用于帮助你编写具有以下功能的编码器：</p>
<ul>
<li>将消息编码为字节；</li>
<li>将消息编码为消息(另外一种格式的消息)。</li>
</ul>
<p>我们将首先从抽象基类 <code>MessageToByteEncoder</code>开始来对这些类进行考察。</p>
<h3 id="抽象类-MessageToByteEncoder"><a href="#抽象类-MessageToByteEncoder" class="headerlink" title="抽象类 MessageToByteEncoder"></a>抽象类 <code>MessageToByteEncoder</code></h3><p>前面我们看到了如何使用 <code>ByteToMessageDecoder</code> 来将字节转换为消息。现在我们将使用 <code>MessageToByteEncoder</code>来做逆向的事情。下表展示了该 API。</p>
<table>
<thead>
<tr>
<th>方 法</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td><code>encode(ChannelHandlerContext ctx, I msg, ByteBuf out)</code></td>
<td><code>encode()</code>方法是你需要实现的唯一抽象方法。它被调用时将会传入要被该类编码为 <code>ByteBuf</code> 的（类型为 <code>I</code> 的）出站消息。该 <code>ByteBuf</code>随后将会被转发给 <code>ChannelPipeline</code>中的下一个 <code>ChannelOutboundHandler</code></td>
</tr>
</tbody></table>
<p>你可能已经注意到了，这个类只有一个方法，而解码器有两个。原因是解码器通常需要在 <code>Channel</code> 关闭之后产生最后一个消息（因此也就有了 <code>decodeLast()</code>方法）。这显然不适用于编码器的场景——在连接被关闭之后仍然产生一个消息是毫无意义的。</p>
<p>下图展示了 <code>ShortToByteEncoder</code>，其接受一个 <code>Short</code>类型的实例作为消息，将它编码为 <code>Short</code>的原子类型值，并将它写入 <code>ByteBuf</code>中，其将随后被转发给 <code>ChannelPipeline</code>中的下一个 <code>ChannelOutboundHandler</code>。每个传出的 <code>Short</code>值都将会占用 <code>ByteBuf</code>中的 2 字节。</p>
<p><code>ShortToByteEncoder</code>的实现如以下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展了 MessageToByteEncoder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShortToByteEncoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToByteEncoder</span>&lt;Short&gt; &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Short msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 将 Short 写入 ByteBuf 中</span></span><br><span class="line">    out.writeShort(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Netty 提供了一些专门化的 <code>MessageToByteEncoder</code>，你可以基于它们实现自己的编码器。<code>WebSocket08FrameEncoder</code> 类提供了一个很好的实例。你可以在 <code>io.netty.handler.codec.http.websocketx</code>包中找到它。</p>
<img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/image-20240506225143929.png" alt="ShortToByteEncoder" style="zoom:33%;" />

<h3 id="抽象类-MessageToMessageEncode"><a href="#抽象类-MessageToMessageEncode" class="headerlink" title="抽象类 MessageToMessageEncode"></a>抽象类 <code>MessageToMessageEncode</code></h3><p>你已经看到了如何将入站数据从一种消息格式解码为另一种。为了完善这幅图，我们将展示对于出站数据将如何从一种消息编码为另一种。 <code>MessageToMessageEncoder</code>类的 <code>encode()</code>方法提供了这种能力，如下表所示。</p>
<table>
<thead>
<tr>
<th>名 称</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td><code>encode(ChannelHandlerContext ctx, I msg, List&lt;Object&gt; out)</code></td>
<td>这是你需要实现的唯一方法。每个通过 <code>write()</code>方法写入的消息都将会被传递给 <code>encode()</code>方法，以编码为一个或者多个出站消息。随后，这些出站消息将会被转发给 <code>ChannelPipeline</code>中的下一个 <code>ChannelOutboundHandler</code></td>
</tr>
</tbody></table>
<p>为了演示，下列代码使用 <code>IntegerToStringEncoder</code>扩展了 <code>MessageToMessageEncoder</code>。其设计如下图所示。</p>
<img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/image-20240506225446032.png" alt="IntegerToStringEncoder" style="zoom:33%;" />

<p>如以下代码所示，编码器将每个出站 <code>Integer</code>的 <code>String</code>表示添加到了该 <code>List</code>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展了 MessageToMessageEncoder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerToStringEncoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageEncoder</span>&lt;Integer&gt; &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Integer msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 将 Integer 转换为 String，并将其添加到 List 中</span></span><br><span class="line">    out.add(String.valueOf(msg));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于有趣的 <code>MessageToMessageEncoder</code> 的专业用法，请查看 <code>io.netty.handler.codec.protobuf.ProtobufEncoder</code>类，它处理了由 <code>Google</code> 的 <code>Protocol Buffers</code> 规范所定义的数据格式。</p>
<h2 id="抽象的编解码器类"><a href="#抽象的编解码器类" class="headerlink" title="抽象的编解码器类"></a>抽象的编解码器类</h2><p>虽然我们一直将解码器和编码器作为单独的实体讨论，但是你有时将会发现在同一个类中管理入站和出站数据和消息的转换是很有用的。Netty 的抽象编解码器类正好用于这个目的，因为它们每个都将捆绑一个解码器/编码器对，以处理我们一直在学习的这两种类型的操作。正如同你可能已经猜想到的，这些类同时实现了 <code>ChannelInboundHandler</code>和 <code>ChannelOutboundHandler</code>接口。</p>
<p>为什么我们并没有一直优先于单独的解码器和编码器使用这些复合类呢？因为通过尽可能地将这两种功能分开，最大化了代码的可重用性和可扩展性，这是 Netty 设计的一个基本原则。</p>
<p>在我们查看这些抽象的编解码器类时， 我们将会把它们与相应的单独的解码器和编码器进行比较和参照。</p>
<h3 id="抽象类-ByteToMessageCodec"><a href="#抽象类-ByteToMessageCodec" class="headerlink" title="抽象类 ByteToMessageCodec"></a>抽象类 <code>ByteToMessageCodec</code></h3><p>让我们来研究这样的一个场景：我们需要将字节解码为某种形式的消息，可能是 POJO，随后再次对它进行编码。<code>ByteToMessageCodec</code> 将为我们处理好这一切，因为它结合了 <code>ByteToMessageDecoder</code>以及它的逆向——<code>MessageToByteEncoder</code>。下表列出了其中重要的方法。</p>
<p>任何的请求/响应协议都可以作为使用 <code>ByteToMessageCodec</code> 的理想选择。例如，在某个 SMTP 的实现中，编解码器将读取传入字节，并将它们解码为一个自定义的消息类型，如 <code>SmtpRequest</code>（位于基于 Netty 的 SMTP/LMTP 客户端项目中）。而在接收端，当一个响应被创建时，将会产生一个 <code>SmtpResponse</code>，其将被编码回字节以便进行传输。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td><code>decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt;)</code></td>
<td>只要有字节可以被消费，这个方法就将会被调用。它将入站 <code>ByteBuf</code> 转换为指定的消息格式，并将其转发给 <code>ChannelPipeline</code>中的下一个 <code>ChannelInboundHandler</code></td>
</tr>
<tr>
<td><code>decodeLast(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</code></td>
<td>这个方法的默认实现委托给了 <code>decode()</code>方法。它只会在<code>Channel</code>的状态变为非活动时被调用一次。它可以被重写以实现特殊的处理</td>
</tr>
<tr>
<td><code>encode(ChannelHandlerContext ctx, I msg, ByteBuf out)</code></td>
<td>对于每个将被编码并写入出站 <code>ByteBuf</code> 的（类型为 <code>I</code> 的）消息来说，这个方法都将会被调用</td>
</tr>
</tbody></table>
<h3 id="抽象类-MessageToMessageCodec"><a href="#抽象类-MessageToMessageCodec" class="headerlink" title="抽象类 MessageToMessageCodec"></a>抽象类 <code>MessageToMessageCodec</code></h3><p>在上文中，你看到了一个扩展了 <code>MessageToMessageEncoder</code> 以将一种消息格式转换为另外一种消息格式的例子。通过使用 <code>MessageToMessageCodec</code>，我们可以在一个单个的类中实现该转换的往返过程。<code>MessageToMessageCodec</code>是一个参数化的类，定义如下：</p>
<p><code>public abstract class MessageToMessageCodec&lt;INBOUND_IN,OUTBOUND_IN&gt;</code></p>
<p>下表中列出了其中重要的方法。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td><code>protected abstract decode(ChannelHandlerContext ctx, INBOUND_IN msg, List&lt;Object&gt; out)</code></td>
<td>这个方法被调用时会被传入 <code>INBOUND_IN</code> 类型的消息。它将把它们解码为 <code>OUTBOUND_IN</code>类型的消息， 这些消息将被转发给 <code>ChannelPipeline</code>中的下一个 <code>ChannelInboundHandler</code></td>
</tr>
<tr>
<td><code>protected abstract encode(ChannelHandlerContext ctx, OUTBOUND_IN msg, List&lt;Object&gt; out)</code></td>
<td>对于每个 <code>OUTBOUND_IN</code>类型的消息，这个方法都将会被调用。这些消息将会被编码为 <code>INBOUND_IN</code>类型的消息，然后被转发给 <code>ChannelPipeline</code>中的下一个 <code>ChannelOutboundHandler</code></td>
</tr>
</tbody></table>
<p><code>decode()</code>方法是将 <code>INBOUND_IN</code>类型的消息转换为 <code>OUTBOUND_IN</code>类型的消息，而 <code>encode()</code>方法则进行它的逆向操作。将<code>INBOUND_IN</code>类型的消息看作是通过网络发送的类型，而将<code>OUTBOUND_IN</code>类型的消息看作是应用程序所处理的类型，将有助于理解这两个类型签名的实际意义。</p>
<p>虽然这个编解码器可能看起来有点高深，但是它所处理的用例却是相当常见的：在两种不同的消息 API 之间来回转换数据。当我们不得不和使用遗留或者专有消息格式的 API 进行互操作时，我们经常会遇到这种模式。</p>
<blockquote>
<p><strong><code>WebSocket</code> 协议</strong></p>
<p>下面关于 <code>MessageToMessageCodec</code> 的示例引用了一个新出的 <code>WebSocket</code> 协议，这个协议能实现 Web 浏览器和服务器之间的全双向通信。我们将在第 12 章中详细地讨论 Netty 对于 <code>WebSocket</code> 的支持。</p>
</blockquote>
<p>下面代码展示了这样的Web 浏览器和服务器之间的双向通信可能的实现方式。我们的<code>WebSocketConvertHandler</code>在参数化<code>MessageToMessageCodec</code>时将使用<code>INBOUND_IN</code>类型的<code>WebSocketFrame</code>，以及<code>OUTBOUND_IN</code>类型的<code>MyWebSocketFrame</code>，后者是<code>WebSocketConvertHandler</code>本身的一个静态嵌套类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConvertHandler</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageCodec</span>&lt;WebSocketFrame, WebSocketConvertHandler.MyWebSocketFrame&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将 MyWebSocketFrame 编码为指定的 WebSocketFrame子类型</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, WebSocketConvertHandler.MyWebSocketFrame msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">payload</span> <span class="operator">=</span> msg.getData().duplicate().retain();</span><br><span class="line">    <span class="comment">// 实例化一个指定子类型的 WebSocketFrame</span></span><br><span class="line">    <span class="keyword">switch</span> (msg.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> BINARY:</span><br><span class="line">        out.add(<span class="keyword">new</span> <span class="title class_">BinaryWebSocketFrame</span>(payload));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> TEXT:</span><br><span class="line">        out.add(<span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(payload));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CLOSE:</span><br><span class="line">        out.add(<span class="keyword">new</span> <span class="title class_">CloseWebSocketFrame</span>(<span class="literal">true</span>, <span class="number">0</span>, payload));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CONTINUATION:</span><br><span class="line">        out.add(<span class="keyword">new</span> <span class="title class_">ContinuationWebSocketFrame</span>(payload));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> PONG:</span><br><span class="line">        out.add(<span class="keyword">new</span> <span class="title class_">PongWebSocketFrame</span>(payload));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> PING:</span><br><span class="line">        out.add(<span class="keyword">new</span> <span class="title class_">PingWebSocketFrame</span>(payload));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">      <span class="string">&quot;Unsupported websocket msg &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 WebSocketFrame 解码为 MyWebSocketFrame，并设置 FrameType</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, WebSocketFrame msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">payload</span> <span class="operator">=</span> msg.content().duplicate().retain();</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> BinaryWebSocketFrame) &#123;</span><br><span class="line">      out.add(<span class="keyword">new</span> <span class="title class_">MyWebSocketFrame</span>(</span><br><span class="line">      MyWebSocketFrame.FrameType.BINARY, payload));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> CloseWebSocketFrame) &#123;</span><br><span class="line">      out.add(<span class="keyword">new</span> <span class="title class_">MyWebSocketFrame</span> (</span><br><span class="line">      MyWebSocketFrame.FrameType.CLOSE, payload));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> PingWebSocketFrame) &#123;</span><br><span class="line">      out.add(<span class="keyword">new</span> <span class="title class_">MyWebSocketFrame</span> (</span><br><span class="line">      MyWebSocketFrame.FrameType.PING, payload));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> PongWebSocketFrame) &#123;</span><br><span class="line">      out.add(<span class="keyword">new</span> <span class="title class_">MyWebSocketFrame</span> (</span><br><span class="line">      MyWebSocketFrame.FrameType.PONG, payload));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> TextWebSocketFrame) &#123;</span><br><span class="line">      out.add(<span class="keyword">new</span> <span class="title class_">MyWebSocketFrame</span> (</span><br><span class="line">      MyWebSocketFrame.FrameType.TEXT, payload));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ContinuationWebSocketFrame) &#123;</span><br><span class="line">      out.add(<span class="keyword">new</span> <span class="title class_">MyWebSocketFrame</span> (</span><br><span class="line">      MyWebSocketFrame.FrameType.CONTINUATION, payload));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">      <span class="string">&quot;Unsupported websocket msg &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明 WebSocketConvertHandler 所使用的 OUTBOUND_IN 类型</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MyWebSocketFrame</span> &#123;</span><br><span class="line">    <span class="comment">// 定义拥有被包装的有效负载的 WebSocketFrame的类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">FrameType</span> &#123;</span><br><span class="line">      BINARY,</span><br><span class="line">      CLOSE,</span><br><span class="line">      PING,</span><br><span class="line">      PONG,</span><br><span class="line">      TEXT,</span><br><span class="line">      CONTINUATION</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FrameType type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ByteBuf data;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyWebSocketFrame</span><span class="params">(FrameType type, ByteBuf data)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.type = type;</span><br><span class="line">      <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> FrameType <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ByteBuf <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CombinedChannelDuplexHandler-类"><a href="#CombinedChannelDuplexHandler-类" class="headerlink" title="CombinedChannelDuplexHandler 类"></a><code>CombinedChannelDuplexHandler</code> 类</h3><p>正如我们前面所提到的，结合一个解码器和编码器可能会对可重用性造成影响。但是，有一种方法既能够避免这种惩罚， 又不会牺牲将一个解码器和一个编码器作为一个单独的单元部署所带来的便利性。<code>CombinedChannelDuplexHandler</code>提供了这个解决方案，其声明为：</p>
<p><code>public class CombinedChannelDuplexHandler&lt;I extends ChannelInboundHandler, O extends ChannelOutboundHandler&gt;</code></p>
<p>这个类充当了 <code>ChannelInboundHandler</code>和 <code>ChannelOutboundHandler</code>（该类的类型参数 <code>I</code>和 <code>O</code>）的容器。通过提供分别继承了解码器类和编码器类的类型，我们可以实现一个编解码器，而又不必直接扩展抽象的编解码器类。我们将在下面的示例中说明这一点。</p>
<p>首先，让我们研究下列代码中的 <code>ByteToCharDecoder</code>。注意，该实现扩展了 <code>ByteToMessageDecoder</code>，因为它要从 <code>ByteBuf</code>中读取字符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展了 ByteToMessageDecoder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteToCharDecoder</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageDecoder</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">while</span> (in.readableBytes() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="comment">// 将一个或者多个 Character 对象添加到传出的 List 中</span></span><br><span class="line">      out.add(in.readChar());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>decode()</code>方法一次将从 <code>ByteBuf</code>中提取 2 字节，并将它们作为 <code>char</code>写入到 <code>List</code>中，其将会被自动装箱为 <code>Character</code>对象。</p>
<p>下列代码中包含了 <code>CharToByteEncoder</code>，它能将 <code>Character</code>转换回字节。这个类扩展了 <code>MessageToByteEncoder</code>，因为它需要将 <code>char</code>消息编码到 <code>ByteBuf</code>中。这是通过直接写入 <code>ByteBuf</code>做到的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展了 MessageToByteEncoder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharToByteEncoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToByteEncoder</span>&lt;Character&gt; &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Character msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 将 Character 解码为 char，并将其写入到出站 ByteBuf 中</span></span><br><span class="line">    out.writeChar(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然我们有了解码器和编码器，我们将会结合它们来构建一个编解码器。下列代码展示了这是如何做到的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过该解码器和编码器实现参数化 CombinedByteCharCodec</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CombinedByteCharCodec</span> <span class="keyword">extends</span> <span class="title class_">CombinedChannelDuplexHandler</span>&lt;ByteToCharDecoder, CharToByteEncoder&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">CombinedByteCharCodec</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 将委托实例传递给父类</span></span><br><span class="line">    <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">ByteToCharDecoder</span>(), <span class="keyword">new</span> <span class="title class_">CharToByteEncoder</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如你所能看到的，在某些情况下，通过这种方式结合实现相对于使用编解码器类的方式来说可能更加的简单也更加的灵活。当然，这可能也归结于个人的偏好问题。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">LemonGo97</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.lemongo97.com/posts/63335c7/">https://blog.lemongo97.com/posts/63335c7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.lemongo97.com" target="_blank">LemonGo97のBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Netty/">Netty</a></div><div class="post_share"><div class="social-share" data-image="https://image.lemongo97.com/Snipaste_2024-05-06_00-33-28%202.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/89f7e616/"><img class="prev-cover" data-lazy-src="https://image.lemongo97.com/Snipaste_2024-05-06_00-33-28%202.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Netty In Action -- 预置的 ChannelHandler和编解码器</div></div></a></div><div class="next-post pull-right"><a href="/posts/1050cde4/"><img class="next-cover" data-lazy-src="https://image.lemongo97.com/Snipaste_2024-05-06_00-33-28%202.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Netty In Action -- 单元测试</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/posts/d8676d75/" title="Netty In Action -- Netty的组件和设计"><img class="relatedPosts_cover" data-lazy-src="https://image.lemongo97.com/Snipaste_2024-05-06_00-33-28%202.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-06</div><div class="relatedPosts_title">Netty In Action -- Netty的组件和设计</div></div></a></div><div class="relatedPosts_item"><a href="/posts/dc761a4c/" title="Netty In Action -- 传输"><img class="relatedPosts_cover" data-lazy-src="https://image.lemongo97.com/Snipaste_2024-05-06_00-33-28%202.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-06</div><div class="relatedPosts_title">Netty In Action -- 传输</div></div></a></div><div class="relatedPosts_item"><a href="/posts/8aef8fee/" title="Netty In Action -- 核心组件"><img class="relatedPosts_cover" data-lazy-src="https://image.lemongo97.com/Snipaste_2024-05-06_00-33-28%202.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-06</div><div class="relatedPosts_title">Netty In Action -- 核心组件</div></div></a></div><div class="relatedPosts_item"><a href="/posts/599662bc/" title="Netty In Action -- BootStrap"><img class="relatedPosts_cover" data-lazy-src="https://image.lemongo97.com/Snipaste_2024-05-06_00-33-28%202.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-06</div><div class="relatedPosts_title">Netty In Action -- BootStrap</div></div></a></div><div class="relatedPosts_item"><a href="/posts/981a23ac/" title="Netty In Action -- EventLoop和线程模型"><img class="relatedPosts_cover" data-lazy-src="https://image.lemongo97.com/Snipaste_2024-05-06_00-33-28%202.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-06</div><div class="relatedPosts_title">Netty In Action -- EventLoop和线程模型</div></div></a></div><div class="relatedPosts_item"><a href="/posts/1050cde4/" title="Netty In Action -- 单元测试"><img class="relatedPosts_cover" data-lazy-src="https://image.lemongo97.com/Snipaste_2024-05-06_00-33-28%202.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-06</div><div class="relatedPosts_title">Netty In Action -- 单元测试</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By LemonGo97</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/instant.page/5.1.0/instantpage.min.js" type="module" defer></script><script src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.3.1/lazyload.iife.min.js" async></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'w7vT5VedMPyGHyDYppcacmtw-gzGzoHsz',
      appKey: 'YxBl09Aj50g5Ld621aydI4pz',
      placeholder: '来和大家一起讨论吧！',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div></div></body></html>