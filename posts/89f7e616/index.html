<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Netty In Action -- 预置的 ChannelHandler和编解码器 | LemonGo97のBlog</title><meta name="description" content="Netty 为许多通用协议提供了编解码器和处理器，几乎可以开箱即用，这减少了你在那些相当烦琐的事务上本来会花费的时间与精力。在本章中，我们将探讨这些工具以及它们所带来的好处，其中包括 Netty 对于 SSL&#x2F;TLS 和 WebSocket 的支持，以及如何简单地通过数据压缩来压榨HTTP，以获取更好的性能。 通过 SSL&#x2F;TLS 保护 Netty 应用程序如今，数据隐私是一个非常值得关注的问题，"><meta name="keywords" content="Java,Netty"><meta name="author" content="LemonGo97"><meta name="copyright" content="LemonGo97"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.lemongo97.com/posts/89f7e616/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><meta property="og:type" content="article"><meta property="og:title" content="Netty In Action -- 预置的 ChannelHandler和编解码器"><meta property="og:url" content="https://blog.lemongo97.com/posts/89f7e616/"><meta property="og:site_name" content="LemonGo97のBlog"><meta property="og:description" content="Netty 为许多通用协议提供了编解码器和处理器，几乎可以开箱即用，这减少了你在那些相当烦琐的事务上本来会花费的时间与精力。在本章中，我们将探讨这些工具以及它们所带来的好处，其中包括 Netty 对于 SSL&#x2F;TLS 和 WebSocket 的支持，以及如何简单地通过数据压缩来压榨HTTP，以获取更好的性能。 通过 SSL&#x2F;TLS 保护 Netty 应用程序如今，数据隐私是一个非常值得关注的问题，"><meta property="og:image" content="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/Snipaste_2024-05-06_00-33-28%202.png"><meta property="article:published_time" content="2024-05-06T15:29:28.000Z"><meta property="article:modified_time" content="2024-05-06T15:29:28.000Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.1.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2024-05-06 23:29:28'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="LemonGo97のBlog" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="https://coding-net-production-static-ci.codehub.cn/d70d0fa9-08d5-4fc7-ba82-7b73fee22292.jpg?imageMogr2/auto-orient/format/jpeg/cut/700x700x0x0" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">65</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">39</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-SSL-TLS-%E4%BF%9D%E6%8A%A4-Netty-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.</span> <span class="toc-text">通过 SSL&#x2F;TLS 保护 Netty 应用程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%9F%BA%E4%BA%8E-Netty-%E7%9A%84-HTTP-HTTPS-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.</span> <span class="toc-text">构建基于 Netty 的 HTTP&#x2F;HTTPS 应用程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E8%A7%A3%E7%A0%81%E5%99%A8%E3%80%81%E7%BC%96%E7%A0%81%E5%99%A8%E5%92%8C%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">HTTP 解码器、编码器和编解码器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88-HTTP-%E6%B6%88%E6%81%AF"><span class="toc-number">2.2.</span> <span class="toc-text">聚合 HTTP 消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E5%8E%8B%E7%BC%A9"><span class="toc-number">2.3.</span> <span class="toc-text">HTTP 压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-HTTPS"><span class="toc-number">2.4.</span> <span class="toc-text">使用 HTTPS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket"><span class="toc-number">2.5.</span> <span class="toc-text">WebSocket</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%92%8C%E8%B6%85%E6%97%B6"><span class="toc-number">3.</span> <span class="toc-text">空闲的连接和超时</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E7%A0%81%E5%9F%BA%E4%BA%8E%E5%88%86%E9%9A%94%E7%AC%A6%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%9F%BA%E4%BA%8E%E9%95%BF%E5%BA%A6%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.</span> <span class="toc-text">解码基于分隔符的协议和基于长度的协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%88%86%E9%9A%94%E7%AC%A6%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.1.</span> <span class="toc-text">基于分隔符的协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E9%95%BF%E5%BA%A6%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.2.</span> <span class="toc-text">基于长度的协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%A4%A7%E5%9E%8B%E6%95%B0%E6%8D%AE"><span class="toc-number">5.</span> <span class="toc-text">写大型数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E6%95%B0%E6%8D%AE"><span class="toc-number">6.</span> <span class="toc-text">序列化数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">6.1.</span> <span class="toc-text">JDK 序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-JBoss-Marshalling-%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">6.2.</span> <span class="toc-text">使用 JBoss Marshalling 进行序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-Protocol-Buffers-%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">6.3.</span> <span class="toc-text">通过 Protocol Buffers 序列化</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/Snipaste_2024-05-06_00-33-28%202.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">LemonGo97のBlog</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Netty In Action -- 预置的 ChannelHandler和编解码器</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-06T15:29:28.000Z" title="发表于 2024-05-06 23:29:28">2024-05-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-06T15:29:28.000Z" title="更新于 2024-05-06 23:29:28">2024-05-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Netty/">Netty</a></span></div><div class="meta-secondline"> </div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>Netty 为许多通用协议提供了编解码器和处理器，几乎可以开箱即用，这减少了你在那些相当烦琐的事务上本来会花费的时间与精力。在本章中，我们将探讨这些工具以及它们所带来的好处，其中包括 Netty 对于 <code>SSL/TLS</code> 和 <code>WebSocket</code> 的支持，以及如何简单地通过数据压缩来压榨HTTP，以获取更好的性能。</p>
<h2 id="通过-SSL-TLS-保护-Netty-应用程序"><a href="#通过-SSL-TLS-保护-Netty-应用程序" class="headerlink" title="通过 SSL/TLS 保护 Netty 应用程序"></a>通过 <code>SSL/TLS</code> 保护 Netty 应用程序</h2><p>如今，数据隐私是一个非常值得关注的问题，作为开发人员，我们需要准备好应对它。至少，我们应该熟悉像 SSL 和 TLS(传输层安全（TLS）协议，1.2 版)这样的安全协议，它们层叠在其他协议之上，用以实现数据安全。我们在访问安全网站时遇到过这些协议，但是它们也可用于其他不是基于 HTTP 的应用程序，如安全 SMTP（SMTPS）邮件服务器甚至是关系型数据库系统。</p>
<p>为了支持 SSL/TLS，Java 提供了 <code>javax.net.ssl</code>包，它的 <code>SSLContext</code>和 <code>SSLEngine</code>类使得实现解密和加密相当简单直接。Netty 通过一个名为 <code>SslHandler</code>的 <code>ChannelHandler</code>实现利用了这个 API，其中 <code>SslHandler</code>在内部使用 <code>SSLEngine</code>来完成实际的工作。</p>
<p>下图展示了使用 <code>SslHandler</code>的数据流</p>
<blockquote>
<p><strong>Netty 的 <code>OpenSSL/SSLEngine</code> 实现</strong></p>
<p>Netty 还提供了使用 OpenSSL 工具包的 <code>SSLEngine</code> 实现。这个 <code>OpenSslEngine</code> 类提供了比JDK 提供的 <code>SSLEngine</code>实现更好的性能。</p>
<p>如果 OpenSSL库可用，可以将 Netty 应用程序（客户端和服务器）配置为默认使用 <code>OpenSslEngine</code>。如果不可用，Netty 将会回退到 JDK 实现。有关配置 OpenSSL 支持的详细说明，参见 Netty 相关文档。</p>
<p>注意，无论你使用 JDK 的 <code>SSLEngine</code>还是使用 Netty 的 <code>OpenSslEngine</code>，SSL API 和数据流都是一致的。</p>
</blockquote>
<img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/image-20240506233504756.png" alt="通过 SslHandler进行解密和加密的数据流" style="zoom:33%;" />

<p>下边代码展示了如何使用 <code>ChannelInitializer</code>来将 <code>SslHandler</code>添加到 <code>ChannelPipeline</code>中。回想一下， <code>ChannelInitializer</code>用于在 <code>Channel</code>注册好时设置 <code>ChannelPipeline</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SslChannelInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SslContext context;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> startTls;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 传入要使用的 SslContext</span></span><br><span class="line">  <span class="comment">// 如果设置为 true，第一个写入的消息将不会被加密（客户端应该设置为 true）</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SslChannelInitializer</span><span class="params">(SslContext context, <span class="type">boolean</span> startTls)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.context = context;</span><br><span class="line">    <span class="built_in">this</span>.startTls = startTls;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 对于每个 SslHandler 实例，都使用 Channel 的 ByteBufAllocator 从 SslContext 获取一个新的 SSLEngine</span></span><br><span class="line">    <span class="type">SSLEngine</span> <span class="variable">engine</span> <span class="operator">=</span> context.newEngine(ch.alloc());</span><br><span class="line">    <span class="comment">// 将 SslHandler 作为第一个 ChannelHandler 添加到 ChannelPipeline 中</span></span><br><span class="line">    ch.pipeline().addFirst(<span class="string">&quot;ssl&quot;</span>, <span class="keyword">new</span> <span class="title class_">SslHandler</span>(engine, startTls));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在大多数情况下， <code>SslHandler</code>将是 <code>ChannelPipeline</code>中的第一个 <code>ChannelHandler</code>。这确保了只有在所有其他的 <code>ChannelHandler</code>将它们的逻辑应用到数据之后，才会进行加密。</p>
<p><code>SslHandler</code>具有一些有用的方法，如下表所示。例如，在握手阶段，两个节点将相互验证并且商定一种加密方式。你可以通过配置 <code>SslHandler</code>来修改它的行为，或者在 SSL/TLS握手一旦完成之后提供通知，握手阶段完成之后，所有的数据都将会被加密。 SSL/TLS 握手将会被自动执行。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>setHandshakeTimeout (long,TimeUnit)<br>setHandshakeTimeoutMillis (long)<br>getHandshakeTimeoutMillis()</td>
<td>设置和获取超时时间，超时之后，握手<code>ChannelFuture</code>将会被通知失败</td>
</tr>
<tr>
<td>setCloseNotifyTimeout (long,TimeUnit)<br>setCloseNotifyTimeoutMillis (long)<br>getCloseNotifyTimeoutMillis()</td>
<td>设置和获取超时时间，超时之后，将会触发一个关闭通知并关闭连接。这也将会导致通知该 <code>ChannelFuture</code>失败</td>
</tr>
<tr>
<td>handshakeFuture()</td>
<td>返回一个在握手完成后将会得到通知的<code>ChannelFuture</code>。如果握手先前已经执行过了，则返回一个包含了先前的握手结果的 <code>ChannelFuture</code></td>
</tr>
<tr>
<td>close()<br>close(ChannelPromise)<br>close(ChannelHandlerContext,ChannelPromise)</td>
<td>发送 <code>close_notify</code>以请求关闭并销毁底层的 <code>SslEngine</code></td>
</tr>
</tbody></table>
<h2 id="构建基于-Netty-的-HTTP-HTTPS-应用程序"><a href="#构建基于-Netty-的-HTTP-HTTPS-应用程序" class="headerlink" title="构建基于 Netty 的 HTTP/HTTPS 应用程序"></a>构建基于 Netty 的 HTTP/HTTPS 应用程序</h2><p>HTTP/HTTPS 是最常见的协议套件之一，并且随着智能手机的成功，它的应用也日益广泛，因为对于任何公司来说，拥有一个可以被移动设备访问的网站几乎是必需的。这些协议也被用于其他方面。许多组织导出的用于和他们的商业合作伙伴通信的 WebService API 一般也是基于HTTP（S）的。</p>
<p>接下来，我们来看看 Netty 提供的 <code>ChannelHandler</code>，你可以用它来处理 HTTP 和 HTTPS协议，而不必编写自定义的编解码器</p>
<h3 id="HTTP-解码器、编码器和编解码器"><a href="#HTTP-解码器、编码器和编解码器" class="headerlink" title="HTTP 解码器、编码器和编解码器"></a>HTTP 解码器、编码器和编解码器</h3><p>HTTP 是基于请求/响应模式的：客户端向服务器发送一个 HTTP 请求，然后服务器将会返回一个 HTTP 响应。Netty 提供了多种编码器和解码器以简化对这个协议的使用。下面两图分别展示了生产和消费 HTTP 请求和 HTTP 响应的方法。</p>
<img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/image-20240506234426076.png" alt="HTTP 请求的组成部分" style="zoom:33%;" />

<img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/image-20240506234459499.png" alt="HTTP 响应的组成部分" style="zoom:33%;" />

<p>以上两图所示，一个 HTTP 请求/响应可能由多个数据部分组成，并且它总是以一个 <code>LastHttpContent</code>部分作为结束。 <code>FullHttpRequest</code>和 <code>FullHttpResponse</code>消息是特殊的子类型，分别代表了完整的请求和响应。所有类型的 HTTP 消息（<code>FullHttpRequest</code>、<code>LastHttpContent</code>以及下列代码中展示的那些）都实现了 <code>HttpObject</code>接口。</p>
<p>下表概要地介绍了处理和生成这些消息的 HTTP 解码器和编码器。</p>
<table>
<thead>
<tr>
<th>名 称</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td><code>HttpRequestEncoder</code></td>
<td>将 <code>HttpRequest</code>、<code>HttpContent</code>和 <code>LastHttpContent</code>消息编码为字节</td>
</tr>
<tr>
<td><code>HttpResponseEncoder</code></td>
<td>将 <code>HttpResponse</code>、<code>HttpContent</code>和 <code>LastHttpContent</code>消息编码为字节</td>
</tr>
<tr>
<td><code>HttpRequestDecoder</code></td>
<td>将字节解码为 <code>HttpRequest</code>、<code>HttpContent</code>和 <code>LastHttpContent</code>消息</td>
</tr>
<tr>
<td><code>HttpResponseDecoder</code></td>
<td>将字节解码为 <code>HttpResponse</code>、<code>HttpContent</code>和 <code>LastHttpContent</code>消息</td>
</tr>
</tbody></table>
<p>下列代码中的 <code>HttpPipelineInitializer</code>类展示了将 HTTP 支持添加到你的应用程序是多么简单—几乎只需要将正确的 <code>ChannelHandler</code>添加到 <code>ChannelPipeline</code>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpPipelineInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt; &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> client;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">HttpPipelineInitializer</span><span class="params">(<span class="type">boolean</span> client)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.client = client;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (client) &#123;</span><br><span class="line">      <span class="comment">// 如果是客户端，则添加 HttpResponseDecoder 以处理来自服务器的响应</span></span><br><span class="line">      pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">HttpResponseDecoder</span>());</span><br><span class="line">      <span class="comment">// 如果是客户端，则添加 HttpRequestEncoder 以向服务器发送请求</span></span><br><span class="line">      pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">HttpRequestEncoder</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果是服务器，则添加 HttpRequestDecoder 以接收来自客户端的请求</span></span><br><span class="line">      pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">HttpRequestDecoder</span>());</span><br><span class="line">      <span class="comment">// 如果是服务器，则添加 HttpResponseEncoder 以向客户端发送响应</span></span><br><span class="line">      pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">HttpResponseEncoder</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="聚合-HTTP-消息"><a href="#聚合-HTTP-消息" class="headerlink" title="聚合 HTTP 消息"></a>聚合 HTTP 消息</h3><p>在 <code>ChannelInitializer</code>将 <code>ChannelHandler</code>安装到 <code>ChannelPipeline</code>中之后，你便可以处理不同类型的 <code>HttpObject</code>消息了。但是由于 HTTP 的请求和响应可能由许多部分组成，因此你需要聚合它们以形成完整的消息。为了消除这项烦琐的任务，Netty 提供了一个聚合器，它可以将多个消息部分合并为 <code>FullHttpRequest</code>或者 <code>FullHttpResponse</code>消息。通过这样的方式，你将总是看到完整的消息内容。</p>
<p>由于消息分段需要被缓冲，直到可以转发一个完整的消息给下一个 <code>ChannelInboundHandler</code>，所以这个操作有轻微的开销。其所带来的好处便是你不必关心消息碎片了。</p>
<p>引入这种自动聚合机制只不过是向 <code>ChannelPipeline</code> 中添加另外一个 <code>ChannelHandler</code>罢了。下列代码展示了如何做到这一点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpAggregatorInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> isClient;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">HttpAggregatorInitializer</span><span class="params">(<span class="type">boolean</span> isClient)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.isClient = isClient;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">    <span class="keyword">if</span> (isClient) &#123;</span><br><span class="line">      <span class="comment">// 如果是客户端，则添加 HttpClientCodec</span></span><br><span class="line">      pipeline.addLast(<span class="string">&quot;codec&quot;</span>, <span class="keyword">new</span> <span class="title class_">HttpClientCodec</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果是服务器，则添加 HttpServerCodec</span></span><br><span class="line">      pipeline.addLast(<span class="string">&quot;codec&quot;</span>, <span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将最大的消息大小为 512 KB的 HttpObjectAggregator 添加到 ChannelPipeline</span></span><br><span class="line">    pipeline.addLast(<span class="string">&quot;aggregator&quot;</span>, <span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(<span class="number">512</span> * <span class="number">1024</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HTTP-压缩"><a href="#HTTP-压缩" class="headerlink" title="HTTP 压缩"></a>HTTP 压缩</h3><p>当使用 HTTP 时，建议开启压缩功能以尽可能多地减小传输数据的大小。虽然压缩会带来一些 CPU 时钟周期上的开销，但是通常来说它都是一个好主意，特别是对于文本数据来说。</p>
<p>Netty 为压缩和解压缩提供了 <code>ChannelHandler</code>实现， 它们同时支持 <code>gzip</code>和 <code>deflate</code>编码。</p>
<blockquote>
<p><strong>HTTP 请求的头部信息</strong></p>
<p>客户端可以通过提供以下头部信息来指示服务器它所支持的压缩格式：</p>
  <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/encrypted-area</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br></pre></td></tr></table></figure>

<p>然而，需要注意的是，服务器没有义务压缩它所发送的数据。</p>
</blockquote>
<p>下列代码展示了一个例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpCompressionInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> isClient;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">HttpCompressionInitializer</span><span class="params">(<span class="type">boolean</span> isClient)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.isClient = isClient;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">    <span class="keyword">if</span> (isClient) &#123;</span><br><span class="line">      <span class="comment">// 如果是客户端， 则添加 HttpClientCodec</span></span><br><span class="line">      pipeline.addLast(<span class="string">&quot;codec&quot;</span>, <span class="keyword">new</span> <span class="title class_">HttpClientCodec</span>());</span><br><span class="line">      <span class="comment">// 如果是客户端，则添加 HttpContentDecompressor 以处理来自服务器的压缩内容</span></span><br><span class="line">      pipeline.addLast(<span class="string">&quot;decompressor&quot;</span>, <span class="keyword">new</span> <span class="title class_">HttpContentDecompressor</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果是服务器，则添加 HttpServerCodec</span></span><br><span class="line">      pipeline.addLast(<span class="string">&quot;codec&quot;</span>, <span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());</span><br><span class="line">      <span class="comment">// 如果是服务器，则添加 HttpContentCompressor 来压缩数据（如果客户端支持它）</span></span><br><span class="line">      pipeline.addLast(<span class="string">&quot;compressor&quot;</span>, <span class="keyword">new</span> <span class="title class_">HttpContentCompressor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>压缩及其依赖</strong></p>
<p>如果你正在使用的是 JDK 6 或者更早的版本，那么你需要将 <code>JZlib</code> 添加到 <code>CLASSPATH</code> 中以支持压缩功能。</p>
<p>对于 Maven，请添加以下依赖项：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.jcraft<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jzlib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="使用-HTTPS"><a href="#使用-HTTPS" class="headerlink" title="使用 HTTPS"></a>使用 HTTPS</h3><p>如下代码显示，启用 HTTPS 只需要将 <code>SslHandler</code> 添加到 <code>ChannelPipeline</code> 的 <code>ChannelHandler</code>组合中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpsCodecInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SslContext context;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> isClient;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">HttpsCodecInitializer</span><span class="params">(SslContext context, <span class="type">boolean</span> isClient)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.context = context;</span><br><span class="line">    <span class="built_in">this</span>.isClient = isClient;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">    <span class="type">SSLEngine</span> <span class="variable">engine</span> <span class="operator">=</span> context.newEngine(ch.alloc());</span><br><span class="line">    <span class="comment">// 将 SslHandler 添加到 ChannelPipeline 中以使用 HTTPS</span></span><br><span class="line">    pipeline.addFirst(<span class="string">&quot;ssl&quot;</span>, <span class="keyword">new</span> <span class="title class_">SslHandler</span>(engine));</span><br><span class="line">    <span class="keyword">if</span> (isClient) &#123;</span><br><span class="line">      <span class="comment">// 如果是客户端，则添加 HttpClientCodec</span></span><br><span class="line">      pipeline.addLast(<span class="string">&quot;codec&quot;</span>, <span class="keyword">new</span> <span class="title class_">HttpClientCodec</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果是服务器，则添加 HttpServerCodec</span></span><br><span class="line">      pipeline.addLast(<span class="string">&quot;codec&quot;</span>, <span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面的代码是一个很好的例子， 说明了 Netty 的架构方式是如何将代码重用变为杠杆作用的。只需要简单地将一个 <code>ChannelHandler</code> 添加到 <code>ChannelPipeline</code> 中，便可以提供一项新功能，甚至像加密这样重要的功能都能提供。</p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a><code>WebSocket</code></h3><p>Netty 针对基于 HTTP 的应用程序的广泛工具包中包括了对它的一些最先进的特性的支持。在这一节中，我们将探讨 <code>WebSocket</code> ——一种在 2011 年被互联网工程任务组（IETF）标准化的协议。</p>
<p><code>WebSocket</code> 解决了一个长期存在的问题：既然底层的协议（HTTP）是一个请求/响应模式的交互序列，那么如何实时地发布信息呢？AJAX 提供了一定程度上的改善，但是数据流仍然是由客户端所发送的请求驱动的。还有其他的一些或多或少的取巧方式，但是最终它们仍然属于扩展性受限的变通之法。</p>
<p><code>WebSocket</code> 规范以及它的实现代表了对一种更加有效的解决方案的尝试。简单地说，<code>WebSocket</code> 提供了“在一个单个的 TCP 连接上提供双向的通信……结合 <code>WebSocket API</code>……它为网页和远程服务器之间的双向通信提供了一种替代 HTTP 轮询的方案。 ”</p>
<p>也就是说，<code>WebSocket</code> 在客户端和服务器之间提供了真正的双向数据交换。我们不会深入地描述太多的内部细节，但是我们还是应该提到，尽管最早的实现仅限于文本数据，但是现在已经不是问题了；<code>WebSocket</code> 现在可以用于传输任意类型的数据，很像普通的套接字。</p>
<p>下图给出了 <code>WebSocket</code> 协议的一般概念。在这个场景下，通信将作为普通的 HTTP 协议开始，随后升级到双向的 <code>WebSocket</code> 协议。</p>
<p>要想向你的应用程序中添加对于 <code>WebSocket</code> 的支持，你需要将适当的客户端或者服务器<code>WebSocketChannelHandler</code>添加到 <code>ChannelPipeline</code>中。 这个类将处理由 <code>WebSocket</code> 定义的称为帧的特殊消息类型。 如下表所示， <code>WebSocketFrame</code>可以被归类为数据帧或者控制帧。</p>
<img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/image-20240507000827503.png" alt="WebSocket 协议" style="zoom:33%;" />

<table>
<thead>
<tr>
<th>名 称</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td><code>BinaryWebSocketFrame</code></td>
<td>数据帧：二进制数据</td>
</tr>
<tr>
<td><code>TextWebSocketFrame</code></td>
<td>数据帧：文本数据</td>
</tr>
<tr>
<td><code>ContinuationWebSocketFrame</code></td>
<td>数据帧： 属于上一个 <code>BinaryWebSocketFrame</code>或者 <code>TextWebSocketFrame</code>的二进制或者文本数据</td>
</tr>
<tr>
<td><code>CloseWebSocketFrame</code></td>
<td>控制帧：一个 <code>CLOSE</code>请求、关闭的状态码以及关闭的原因</td>
</tr>
<tr>
<td><code>PingWebSocketFrame</code></td>
<td>控制帧：请求一个 <code>PongWebSocketFrame</code></td>
</tr>
<tr>
<td><code>PongWebSocketFrame</code></td>
<td>控制帧：对 <code>PingWebSocketFrame</code>请求的响应</td>
</tr>
</tbody></table>
<p>因为 Netty 主要是一种服务器端的技术，所以在这里我们重点创建 <code>WebSocket</code> 服务器。下列代码展示了一个使用 <code>WebSocketServerProtocolHandler</code>的简单示例，这个类处理协议升级握手，以及 3 种控制帧——<code>Close</code>、 <code>Ping</code>和 <code>Pong</code>。 <code>Text</code>和 <code>Binary</code>数据帧将会被传递给下一个（由你实现的）<code>ChannelHandler</code>进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketServerInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    ch.pipeline().addLast(</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>(),</span><br><span class="line">      <span class="comment">// 为握手提供聚合的HttpRequest</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(<span class="number">65536</span>),</span><br><span class="line">      <span class="comment">// 如果被请求的端点是&quot;/websocket&quot;，则处理该升级握手</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">WebSocketServerProtocolHandler</span>(<span class="string">&quot;/websocket&quot;</span>),</span><br><span class="line">      <span class="comment">// TextFrameHandler 处理 TextWebSocketFrame</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">TextFrameHandler</span>(),</span><br><span class="line">      <span class="comment">// BinaryFrameHandler 处理 BinaryWebSocketFrame</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">BinaryFrameHandler</span>(),</span><br><span class="line">      <span class="comment">// ContinuationFrameHandler 处理 ContinuationWebSocketFrame</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ContinuationFrameHandler</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TextFrameHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;TextWebSocketFrame&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="comment">// Handle text frame</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">BinaryFrameHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;BinaryWebSocketFrame&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, BinaryWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="comment">// Handle binary frame</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ContinuationFrameHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;ContinuationWebSocketFrame&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ContinuationWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="comment">// Handle continuation frame</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>保护 <code>WebSocket</code></strong></p>
<p>要想为 <code>WebSocket</code> 添加安全性，只需要将 <code>SslHandler</code> 作为第一个 <code>ChannelHandler</code> 添加到 <code>ChannelPipeline</code>中。</p>
</blockquote>
<h2 id="空闲的连接和超时"><a href="#空闲的连接和超时" class="headerlink" title="空闲的连接和超时"></a>空闲的连接和超时</h2><p>到目前为止，我们的讨论都集中在 Netty 通过专门的编解码器和处理器对 HTTP 的变型 HTTPS 和 <code>WebSocket</code> 的支持上。只要你有效地管理你的网络资源，这些技术就可以使得你的应用程序更加高效、易用和安全。所以，让我们一起来探讨下首先需要关注的——连接管理吧。</p>
<p>检测空闲连接以及超时对于及时释放资源来说是至关重要的。由于这是一项常见的任务，Netty 特地为它提供了几个 <code>ChannelHandler</code>实现。下表给出了它们的概述。</p>
<table>
<thead>
<tr>
<th>名 称</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td><code>IdleStateHandler</code></td>
<td>当连接空闲时间太长时，将会触发一个 <code>IdleStateEvent</code>事件。然后，你可以通过在你的 <code>ChannelInboundHandler</code> 中重写 <code>userEventTriggered()</code>方法来处理该 <code>IdleStateEvent</code>事件</td>
</tr>
<tr>
<td><code>ReadTimeoutHandler</code></td>
<td>如果在指定的时间间隔内没有收到任何的入站数据，则抛出一个 <code>ReadTimeoutException</code> 并关闭对应的<code>Channel</code>。可以通过重写你的<code>ChannelHandler</code> 中的 <code>exceptionCaught()</code>方法来检测该 <code>ReadTimeoutException</code></td>
</tr>
<tr>
<td><code>WriteTimeoutHandler</code></td>
<td>如果在指定的时间间隔内没有任何出站数据写入，则抛出一个 <code>WriteTimeoutException</code> 并关闭对应的 <code>Channel</code>。可以通过重写你的<code>ChannelHandler</code>的 <code>exceptionCaught()</code>方法检测该 <code>WriteTimeoutException</code></td>
</tr>
</tbody></table>
<p>让我们仔细看看在实践中使用得最多的 <code>IdleStateHandler</code> 吧。下列代码展示了当使用通常的发送心跳消息到远程节点的方法时，如果在 60 秒之内没有接收或者发送任何的数据，我们将如何得到通知；如果没有响应，则连接会被关闭。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdleStateHandlerInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">    <span class="comment">// 1. IdleStateHandler 将在被触发时发送一个 IdleStateEvent 事件</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">60</span>, TimeUnit.SECONDS));</span><br><span class="line">    <span class="comment">// 将一个 HeartbeatHandler添加到ChannelPipeline 中</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">HeartbeatHandler</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现 userEventTriggered()方法以发送心跳消息</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HeartbeatHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送到远程节点的心跳消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ByteBuf</span> <span class="variable">HEARTBEAT_SEQUENCE</span> <span class="operator">=</span> Unpooled.unreleasableBuffer(Unpooled.copiedBuffer(<span class="string">&quot;HEARTBEAT&quot;</span>, CharsetUtil.ISO_8859_1));</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">        <span class="comment">// 2. 发送心跳消息，并在发送失败时关闭该连接</span></span><br><span class="line">        ctx.writeAndFlush(HEARTBEAT_SEQUENCE.duplicate())</span><br><span class="line">        .addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不是 IdleStateEvent事件，所以将它传递给下一个 ChannelInboundHandler</span></span><br><span class="line">        <span class="built_in">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例演示了如何使用 <code>IdleStateHandler</code>来测试远程节点是否仍然还活着， 并且在它失活时通过关闭连接来释放资源。</p>
<p>如果连接超过 60 秒没有接收或者发送任何的数据，那么 <code>IdleStateHandler</code> 将会使用一个<code>IdleStateEvent</code>事件来调用 <code>fireUserEventTriggered()</code>方法。<code>HeartbeatHandler</code>实现了 <code>userEventTriggered()</code>方法，如果这个方法检测到 <code>IdleStateEvent</code>事件，它将会发送心跳消息，并且添加一个将在发送操作失败时关闭该连接的 <code>ChannelFutureListener</code> 。</p>
<h2 id="解码基于分隔符的协议和基于长度的协议"><a href="#解码基于分隔符的协议和基于长度的协议" class="headerlink" title="解码基于分隔符的协议和基于长度的协议"></a>解码基于分隔符的协议和基于长度的协议</h2><p>在使用 Netty 的过程中，你将会遇到需要解码器的基于分隔符和帧长度的协议。下一节将解释 Netty 所提供的用于处理这些场景的实现。</p>
<h3 id="基于分隔符的协议"><a href="#基于分隔符的协议" class="headerlink" title="基于分隔符的协议"></a>基于分隔符的协议</h3><p>基于分隔符的（<code>delimited</code>）消息协议使用定义的字符来标记的消息或者消息段（通常被称为帧） 的开头或者结尾。 由 RFC 文档正式定义的许多协议 （如 SMTP、 POP3、 IMAP 以及 Telnet）都是这样的。此外，当然，私有组织通常也拥有他们自己的专有格式。无论你使用什么样的协议，下表中列出的解码器都能帮助你定义可以提取由任意标记（token）序列分隔的帧的自定义解码器。</p>
<table>
<thead>
<tr>
<th>名 称</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td><code>DelimiterBasedFrameDecoder</code></td>
<td>使用任何由用户提供的分隔符来提取帧的通用解码器</td>
</tr>
<tr>
<td><code>LineBasedFrameDecoder</code></td>
<td>提取由行尾符（<code>\n</code>或者<code>\r\n</code>）分隔的帧的解码器。这个解码器比 <code>DelimiterBasedFrameDecoder</code>更快</td>
</tr>
</tbody></table>
<p>下图展示了当帧由行尾序列<code>\r\n</code>（回车符+换行符）分隔时是如何被处理的。</p>
<img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/image-20240507003026959.png" alt="由行尾符分隔的帧" style="zoom:33%;" />

<p>下列代码展示了如何使用 <code>LineBasedFrameDecoder</code>来处理上图所示的场景</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LineBasedHandlerInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">    <span class="comment">// 该 LineBasedFrameDecoder 将提取的帧转发给下一个 ChannelInboundHandler</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">LineBasedFrameDecoder</span>(<span class="number">64</span> * <span class="number">1024</span>));</span><br><span class="line">    <span class="comment">// 添加 FrameHandler 以接收帧</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">FrameHandler</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FrameHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;ByteBuf&gt; &#123;</span><br><span class="line">    <span class="comment">// 传入了单个帧的内容</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="comment">// Do something with the data extracted from the frame</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你正在使用除了行尾符之外的分隔符分隔的帧，那么你可以以类似的方式使用 <code>DelimiterBasedFrameDecoder</code>，只需要将特定的分隔符序列指定到其构造函数即可。</p>
<p>这些解码器是实现你自己的基于分隔符的协议的工具。作为示例，我们将使用下面的协议规范：</p>
<p>传入数据流是一系列的帧，每个帧都由换行符（<code>\n</code>）分隔；</p>
<ul>
<li>每个帧都由一系列的元素组成，每个元素都由单个空格字符分隔；</li>
<li>一个帧的内容代表一个命令，定义为一个命令名称后跟着数目可变的参数。</li>
</ul>
<p>我们用于这个协议的自定义解码器将定义以下类：</p>
<ul>
<li><code>Cmd</code> —将帧（命令）的内容存储在 <code>ByteBuf</code> 中，一个 <code>ByteBuf</code> 用于名称，另一个用于参数；</li>
<li><code>CmdDecoder</code> —从被重写了的 <code>decode()</code>方法中获取一行字符串，并从它的内容构建一个 <code>Cmd</code>的实例；</li>
<li><code>CmdHandler</code> —从 <code>CmdDecoder</code>获取解码的 <code>Cmd</code>对象，并对它进行一些处理；</li>
<li><code>CmdHandlerInitializer</code> —为了简便起见，我们将会把前面的这些类定义为专门的 <code>ChannelInitializer</code>的嵌套类，其将会把这些 <code>ChannelInboundHandler</code>安装到 <code>ChannelPipeline</code>中。</li>
</ul>
<p>正如将在下列代码中所能看到的那样，这个解码器的关键是扩展 <code>LineBasedFrameDecoder</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CmdHandlerInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">SPACE</span> <span class="operator">=</span> (<span class="type">byte</span>)<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">    <span class="comment">// 添加 CmdDecoder 以提取 Cmd 对象，并将它转发给下一个 ChannelInboundHandler</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">CmdDecoder</span>(<span class="number">64</span> * <span class="number">1024</span>));</span><br><span class="line">    <span class="comment">// 添加 CmdHandler 以接收和处理 Cmd 对象</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">CmdHandler</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cmd POJO</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Cmd</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ByteBuf name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ByteBuf args;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cmd</span><span class="params">(ByteBuf name, ByteBuf args)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="built_in">this</span>.args = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ByteBuf <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ByteBuf <span class="title function_">args</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> args;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CmdDecoder</span> <span class="keyword">extends</span> <span class="title class_">LineBasedFrameDecoder</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CmdDecoder</span><span class="params">(<span class="type">int</span> maxLength)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(maxLength);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf buffer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="comment">// 从 ByteBuf 中提取由行尾符序列分隔的帧</span></span><br><span class="line">      <span class="type">ByteBuf</span> <span class="variable">frame</span> <span class="operator">=</span> (ByteBuf) <span class="built_in">super</span>.decode(ctx, buffer);</span><br><span class="line">      <span class="keyword">if</span> (frame == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果输入中没有帧，则返回 null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 查找第一个空格字符的索引。前面是命令名称，接着是参数</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> frame.indexOf(frame.readerIndex(), frame.writerIndex(), SPACE);</span><br><span class="line">      <span class="comment">// 使用包含有命令名称和参数的切片创建新的 Cmd 对象</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cmd</span>(frame.slice(frame.readerIndex(), index), frame.slice(index + <span class="number">1</span>, frame.writerIndex()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CmdHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;Cmd&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Cmd msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="comment">// 处理传经 ChannelPipeline 的 Cmd 对象</span></span><br><span class="line">      <span class="comment">// Do something with the command</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="基于长度的协议"><a href="#基于长度的协议" class="headerlink" title="基于长度的协议"></a>基于长度的协议</h3><p>基于长度的协议通过将它的长度编码到帧的头部来定义帧，而不是使用特殊的分隔符来标记它的结束（对于固定帧大小的协议来说，不需要将帧长度编码到头部）。下表列出了Netty提供的用于处理这种类型的协议的两种解码器。</p>
<table>
<thead>
<tr>
<th>名 称</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td><code>FixedLengthFrameDecoder</code></td>
<td>提取在调用构造函数时指定的定长帧</td>
</tr>
<tr>
<td><code>LengthFieldBasedFrameDecoder</code></td>
<td>根据编码进帧头部中的长度值提取帧；该字段的偏移量以及长度在构造函数中指定</td>
</tr>
</tbody></table>
<p>下图展示了 <code>FixedLengthFrameDecoder</code> 的功能，其在构造时已经指定了帧长度为 8 字节。</p>
<img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/image-20240507004455114.png" alt="解码长度为 8 字节的帧" style="zoom:30%;" />

<p>你将经常会遇到被编码到消息头部的帧大小不是固定值的协议。为了处理这种变长帧，你可以使用 <code>LengthFieldBasedFrameDecoder</code>， 它将从头部字段确定帧长，然后从数据流中提取指定的字节数。</p>
<p>下图展示了一个示例，其中长度字段在帧中的偏移量为 0，并且长度为 2 字节。</p>
<img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/image-20240507004639800.png" alt="将变长帧大小编码进头部的消息" style="zoom:33%;" />

<p><code>LengthFieldBasedFrameDecoder</code> 提供了几个构造函数来支持各种各样的头部配置情况。下列代码展示了如何使用其 3 个构造参数分别为 <code>maxFrameLength</code>、 <code>lengthFieldOffset</code>和 <code>lengthFieldLength</code>的构造函数。在这个场景中，帧的长度被编码到了帧起始的前8 个字节中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LengthBasedInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt; &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">    <span class="comment">// 使用 LengthFieldBasedFrameDecoder 解码将帧长度编码到帧起始的前 8 个字节中的消息</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">64</span> * <span class="number">1024</span>, <span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">    <span class="comment">// 添加 FrameHandler 以处理每个帧</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">FrameHandler</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FrameHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;ByteBuf&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="comment">// 处理帧的数据</span></span><br><span class="line">      <span class="comment">// Do something with the frame</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你现在已经看到了 Netty 提供的，用于支持那些通过指定协议帧的分隔符或者长度（固定的或者可变的）以定义字节流的结构的协议的编解码器。你将会发现这些编解码器的许多用途，因为许多的常见协议都落到了这些分类之一中。</p>
<h2 id="写大型数据"><a href="#写大型数据" class="headerlink" title="写大型数据"></a>写大型数据</h2><p>因为网络饱和的可能性，如何在异步框架中高效地写大块的数据是一个特殊的问题。由于写操作是非阻塞的，所以即使没有写出所有的数据，写操作也会在完成时返回并通知 <code>ChannelFuture</code>。当这种情况发生时，如果仍然不停地写入，就有内存耗尽的风险。所以在写大型数据时，需要准备好处理到远程节点的连接是慢速连接的情况， 这种情况会导致内存释放的延迟。让我们考虑下将一个文件内容写出到网络的情况。</p>
<p>在我们讨论传输的过程中，提到了 NIO 的零拷贝特性，这种特性消除了将文件的内容从文件系统移动到网络栈的复制过程。所有的这一切都发生在 Netty 的核心中，所以应用程序所有需要做的就是使用一个 <code>FileRegion</code>接口的实现，其在 Netty 的 API 文档中的定义是：“通过支持零拷贝的文件传输的 <code>Channel</code>来发送的文件区域。”</p>
<p>下列代码展示了如何通过从<code>FileInputStream</code>创建一个<code>DefaultFileRegion</code>，并将其写入<code>Channel</code>，从而利用零拷贝特性来传输一个文件的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 FileInputStream</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"><span class="comment">// 以该文件的完整长度创建一个新的 DefaultFileRegion</span></span><br><span class="line"><span class="type">FileRegion</span> <span class="variable">region</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFileRegion</span>(in.getChannel(), <span class="number">0</span>, file.length());</span><br><span class="line"><span class="comment">// 发送该 DefaultFileRegion，并注册一个 ChannelFutureListener</span></span><br><span class="line">channel.writeAndFlush(region).addListener(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">        <span class="comment">// 处理失败</span></span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> future.cause();</span><br><span class="line">        <span class="comment">// Do something</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>这个示例只适用于文件内容的直接传输，不包括应用程序对数据的任何处理。在需要将数据从文件系统复制到用户内存中时，可以使用 <code>ChunkedWriteHandler</code>，它支持异步写大型数据流，而又不会导致大量的内存消耗。</p>
<p>关键是 <code>interface ChunkedInput&lt;B&gt;</code>，其中类型参数 <code>B</code> 是 <code>readChunk()</code>方法返回的类型。 Netty 预置了该接口的 4 个实现，如下表中所列出的。每个都代表了一个将由 <code>ChunkedWriteHandler</code>处理的不定长度的数据流。</p>
<p>下列代码说明了 <code>ChunkedStream</code>的用法， 它是实践中最常用的实现。所示的类使用了一个 <code>File</code> 以及一个 <code>SslContext</code> 进行实例化。当 <code>initChannel()</code>方法被调用时，它将使用所示的 <code>ChannelHandler</code>链初始化该 <code>Channel</code>。</p>
<table>
<thead>
<tr>
<th>名 称</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td><code>ChunkedFile</code></td>
<td>从文件中逐块获取数据，当你的平台不支持零拷贝或者你需要转换数据时使用</td>
</tr>
<tr>
<td><code>ChunkedNioFile</code></td>
<td>和 <code>ChunkedFile</code>类似，只是它使用了 <code>FileChannel</code></td>
</tr>
<tr>
<td><code>ChunkedStream</code></td>
<td>从 <code>InputStream</code>中逐块传输内容</td>
</tr>
<tr>
<td><code>ChunkedNioStream</code></td>
<td>从 <code>ReadableByteChannel</code>中逐块传输内容</td>
</tr>
</tbody></table>
<p>当 <code>Channel</code>的状态变为活动的时，<code>WriteStreamHandler</code>将会逐块地把来自文件中的数据作为 <code>ChunkedStream</code>写入。数据在传输之前将会由 <code>SslHandler</code>加密。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChunkedWriteHandlerInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> File file;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SslContext sslCtx;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ChunkedWriteHandlerInitializer</span><span class="params">(File file, SslContext sslCtx)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.file = file;</span><br><span class="line">    <span class="built_in">this</span>.sslCtx = sslCtx;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">    <span class="comment">// 将 SslHandler 添加到 ChannelPipeline 中</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">SslHandler</span>(sslCtx.newEngine(ch.alloc());</span><br><span class="line">    <span class="comment">// 添加 ChunkedWriteHandler 以处理作为 ChunkedInput 传入的数据</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ChunkedWriteHandler</span>());</span><br><span class="line">    <span class="comment">// 一旦连接建立，WriteStreamHandler 就开始写文件数据</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">WriteStreamHandler</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WriteStreamHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 当连接建立时，channelActive() 方法将使用 ChunkedInput 写文件数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="built_in">super</span>.channelActive(ctx);</span><br><span class="line">      ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">ChunkedStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>逐块输入</strong> 要使用你自己的 <code>ChunkedInput</code> 实现，请在 <code>ChannelPipeline</code> 中安装一个 <code>ChunkedWriteHandler</code>。</p>
</blockquote>
<p>在本节中，我们讨论了如何通过使用零拷贝特性来高效地传输文件，以及如何通过使用 <code>ChunkedWriteHandler</code>来写大型数据而又不必冒着导致 <code>OutOfMemoryError</code>的风险。在下一节中，我们将仔细研究几种序列化 POJO 的方法。</p>
<h2 id="序列化数据"><a href="#序列化数据" class="headerlink" title="序列化数据"></a>序列化数据</h2><p>JDK 提供了 <code>ObjectOutputStream</code>和 <code>ObjectInputStream</code>，用于通过网络对 POJO 的基本数据类型和图进行序列化和反序列化。该 API 并不复杂，而且可以被应用于任何实现了<code>java.io.Serializable</code> 接口的对象。但是它的性能也不是非常高效的。在这一节中，我们将看到 Netty 必须为此提供什么。</p>
<h3 id="JDK-序列化"><a href="#JDK-序列化" class="headerlink" title="JDK 序列化"></a>JDK 序列化</h3><p>如果你的应用程序必须要和使用了 <code>ObjectOutputStream</code>和 <code>ObjectInputStream</code>的远程节点交互，并且兼容性也是你最关心的，那么 JDK 序列化将是正确的选择。下表中列出了Netty 提供的用于和 JDK 进行互操作的序列化类。</p>
<table>
<thead>
<tr>
<th>名 称</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td><code>CompatibleObjectDecoder</code>(已废弃)</td>
<td>和使用 JDK 序列化的非基于 Netty 的远程节点进行互操作的解码器</td>
</tr>
<tr>
<td><code>CompatibleObjectEncoder</code></td>
<td>和使用 JDK 序列化的非基于 Netty 的远程节点进行互操作的编码器</td>
</tr>
<tr>
<td><code>ObjectDecoder</code></td>
<td>构建于 JDK 序列化之上的使用自定义的序列化来解码的解码器；当没有其他的外部依赖时，它提供了速度上的改进。否则其他的序列化实现更加可取</td>
</tr>
<tr>
<td><code>ObjectEncoder</code></td>
<td>构建于 JDK 序列化之上的使用自定义的序列化来编码的编码器；当没有其他的外部依赖时，它提供了速度上的改进。否则其他的序列化实现更加可取</td>
</tr>
</tbody></table>
<h3 id="使用-JBoss-Marshalling-进行序列化"><a href="#使用-JBoss-Marshalling-进行序列化" class="headerlink" title="使用 JBoss Marshalling 进行序列化"></a>使用 <code>JBoss Marshalling</code> 进行序列化</h3><p>如果你可以自由地使用外部依赖，那么 JBoss Marshalling 将是个理想的选择：它比 JDK 序列化最多快 3 倍，而且也更加紧凑。在 JBoss Marshalling 官方网站主页上的概述中对它是这么定义的：</p>
<blockquote>
<p>JBoss Marshalling 是一种可选的序列化 API， 它修复了在 JDK 序列化 API 中所发现的许多问题，同时保留了与 <code>java.io.Serializable</code> 及其相关类的兼容性，并添加了几个新的可调优参数以及额外的特性，所有的这些都是可以通过工厂配置（如外部序列化器、类/实例查找表、类解析以及对象替换等）实现可插拔的。</p>
</blockquote>
<p>Netty 通过下表所示的两组解码器/编码器对为 <code>JBoss Marshalling</code> 提供了支持。第一组兼容只使用 JDK 序列化的远程节点。第二组提供了最大的性能，适用于和使用 JBoss Marshalling 的远程节点一起使用。</p>
<table>
<thead>
<tr>
<th>名 称</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td><code>CompatibleMarshallingDecoder</code><br><code>CompatibleMarshallingEncoder</code></td>
<td>与只使用 JDK 序列化的远程节点兼容</td>
</tr>
<tr>
<td><code>MarshallingDecoder</code><br><code>MarshallingEncoder</code></td>
<td>适用于使用 JBoss Marshalling 的节点。这些类必须一起使用</td>
</tr>
</tbody></table>
<p>下列代码展示了如何使用 <code>MarshallingDecoder</code>和 <code>MarshallingEncoder</code>。同样，几乎只是适当地配置 <code>ChannelPipeline</code>罢了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MarshallingInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MarshallerProvider marshallerProvider;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> UnmarshallerProvider unmarshallerProvider;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MarshallingInitializer</span><span class="params">(UnmarshallerProvider unmarshallerProvider, MarshallerProvider marshallerProvider)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.marshallerProvider = marshallerProvider;</span><br><span class="line">    <span class="built_in">this</span>.unmarshallerProvider = unmarshallerProvider;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> channel.pipeline();</span><br><span class="line">    <span class="comment">// 添加 MarshallingDecoder 以将 ByteBuf 转换为 POJO</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">MarshallingDecoder</span>(unmarshallerProvider));</span><br><span class="line">    <span class="comment">// 添加 MarshallingEncoder 以将 POJO转换为 ByteBuf</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">MarshallingEncoder</span>(marshallerProvider));</span><br><span class="line">    <span class="comment">// 添加 ObjectHandler，以处理普通的实现</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ObjectHandler</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ObjectHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;Serializable&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, Serializable serializable)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="comment">// Do something</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过-Protocol-Buffers-序列化"><a href="#通过-Protocol-Buffers-序列化" class="headerlink" title="通过 Protocol Buffers 序列化"></a>通过 <code>Protocol Buffers</code> 序列化</h3><p>Netty 序列化的最后一个解决方案是利用 <code>Protocol Buffers</code> 的编解码器，它是一种由 Google公司开发的、现在已经开源的数据交换格式。</p>
<p><code>Protocol Buffers</code> 以一种紧凑而高效的方式对结构化的数据进行编码以及解码。它具有许多的编程语言绑定，使得它很适合跨语言的项目。下表展示了 Netty 为支持 <code>protobuf</code> 所提供的<code>ChannelHandler</code>实现。</p>
<table>
<thead>
<tr>
<th>名 称</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td><code>ProtobufDecoder</code></td>
<td>使用 <code>protobuf</code> 对消息进行解码</td>
</tr>
<tr>
<td><code>ProtobufEncoder</code></td>
<td>使用 <code>protobuf</code> 对消息进行编码</td>
</tr>
<tr>
<td><code>ProtobufVarint32FrameDecoder</code></td>
<td>根据消息中的 Google Protocol Buffers 的“<code>Base 128 Varints</code>” 整型长度字段值动态地分割所接收到的 <code>ByteBuf</code></td>
</tr>
<tr>
<td><code>ProtobufVarint32LengthFieldPrepender</code></td>
<td>向 ByteBuf前追加一个 Google Protocal Buffers 的 “<code>Base128 Varints</code>”整型的长度字段值</td>
</tr>
</tbody></table>
<p>在这里我们又看到了，使用 <code>protobuf</code> 只不过是将正确的 <code>ChannelHandler</code>添加到 <code>ChannelPipeline</code>中，如以下代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProtoBufInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MessageLite lite;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ProtoBufInitializer</span><span class="params">(MessageLite lite)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.lite = lite;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">    <span class="comment">// 添加 ProtobufVarint32FrameDecoder以分隔帧</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ProtobufVarint32FrameDecoder</span>());</span><br><span class="line">    <span class="comment">// 添加 ProtobufEncoder以处理消息的编码</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ProtobufEncoder</span>()); </span><br><span class="line">    <span class="comment">// 添加 ProtobufDecoder以解码消息</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ProtobufDecoder</span>(lite));</span><br><span class="line">    <span class="comment">// 添加 ObjectHandler 以处理解码消息</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ObjectHandler</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ObjectHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="comment">// Do something with the object</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这一节中，我们探讨了由 Netty 专门的解码器和编码器所支持的不同的序列化选项：标准JDK 序列化、JBoss Marshalling 以及 Google 的 Protocol Buffers。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">LemonGo97</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.lemongo97.com/posts/89f7e616/">https://blog.lemongo97.com/posts/89f7e616/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.lemongo97.com" target="_blank">LemonGo97のBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Netty/">Netty</a></div><div class="post_share"><div class="social-share" data-image="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/Snipaste_2024-05-06_00-33-28%202.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/63335c7/"><img class="next-cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/Snipaste_2024-05-06_00-33-28%202.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Netty In Action -- 编解码器框架</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/posts/d8676d75/" title="Netty In Action -- Netty的组件和设计"><img class="relatedPosts_cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/Snipaste_2024-05-06_00-33-28%202.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-06</div><div class="relatedPosts_title">Netty In Action -- Netty的组件和设计</div></div></a></div><div class="relatedPosts_item"><a href="/posts/dc761a4c/" title="Netty In Action -- 传输"><img class="relatedPosts_cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/Snipaste_2024-05-06_00-33-28%202.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-06</div><div class="relatedPosts_title">Netty In Action -- 传输</div></div></a></div><div class="relatedPosts_item"><a href="/posts/8aef8fee/" title="Netty In Action -- 核心组件"><img class="relatedPosts_cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/Snipaste_2024-05-06_00-33-28%202.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-06</div><div class="relatedPosts_title">Netty In Action -- 核心组件</div></div></a></div><div class="relatedPosts_item"><a href="/posts/599662bc/" title="Netty In Action -- BootStrap"><img class="relatedPosts_cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/Snipaste_2024-05-06_00-33-28%202.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-06</div><div class="relatedPosts_title">Netty In Action -- BootStrap</div></div></a></div><div class="relatedPosts_item"><a href="/posts/981a23ac/" title="Netty In Action -- EventLoop和线程模型"><img class="relatedPosts_cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/Snipaste_2024-05-06_00-33-28%202.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-06</div><div class="relatedPosts_title">Netty In Action -- EventLoop和线程模型</div></div></a></div><div class="relatedPosts_item"><a href="/posts/1050cde4/" title="Netty In Action -- 单元测试"><img class="relatedPosts_cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/Snipaste_2024-05-06_00-33-28%202.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-06</div><div class="relatedPosts_title">Netty In Action -- 单元测试</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By LemonGo97</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/instant.page/5.1.0/instantpage.min.js" type="module" defer></script><script src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.3.1/lazyload.iife.min.js" async></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'w7vT5VedMPyGHyDYppcacmtw-gzGzoHsz',
      appKey: 'YxBl09Aj50g5Ld621aydI4pz',
      placeholder: '来和大家一起讨论吧！',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div></div></body></html>