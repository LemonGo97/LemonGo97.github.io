<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Netty In Action -- 单元测试 | LemonGo97のBlog</title><meta name="description" content="ChannelHandler 是 Netty 应用程序的关键元素，所以彻底地测试它们应该是你的开发过程的一个标准部分。最佳实践要求你的测试不仅要能够证明你的实现是正确的，而且还要能够很容易地隔离那些因修改代码而突然出现的问题。这种类型的测试叫作单元测试。 虽然单元测试没有统一的定义，但是大多数的从业者都有基本的共识。其基本思想是，以尽可能小的区块测试你的代码，并且尽可能地和其他的代码模块以及运行时"><meta name="keywords" content="Java,Netty"><meta name="author" content="LemonGo97"><meta name="copyright" content="LemonGo97"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.lemongo97.com/posts/1050cde4/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><meta property="og:type" content="article"><meta property="og:title" content="Netty In Action -- 单元测试"><meta property="og:url" content="https://blog.lemongo97.com/posts/1050cde4/"><meta property="og:site_name" content="LemonGo97のBlog"><meta property="og:description" content="ChannelHandler 是 Netty 应用程序的关键元素，所以彻底地测试它们应该是你的开发过程的一个标准部分。最佳实践要求你的测试不仅要能够证明你的实现是正确的，而且还要能够很容易地隔离那些因修改代码而突然出现的问题。这种类型的测试叫作单元测试。 虽然单元测试没有统一的定义，但是大多数的从业者都有基本的共识。其基本思想是，以尽可能小的区块测试你的代码，并且尽可能地和其他的代码模块以及运行时"><meta property="og:image" content="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/Snipaste_2024-05-06_00-33-28%202.png"><meta property="article:published_time" content="2024-05-06T08:24:02.000Z"><meta property="article:modified_time" content="2024-05-06T08:24:02.000Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.1.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2024-05-06 16:24:02'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="LemonGo97のBlog" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="https://coding-net-production-static-ci.codehub.cn/d70d0fa9-08d5-4fc7-ba82-7b73fee22292.jpg?imageMogr2/auto-orient/format/jpeg/cut/700x700x0x0" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">65</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">39</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#EmbeddedChannel-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">EmbeddedChannel 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-EmbeddedChannel-%E6%B5%8B%E8%AF%95-ChannelHandler"><span class="toc-number">2.</span> <span class="toc-text">使用 EmbeddedChannel 测试 ChannelHandler</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%85%A5%E7%AB%99%E6%B6%88%E6%81%AF"><span class="toc-number">2.1.</span> <span class="toc-text">测试入站消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%87%BA%E7%AB%99%E6%B6%88%E6%81%AF"><span class="toc-number">2.2.</span> <span class="toc-text">测试出站消息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">测试异常处理</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/Snipaste_2024-05-06_00-33-28%202.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">LemonGo97のBlog</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Netty In Action -- 单元测试</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-06T08:24:02.000Z" title="发表于 2024-05-06 16:24:02">2024-05-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-06T08:24:02.000Z" title="更新于 2024-05-06 16:24:02">2024-05-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Netty/">Netty</a></span></div><div class="meta-secondline"> </div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p><code>ChannelHandler</code> 是 Netty 应用程序的关键元素，所以彻底地测试它们应该是你的开发过程的一个标准部分。最佳实践要求你的测试不仅要能够证明你的实现是正确的，而且还要能够很容易地隔离那些因修改代码而突然出现的问题。这种类型的测试叫作单元测试。</p>
<p>虽然单元测试没有统一的定义，但是大多数的从业者都有基本的共识。其基本思想是，以尽可能小的区块测试你的代码，并且尽可能地和其他的代码模块以及运行时的依赖（如数据库和网络）相隔离。如果你的应用程序能通过测试验证每个单元本身都能够正常地工作，那么在出了问题时将可以更加容易地找出根本原因。</p>
<p>在本章中，我们将学习一种特殊的 <code>Channel</code> 实现——<code>EmbeddedChannel</code>，它是 Netty 专门为改进针对 <code>ChannelHandler</code>的单元测试而提供的。</p>
<p>因为正在被测试的代码模块或者单元将在它正常的运行时环境之外被执行， 所以你需要一个框架或者脚手架以便在其中运行它。在我们的例子中，我们将使用 <code>JUnit 4</code>作为我们的测试框架，所以你需要对它的用法有一个基本的了解。如果它对你来说比较陌生，不要害怕；虽然它功能强大，但却很简单，你可以在 <code>JUnit</code> 的官方网站上找到你所需要的所有信息。</p>
<p>你可能会发现回顾前面关于 <code>ChannelHandler</code>的章节很有用，因为这将为我们的示例提供素材。</p>
<h2 id="EmbeddedChannel-概述"><a href="#EmbeddedChannel-概述" class="headerlink" title="EmbeddedChannel 概述"></a><code>EmbeddedChannel</code> 概述</h2><p>你已经知道，可以将 <code>ChannelPipeline</code> 中的 <code>ChannelHandler</code> 实现链接在一起，以构建你的应用程序的业务逻辑。我们已经在前面解释过，这种设计支持将任何潜在的复杂处理过程分解为小的可重用的组件，每个组件都将处理一个明确定义的任务或者步骤。在本章中，我们还将展示它是如何简化测试的。</p>
<p>Netty 提供了它所谓的 <code>Embedded</code> 传输，用于测试 <code>ChannelHandler</code>。这个传输是一种特殊的<code>Channel</code> 实现—<code>EmbeddedChannel</code>—的功能，这个实现提供了通过 <code>ChannelPipeline</code>传播事件的简便方法。</p>
<p>这个想法是直截了当的：将入站数据或者出站数据写入到 <code>EmbeddedChannel</code> 中，然后检查是否有任何东西到达了 <code>ChannelPipeline</code> 的尾端。以这种方式，你便可以确定消息是否已经被编码或者被解码过了，以及是否触发了任何的 <code>ChannelHandler</code>动作。</p>
<p>下表中列出了 <code>EmbeddedChannel</code>的相关方法</p>
<table>
<thead>
<tr>
<th>名 称</th>
<th>职 责</th>
</tr>
</thead>
<tbody><tr>
<td><code>writeInbound(Object... msgs)</code></td>
<td>将入站消息写到 <code>EmbeddedChannel</code> 中。如果可以通过 <code>readInbound()</code>方法从 <code>EmbeddedChannel</code>中读取数据，则返回 <code>true</code></td>
</tr>
<tr>
<td><code>readInbound()</code></td>
<td>从 <code>EmbeddedChannel</code> 中读取一个入站消息。任何返回的东西都穿越了整个 <code>ChannelPipeline</code>。如果没有任何可供读取的，则返回 <code>null</code></td>
</tr>
<tr>
<td><code>writeOutbound(Object... msgs)</code></td>
<td>将出站消息写到 <code>EmbeddedChannel</code>中。如果现在可以通过 <code>readOutbound()</code>方法从 <code>EmbeddedChannel</code>中读取到什么东西，则返回 <code>true</code></td>
</tr>
<tr>
<td><code>readOutbound()</code></td>
<td>从 <code>EmbeddedChannel</code> 中读取一个出站消息。任何返回的东西都穿越了整个 <code>ChannelPipeline</code>。如果没有任何可供读取的，则返回 <code>null</code></td>
</tr>
<tr>
<td><code>finish()</code></td>
<td>将 <code>EmbeddedChannel</code> 标记为完成，并且如果有可被读取的入站数据或者出站数据，则返回 <code>true</code>。这个方法还将会调用 <code>EmbeddedChannel</code> 上的<code>close()</code>方法</td>
</tr>
</tbody></table>
<p>入站数据由 <code>ChannelInboundHandler</code> 处理，代表从远程节点读取的数据。出站数据由 <code>ChannelOutboundHandler</code>处理，代表将要写到远程节点的数据。根据你要测试的 <code>ChannelHandler</code>，你将使用<code>*Inbound()</code>或者<code>*Outbound()</code>方法对，或者兼而有之。</p>
<p>下图展示了使用 <code>EmbeddedChannel</code>的方法，数据是如何流经 <code>ChannelPipeline</code>的。你可以使用 <code>writeOutbound()</code>方法将消息写到 <code>Channel</code> 中，并通过 <code>ChannelPipeline</code> 沿着出站的方向传递。随后，你可以使用 <code>readOutbound()</code>方法来读取已被处理过的消息，以确定结果是否和预期一样。 类似地，对于入站数据，你需要使用 <code>writeInbound()</code>和 <code>readInbound()</code>方法。</p>
<p>在每种情况下，消息都将会传递过 <code>ChannelPipeline</code>，并且被相关的 <code>ChannelInboundHandler</code> 或者 <code>ChannelOutboundHandler</code> 处理。如果消息没有被消费，那么你可以使用<code>readInbound()</code>或者 <code>readOutbound()</code>方法来在处理过了这些消息之后，酌情把它们从 <code>Channel</code>中读出来。</p>
<img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/image-20240506163140968.png" alt="EmbeddedChannel的数据流" style="zoom:33%;" />

<p>接下来让我们仔细看看这两种场景，以及它们是如何应用于测试你的应用程序逻辑的吧。</p>
<h2 id="使用-EmbeddedChannel-测试-ChannelHandler"><a href="#使用-EmbeddedChannel-测试-ChannelHandler" class="headerlink" title="使用 EmbeddedChannel 测试 ChannelHandler"></a>使用 <code>EmbeddedChannel</code> 测试 <code>ChannelHandler</code></h2><p>在这一节中，我们将讲解如何使用 <code>EmbeddedChannel</code>来测试 <code>ChannelHandler</code>。</p>
<blockquote>
<p><strong><code>JUnit</code> 断言</strong></p>
<p><code>org.junit.Assert</code> 类提供了很多用于测试的静态方法。失败的断言将导致一个异常被抛出，并将终止当前正在执行中的测试。导入这些断言的最高效的方式是通过一个 <code>import static</code>语句来实现：</p>
<p><code>import static org.junit.Assert.*;</code></p>
<p>一旦这样做了，就可以直接调用 <code>Assert</code>方法了：</p>
<p><code>assertEquals(buf.readSlice(3), read);</code></p>
</blockquote>
<h3 id="测试入站消息"><a href="#测试入站消息" class="headerlink" title="测试入站消息"></a>测试入站消息</h3><p>下图展示了一个简单的 <code>ByteToMessageDecoder</code>实现。给定足够的数据，这个实现将产生固定大小的帧。如果没有足够的数据可供读取，它将等待下一个数据块的到来，并将再次检查是否能够产生一个新的帧。</p>
<img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/image-20240506163433508.png" alt="通过 FixedLengthFrameDecoder解码" style="zoom:33%;" />

<p>正如可以从上图右侧的帧看到的那样，这个特定的解码器将产生固定为 3 字节大小的帧。因此，它可能会需要多个事件来提供足够的字节数以产生一个帧。</p>
<p>最终，每个帧都会被传递给 <code>ChannelPipeline</code>中的下一个 <code>ChannelHandler</code>。该解码器的实现，如下列代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展 ByteToMessageDecoder 以处理入站字节，并将它们解码为消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedLengthFrameDecoder</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageDecoder</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> frameLength;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指定要生成的帧的长度</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">FixedLengthFrameDecoder</span><span class="params">(<span class="type">int</span> frameLength)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (frameLength &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">        <span class="string">&quot;frameLength must be a positive integer: &quot;</span> + frameLength);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.frameLength = frameLength;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 检查是否有足够的字节可以被读取，以生成下一个帧</span></span><br><span class="line">    <span class="keyword">while</span> (in.readableBytes() &gt;= frameLength) &#123;</span><br><span class="line">      <span class="comment">// 从 ByteBuf 中读取一个新帧</span></span><br><span class="line">      <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> in.readBytes(frameLength);</span><br><span class="line">      <span class="comment">// 将该帧添加到已被解码的消息列表中</span></span><br><span class="line">      out.add(buf);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，让我们创建一个单元测试，以确保这段代码将按照预期执行。正如我们前面所指出的，即使是在简单的代码中，单元测试也能帮助我们防止在将来代码重构时可能会导致的问题，并且能在问题发生时帮助我们诊断它们。</p>
<p>下列代码展示了一个使用 <code>EmbeddedChannel</code>的对于前面代码的测试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedLengthFrameDecoderTest</span> &#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFramesDecoded</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.buffer();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">      buf.writeByte(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">input</span> <span class="operator">=</span> buf.duplicate();</span><br><span class="line">    <span class="type">EmbeddedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmbeddedChannel</span>(<span class="keyword">new</span> <span class="title class_">FixedLengthFrameDecoder</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="comment">// write bytes</span></span><br><span class="line">    assertTrue(channel.writeInbound(input.retain()));</span><br><span class="line">    assertTrue(channel.finish());</span><br><span class="line">    <span class="comment">// read messages</span></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">read</span> <span class="operator">=</span> (ByteBuf) channel.readInbound();</span><br><span class="line">    assertEquals(buf.readSlice(<span class="number">3</span>), read);</span><br><span class="line">    read.release();</span><br><span class="line">    read = (ByteBuf) channel.readInbound();</span><br><span class="line">    assertEquals(buf.readSlice(<span class="number">3</span>), read);</span><br><span class="line">    read.release();</span><br><span class="line">    read = (ByteBuf) channel.readInbound();</span><br><span class="line">    assertEquals(buf.readSlice(<span class="number">3</span>), read);</span><br><span class="line">    read.release();</span><br><span class="line">    assertNull(channel.readInbound());</span><br><span class="line">    buf.release();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFramesDecoded2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.buffer();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">      buf.writeByte(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">input</span> <span class="operator">=</span> buf.duplicate();</span><br><span class="line">    <span class="type">EmbeddedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmbeddedChannel</span>(<span class="keyword">new</span> <span class="title class_">FixedLengthFrameDecoder</span>(<span class="number">3</span>));</span><br><span class="line">    assertFalse(channel.writeInbound(input.readBytes(<span class="number">2</span>)));</span><br><span class="line">    assertTrue(channel.writeInbound(input.readBytes(<span class="number">7</span>)));</span><br><span class="line">    assertTrue(channel.finish());</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">read</span> <span class="operator">=</span> (ByteBuf) channel.readInbound();</span><br><span class="line">    assertEquals(buf.readSlice(<span class="number">3</span>), read);</span><br><span class="line">    read.release();</span><br><span class="line">    read = (ByteBuf) channel.readInbound();</span><br><span class="line">    assertEquals(buf.readSlice(<span class="number">3</span>), read);</span><br><span class="line">    read.release();</span><br><span class="line">    read = (ByteBuf) channel.readInbound();</span><br><span class="line">    assertEquals(buf.readSlice(<span class="number">3</span>), read);</span><br><span class="line">    read.release();</span><br><span class="line">    assertNull(channel.readInbound());</span><br><span class="line">    buf.release();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该 <code>testFramesDecoded()</code>方法验证了：一个包含 9 个可读字节的 <code>ByteBuf</code> 被解码为 3个 <code>ByteBuf</code>，每个都包含了 3 字节。需要注意的是，仅通过一次对 <code>writeInbound()</code>方法的调用，<code>ByteBuf</code> 是如何被填充了 9 个可读字节的。在此之后，通过执行 <code>finish()</code>方法，将<code>EmbeddedChannel</code>标记为了已完成状态。最后， 通过调用 <code>readInbound()</code>方法，从 <code>EmbeddedChannel</code>中正好读取了 3 个帧和一个 <code>null</code>。</p>
<p><code>testFramesDecoded2()</code>方法也是类似的，只有一处不同：入站 <code>ByteBuf</code>是通过两个步骤写入的。当 <code>writeInbound(input.readBytes(2))</code>被调用时，返回了 <code>false</code>。为什么呢？正如同文章开头表格中所描述的，如果对 <code>readInbound()</code>的后续调用将会返回数据，那么 <code>writeInbound()</code>方法将会返回 <code>true</code>。但是只有当有 3 个或者更多的字节可供读取时， <code>FixedLengthFrameDecoder</code>才会产生输出。该测试剩下的部分和 <code>testFramesDecoded()</code>是相同的。</p>
<h3 id="测试出站消息"><a href="#测试出站消息" class="headerlink" title="测试出站消息"></a>测试出站消息</h3><p>测试出站消息的处理过程和刚才所看到的类似。在下面的例子中，我们将会展示如何使用 <code>EmbeddedChannel</code> 来测试一个编码器形式的 <code>ChannelOutboundHandler</code>，编码器是一种将一种消息格式转换为另一种的组件。所以现在我们只需要简单地提及我们正在测试的处理器—<code>AbsIntegerEncoder</code>，它是 Netty 的 <code>MessageToMessageEncoder</code>的一个特殊化的实现，用于将负值整数转换为绝对值。</p>
<p>该示例将会按照下列方式工作：</p>
<ul>
<li>持有 <code>AbsIntegerEncoder</code>的 <code>EmbeddedChannel</code>将会以 4 字节的负整数的形式写出站数据；</li>
<li>编码器将从传入的 <code>ByteBuf</code> 中读取每个负整数，并将会调用 <code>Math.abs()</code>方法来获取其绝对值；</li>
<li>编码器将会把每个负整数的绝对值写到 <code>ChannelPipeline</code>中。</li>
</ul>
<p>下图展示了该逻辑：</p>
<img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/image-20240506165321707.png" alt="通过 AbsIntegerEncoder编码" style="zoom:33%;" />

<p>下面的实现了这个逻辑，如下图所示。<code>encode()</code>方法将把产生的值写到一个 <code>List</code>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展 MessageToMessageEncoder 以将一个消息编码为另外一种格式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbsIntegerEncoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageEncoder</span>&lt;ByteBuf&gt; &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 检查是否有足够的字节用来编码</span></span><br><span class="line">    <span class="keyword">while</span> (in.readableBytes() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="comment">// 从输入的 ByteBuf中读取下一个整数，并且计算其绝对值</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> Math.abs(in.readInt());</span><br><span class="line">      <span class="comment">// 将该整数写入到编码消息的 List 中</span></span><br><span class="line">      out.add(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下列代码使用了 <code>EmbeddedChannel</code>来测试代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbsIntegerEncoderTest</span> &#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testEncoded</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个 ByteBuf，并且写入 9 个负整数</span></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.buffer();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      buf.writeInt(i * -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建一个 EmbeddedChannel，并安装一个要测试的 AbsIntegerEncoder</span></span><br><span class="line">    <span class="type">EmbeddedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmbeddedChannel</span>(<span class="keyword">new</span> <span class="title class_">AbsIntegerEncoder</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 写入 ByteBuf，并断言调用 readOutbound()方法将会产生数据</span></span><br><span class="line">    assertTrue(channel.writeOutbound(buf));</span><br><span class="line">    <span class="comment">// 4. 将该 Channel标记为已完成状态</span></span><br><span class="line">    assertTrue(channel.finish());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 读取所产生的消息，并断言它们包含了对应的绝对值</span></span><br><span class="line">    <span class="comment">// read bytes</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      assertEquals(i, channel.readOutbound());</span><br><span class="line">    &#125;</span><br><span class="line">    assertNull(channel.readOutbound());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是代码中执行的步骤。</p>
<ol>
<li>将 4 字节的负整数写到一个新的 <code>ByteBuf</code>中。</li>
<li>创建一个 <code>EmbeddedChannel</code>，并为它分配一个 <code>AbsIntegerEncoder</code>。</li>
<li>调用 <code>EmbeddedChannel</code>上的 <code>writeOutbound()</code>方法来写入该 <code>ByteBuf</code>。</li>
<li>标记该 <code>Channel</code>为已完成状态。</li>
<li>从 <code>EmbeddedChannel</code>的出站端读取所有的整数，并验证是否只产生了绝对值。</li>
</ol>
<h2 id="测试异常处理"><a href="#测试异常处理" class="headerlink" title="测试异常处理"></a>测试异常处理</h2><p>应用程序通常需要执行比转换数据更加复杂的任务。例如，你可能需要处理格式不正确的输入或者过量的数据。在下一个示例中，如果所读取的字节数超出了某个特定的限制，我们将会抛出一个 <code>TooLongFrameException</code>。这是一种经常用来防范资源被耗尽的方法。</p>
<p>在下图中，最大的帧大小已经被设置为 3 字节。如果一个帧的大小超出了该限制，那么程序将会丢弃它的字节，并抛出一个 <code>TooLongFrameException</code>。位于 <code>ChannelPipeline</code> 中的其他<code>ChannelHandler</code>可以选择在 <code>exceptionCaught()</code>方法中处理该异常或者忽略它。</p>
<img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/image-20240506170035585.png" alt="image-20240506170035585" style="zoom:33%;" />

<p>其实现如下列代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展 ByteToMessageDecoder 以将入站字节解码为消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FrameChunkDecoder</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageDecoder</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxFrameSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指定将要产生的帧的最大允许大小</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">FrameChunkDecoder</span><span class="params">(<span class="type">int</span> maxFrameSize)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.maxFrameSize = maxFrameSize;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">readableBytes</span> <span class="operator">=</span> in.readableBytes();</span><br><span class="line">    <span class="keyword">if</span> (readableBytes &gt; maxFrameSize) &#123;</span><br><span class="line">      <span class="comment">// 如果该帧太大，则丢弃它并抛出一个 TooLongFrameException……</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// discard the bytes</span></span><br><span class="line">      in.clear();</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TooLongFrameException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ……否则，从 ByteBuf 中读取一个新的帧</span></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> in.readBytes(readableBytes);</span><br><span class="line">    <span class="comment">// 将该帧添加到解码消息的 List 中</span></span><br><span class="line">    out.add(buf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再使用 <code>EmbeddedChannel</code>来测试一次这段代码，如下列代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FrameChunkDecoderTest</span> &#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFramesDecoded</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 ByteBuf，并向它写入 9 字节</span></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.buffer();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">      buf.writeByte(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">input</span> <span class="operator">=</span> buf.duplicate();</span><br><span class="line">    <span class="comment">// 创建一个 EmbeddedChannel，并向其安装一个帧大小为 3 字节的 FixedLengthFrameDecoder</span></span><br><span class="line">    <span class="type">EmbeddedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmbeddedChannel</span>(<span class="keyword">new</span> <span class="title class_">FrameChunkDecoder</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="comment">// 向它写入 2 字节，并断言它们将会产生一个新帧</span></span><br><span class="line">    assertTrue(channel.writeInbound(input.readBytes(<span class="number">2</span>)));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 写入一个 4 字节大小的帧，并捕获预期的TooLongFrameException</span></span><br><span class="line">      channel.writeInbound(input.readBytes(<span class="number">4</span>));</span><br><span class="line">      <span class="comment">// 如果上面没有抛出异常，那么就会到达这个断言，并且测试失败</span></span><br><span class="line">      Assert.fail();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TooLongFrameException e) &#123;</span><br><span class="line">      <span class="comment">// expected exception</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入剩余的 2 字节，并断言将会产生一个有效帧</span></span><br><span class="line">    assertTrue(channel.writeInbound(input.readBytes(<span class="number">3</span>)));</span><br><span class="line">    <span class="comment">// 将该 Channel 标记为已完成状态</span></span><br><span class="line">    assertTrue(channel.finish());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取产生的消息，并且验证值</span></span><br><span class="line">    <span class="comment">// Read frames</span></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">read</span> <span class="operator">=</span> (ByteBuf) channel.readInbound();</span><br><span class="line">    assertEquals(buf.readSlice(<span class="number">2</span>), read);</span><br><span class="line">    read.release();</span><br><span class="line">    read = (ByteBuf) channel.readInbound();</span><br><span class="line">    assertEquals(buf.skipBytes(<span class="number">4</span>).readSlice(<span class="number">3</span>), read);</span><br><span class="line">    read.release();</span><br><span class="line">    buf.release();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中有一个有趣的转折点，即对<code>TooLongFrameException</code>的处理。这里使用的<code>try/catch</code>块是<code>EmbeddedChannel</code>的一个特殊功能。如果其中一个<code>write*</code>方法产生了一个受检查的<code>Exception</code>，那么它将会被包装在一个<code>RuntimeException</code>中并抛出。这使得可以容易地测试出一个<code>Exception</code>是否在处理数据的过程中已经被处理了。</p>
<p>这里介绍的测试方法可以用于任何能抛出 <code>Exception</code>的 <code>ChannelHandler</code>实现。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">LemonGo97</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.lemongo97.com/posts/1050cde4/">https://blog.lemongo97.com/posts/1050cde4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.lemongo97.com" target="_blank">LemonGo97のBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Netty/">Netty</a></div><div class="post_share"><div class="social-share" data-image="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/Snipaste_2024-05-06_00-33-28%202.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/63335c7/"><img class="prev-cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/Snipaste_2024-05-06_00-33-28%202.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Netty In Action -- 编解码器框架</div></div></a></div><div class="next-post pull-right"><a href="/posts/599662bc/"><img class="next-cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/Snipaste_2024-05-06_00-33-28%202.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Netty In Action -- BootStrap</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/posts/d8676d75/" title="Netty In Action -- Netty的组件和设计"><img class="relatedPosts_cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/Snipaste_2024-05-06_00-33-28%202.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-06</div><div class="relatedPosts_title">Netty In Action -- Netty的组件和设计</div></div></a></div><div class="relatedPosts_item"><a href="/posts/dc761a4c/" title="Netty In Action -- 传输"><img class="relatedPosts_cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/Snipaste_2024-05-06_00-33-28%202.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-06</div><div class="relatedPosts_title">Netty In Action -- 传输</div></div></a></div><div class="relatedPosts_item"><a href="/posts/8aef8fee/" title="Netty In Action -- 核心组件"><img class="relatedPosts_cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/Snipaste_2024-05-06_00-33-28%202.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-06</div><div class="relatedPosts_title">Netty In Action -- 核心组件</div></div></a></div><div class="relatedPosts_item"><a href="/posts/599662bc/" title="Netty In Action -- BootStrap"><img class="relatedPosts_cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/Snipaste_2024-05-06_00-33-28%202.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-06</div><div class="relatedPosts_title">Netty In Action -- BootStrap</div></div></a></div><div class="relatedPosts_item"><a href="/posts/981a23ac/" title="Netty In Action -- EventLoop和线程模型"><img class="relatedPosts_cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/Snipaste_2024-05-06_00-33-28%202.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-06</div><div class="relatedPosts_title">Netty In Action -- EventLoop和线程模型</div></div></a></div><div class="relatedPosts_item"><a href="/posts/63335c7/" title="Netty In Action -- 编解码器框架"><img class="relatedPosts_cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/Snipaste_2024-05-06_00-33-28%202.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-06</div><div class="relatedPosts_title">Netty In Action -- 编解码器框架</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By LemonGo97</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/instant.page/5.1.0/instantpage.min.js" type="module" defer></script><script src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.3.1/lazyload.iife.min.js" async></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'w7vT5VedMPyGHyDYppcacmtw-gzGzoHsz',
      appKey: 'YxBl09Aj50g5Ld621aydI4pz',
      placeholder: '来和大家一起讨论吧！',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div></div></body></html>