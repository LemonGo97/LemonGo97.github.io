<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>深入理解完美哈希 | LemonGo97のBlog</title><meta name="description" content="作者：foxxiao，腾讯 WXG 后开开发工程师  本文对完美 Hash 的概念进行了梳理，通过 Hash 构建步骤来了解它是如何解决 Hash 冲突的，并比较了 Hash 表和完美 Hash 表。下面介绍常见的 Hash 与 Perfect Hash 函数及它们在不同场景的应用。  散列函数（英语：Hash function）又称散列算法、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的"><meta name="keywords" content="Java,Linux,BigData,MySQL,MongoDB"><meta name="author" content="LemonGo97"><meta name="copyright" content="LemonGo97"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.lemongo97.com/posts/8671c4ed/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><meta property="og:type" content="article"><meta property="og:title" content="深入理解完美哈希"><meta property="og:url" content="https://blog.lemongo97.com/posts/8671c4ed/"><meta property="og:site_name" content="LemonGo97のBlog"><meta property="og:description" content="作者：foxxiao，腾讯 WXG 后开开发工程师  本文对完美 Hash 的概念进行了梳理，通过 Hash 构建步骤来了解它是如何解决 Hash 冲突的，并比较了 Hash 表和完美 Hash 表。下面介绍常见的 Hash 与 Perfect Hash 函数及它们在不同场景的应用。  散列函数（英语：Hash function）又称散列算法、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的"><meta property="og:image" content="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/default_cover_1.jpg"><meta property="article:published_time" content="2023-01-07T15:59:29.000Z"><meta property="article:modified_time" content="2023-01-07T15:59:29.000Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.1.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2023-01-07 23:59:29'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="LemonGo97のBlog" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="https://coding-net-production-static-ci.codehub.cn/d70d0fa9-08d5-4fc7-ba82-7b73fee22292.jpg?imageMogr2/auto-orient/format/jpeg/cut/700x700x0x0" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">65</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">39</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash-%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">Hash 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8-Hash-%E5%87%BD%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">安全 Hash 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashDoS-%E4%B8%8E%E5%85%A8%E5%9F%9F-Hash%EF%BC%88universal-hash%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">HashDoS 与全域 Hash（universal hash）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E7%BE%8E-Hash-%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">完美 Hash 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FCH"><span class="toc-number">4.1.</span> <span class="toc-text">FCH</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CHD"><span class="toc-number">4.2.</span> <span class="toc-text">CHD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PTHash"><span class="toc-number">4.3.</span> <span class="toc-text">PTHash</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-number">5.</span> <span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84-HashMap"><span class="toc-number">5.1.</span> <span class="toc-text">常规 HashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#F14-amp-B16-%E7%B3%BB%E5%88%97-HashMap"><span class="toc-number">5.2.</span> <span class="toc-text">F14 &amp; B16 系列 HashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PerfectHashMap"><span class="toc-number">5.3.</span> <span class="toc-text">PerfectHashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Benchmark"><span class="toc-number">5.4.</span> <span class="toc-text">Benchmark</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#string"><span class="toc-number">5.4.1.</span> <span class="toc-text">string</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#uint64"><span class="toc-number">5.4.2.</span> <span class="toc-text">uint64</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">6.</span> <span class="toc-text">结论</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/default_cover_1.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">LemonGo97のBlog</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">【转载】 深入理解完美哈希</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-07T15:59:29.000Z" title="发表于 2023-01-07 23:59:29">2023-01-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-07T15:59:29.000Z" title="更新于 2023-01-07 23:59:29">2023-01-07</time></span></div><div class="meta-secondline"> </div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>作者：foxxiao，腾讯 WXG 后开开发工程师</p>
<blockquote>
<p>本文对完美 Hash 的概念进行了梳理，通过 Hash 构建步骤来了解它是如何解决 Hash 冲突的，并比较了 Hash 表和完美 Hash 表。下面介绍常见的 Hash 与 Perfect Hash 函数及它们在不同场景的应用。</p>
</blockquote>
<p>散列函数（英语：Hash function）又称散列算法、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或 hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。</p>
<p>Hash 函数是一种将集合 S 转换成具有固定长度的、不可逆的的集合 U 的单射，它的值一般为数字合字母的组合，Hash 函数拥有无限的输入空间，却只有有限的输出空间，这意味着 Hash 函数一定会产生碰撞，一个好的 Hash 函数可以显著的降低碰撞概率。Hash 函数一般有一下特征：</p>
<ol>
<li><p>一致性。Hash 函数可以接受任意大小的数据，并输出固定长度的散列值，同时输出不同值的概率应该尽可能一致。如 CityHash128，不管原始数据有多大，计算得到的 hash 值总是 128 bit。</p>
</li>
<li><p>雪崩效应。原始数据哪怕只有一个字节的修改，得到的 hash 值都会发生巨大的变化。</p>
</li>
<li><p>单向。只能从原始数据计算得到 hash 值，不能从 hash 值计算得到原始数据。所以散列算法不是加密解密算法，加密解密是可逆的，散列算法是不可逆的。</p>
</li>
<li><p>避免冲突。几乎不可能找到一个数据和当前计算的这个数据计算出一样的 hash 值，因此散列函数能够确保数据的唯一性。在 Hash 函数保证不同值出现的概率一致的情况下，CityHash128 出现碰撞的概率只有 2 ^ -128。因为不同 Key 的碰撞概率很小，所以在某些情况下我们可以直接使用较短的 Hash 值代替较长原始数据存储。</p>
</li>
</ol>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/8f92d1eeb46c505c529406486a936d2c.jpeg" alt=""></p>
<h3 id="Hash-函数"><a href="#Hash-函数" class="headerlink" title="Hash 函数"></a>Hash 函数</h3><p>常见的 Hash 函数有：</p>
<ul>
<li><p>CRC32：CRC32 能够快速的生成 32 位 Hash 值，一般在数据库系统或数据传输中出现，用于快速校验数据是否完整；</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/veorq/SipHash/blob/master/README.md">SipHash</a>：SipHash 并不是为了速度设计的，与其他 Hash 函数相比速度上不占优势，而提供了 <a target="_blank" rel="noopener" href="https://coolshell.cn/articles/6424.html"><strong>HashDoS</strong></a> 保护，是 Rust 中的 Hash 函数的默认实现，最新 Redis 中也在使用 SipHash；</p>
</li>
<li><p>MurMurHash：经典快速的 Hash 函数，目前最新的版本是 MurMurHash3，可以生成 32 位或者 128 位 Hash 值；</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/google/cityhash">CityHash</a>：来自于 Google 实现，受到 MurmurHash 启发，但是比 MurmurHash 更快，可以输出 64 位、128 位或者 256 位 Hash 值。ClickHouse 内置；</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/Cyan4973/xxHash">xxHash</a>：针对小数据集速度非常快，支持输出 32 位、64 位、128 位 Hash 值，Github 开源，SSE 支持。ClickHouse 内置。</p>
</li>
</ul>
<p>xxHash 的 <a target="_blank" rel="noopener" href="http://cyan4973.github.io/xxHash/">benchmark</a>，统计了常用 Hash 函数的性能：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/0a4cef39f565f7ef0d6565b3219c4b5c.jpeg" alt=""></p>
<p>常见用法：</p>
<blockquote>
<p>Hash 表：通过 Hash 算法将 Key 均匀映射到不同的位置上，访问单个 key 时可以达到 O(1) 的平均时间复杂度，加快访问速度。</p>
</blockquote>
<h3 id="安全-Hash-函数"><a href="#安全-Hash-函数" class="headerlink" title="安全 Hash 函数"></a>安全 Hash 函数</h3><p>安全 Hash 函数（或者叫加密 Hash 函数）是一种优秀的 Hash 函数，无法（或者很难）通过 Hash 值猜测出 Key，更精确的说，安全 Hash 必须满足抗碰撞和不可逆两个条件：无法通过 Hash 值的统计学方法逆向，以及无法通过算法层逆向。常见的安全 Hash 算法包括：</p>
<ul>
<li><p>SHA2，SHA3 系列</p>
</li>
<li><p>BLAKE 系列</p>
</li>
</ul>
<p>SHA0、SHA1、MD5 算法已经被认为是不安全的，存在已知的漏洞，不要使用这些不安全的 Hash 函数来签名。</p>
<p>常见用法：</p>
<blockquote>
<p>安全 Hash 函数广泛应用于数字签名技术中：对原文进行 Hash 后，将 Hash 结果通过私钥签名，避免原文被泄露或者被修改；工作量证明：如加密货币中挖矿就是通过给定值，计算符合条件的 Hash 输入；文件 ID：在网站下载地址旁往往提供了文件的 MD5 或者 SHA-1，确保下载的文件完整且没有被调包。</p>
</blockquote>
<h3 id="HashDoS-与全域-Hash（universal-hash）"><a href="#HashDoS-与全域-Hash（universal-hash）" class="headerlink" title="HashDoS 与全域 Hash（universal hash）"></a>HashDoS 与全域 Hash（universal hash）</h3><p>全域 Hash 解决的是确定性 Hash 算法无法应对特殊输入的问题。在链式 HashMap 里，假设 <code>m = bucket size</code>，考虑我们有输入集合 S 和 Hash 函数 H，其中 <code>H = H’ % m</code>，攻击者在知道 Hash 函数的情况下，容易构造集合 S 使得集合中每一个元素的 Hash 值相同，那 HashMap 会退化成链表。最坏情况下，HashMap 查找的时间复杂度变成了 <code>O(n)</code>，插入 n 个元素时需要 <code>O(n2)</code> 的时间复杂度，所以也叫 <strong>HashDoS 攻击</strong>。</p>
<p>全域 Hash 解决的问题是：对于精心构造的输入，冲突率仍然在 <code>1 / m</code>。一个简单的想法是随机选一个 Hash 函数，不是在每一次操作时选一个，而是在输入前选一个 Hash 函数，之后所有的操作都基于该 Hash 函数。</p>
<p>当然 H 也不是随便定义的，具体来说是在 |H| 个 Hash 函数 H 中随机的选择一个 Hash 函数作为所有 key 的 Hash 函数，H 中所有的 Hash 函数 H’ 对于不相等的关键词 x 和 y，使得 H’(x) 和 H’(y) 值相等的函数 H’ 的数量个数等于 <code>|H| / m</code>，<a target="_blank" rel="noopener" href="https://www.cnblogs.com/soyscut/p/3396216.html">此时冲突概率为 1/m。</a></p>
<h3 id="完美-Hash-函数"><a href="#完美-Hash-函数" class="headerlink" title="完美 Hash 函数"></a>完美 Hash 函数</h3><p>传统的 Hashmap 总会有分支预测开销与内存对比，最差时间复杂度是 O(n)，有那么一种 Hash 函数：完美 Hash 函数（ Perfect Hash Function，<strong>PHF</strong>），它可以在最坏情况下取得 O(1) 的时间复杂度。当然鱼和熊掌不可兼得，完美 Hash 要求有一个静态的输入集合，查找的 Key 必须存在于静态输入集合中，导致使用场景受限。它有几个特点：</p>
<ol>
<li><p>完美 Hash 大部分都<strong>要求输入 Key 的集合是已知的</strong>，用于提前构建数据结构；</p>
</li>
<li><p>构造算法复杂，大部分情况下需要比较大的内存，特别是时间复杂度高，需要<strong>很长的时间建立索引</strong>，构建海量 key 的完美 Hash 可能会<strong>失败</strong>；</p>
</li>
<li><p>完美 Hash 在实现上并不是只有一个 Hash 函数，而是多个普通 Hash 函数与数据结构算法上的组合，这意味着需要<strong>额外空间</strong>存储 Hash 冲突信息。</p>
</li>
</ol>
<p>尽管它有一些缺点，但是在一些场景如汉字拼音映射，词典，以及程序中预定义的映射关系都有它的应用。</p>
<p>Perfect Hash Function 对于给定的集合 S，可以将 S 中所有的 Key 映射到整数 <code>[0, m)</code> 中，其中 <code>m &gt;= |S|</code>。当 <code>m = |S|</code> 时，称为最小完美 Hash 函数（Minimal Perfect Hash Function, <strong>MPHF</strong>）。即作为一个特例，如果完美 Hash 可以将 N 个 key 映射到 0 到 N-1 的整数，那它可以被称为最小完美 Hash 函数。</p>
<blockquote>
<p>更进一步，如果 Hash 后给出 key 的顺序没有发生变化，称为完美 Hash 函数是保序的。如果一个 Hash 函数在给定区域不超过 t 次冲突，那这个 Hash 函数称为 t-完美 Hash 函数。</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/685c891fbbf16bb6896662bd306fca51.jpeg" alt=""></p>
<p>目前开源的 Perfect Hash 库有：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="http://cmph.sourceforge.net/">cmph</a>：C/C++，集合了大部分知名完美 Hash 算法的库，针对不同的数据集合有推荐不同的算法，参数可调，文档不多，LGPL 协议</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.gnu.org/software/gperf/manual/gperf.html">gperf</a>：C/C++，专门针对于小数据集完美 Hash 的生成库，GPL 协议；</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/rust-phf/rust-phf">rust-phf</a>：使用 CHD 算法生成完美 Hash，使用简单，10 w 个 key 只需 0.4s 就能生成。</p>
</li>
</ul>
<p>下文会讨论 FCH，CHD，PTHASH 是如何巧妙解决了 Hash 冲突并实现了最差 O(1) 时间复杂度的。</p>
<blockquote>
<p>完美 Hash 首先需要<strong>离线构造</strong>得到 Hash 冲突的信息离线保存下来，需要查询时，利用先前生成的信息计算得到唯一的整数 Hash value。</p>
</blockquote>
<p>在描述算法之前，先假设：</p>
<p>对于已知大小 <code>n = |S|</code> 的输入集合 S，已知的负载因子 <code>alpha</code> 和参数 <code>c</code>，table 的数量 <code>table_size = n * alpha</code>，桶的数量 <code>m = cn / (log2 n + 1)</code>。一般来说，c 在 2-8 左右，确保每个桶有合适数量的 key，同时不会空出太多的桶。最终所有的 key 会映射到 <code>[0, table_size)</code> 中的 整数。当 <code>alpha = 1</code>，<code>table_size = n</code>，为 <strong>MPHF</strong>。</p>
<h4 id="FCH"><a href="#FCH" class="headerlink" title="FCH"></a>FCH</h4><p><a target="_blank" rel="noopener" href="http://cmph.sourceforge.net/papers/fch92.pdf">A Faster Algorithm for Constructing Minimal Perfect Hash Functions</a> 由 Fox, Chen, Heath 发明的一种生成完美 Hash 的算法，FCH 是一个相当经典的 Perfect Hash 的实现，后续多种算法均受到 FCH 算法的启发。</p>
<p>FCH 是一种基于<strong>二级 Hash 表</strong>的完美 Hash 函数：</p>
<p>将数据通过一级 Hash 映射到 T 空间中，然后冲突的数据随机选取新的哈希函数映射到 S 空间中，且 S 空间的大小 m 是冲突数据的平方（例如 T2 中有三个数字产生冲突，则映射到 m 为 9 的 S2 空间中，m 即为避免桶内 Hash 冲突的参数），此时可以容易找到避免碰撞的哈希函数（这个避免冲突的过程称为 <strong>position</strong> 或者 <strong>displace</strong>）。最差情况下所需存储空间为 <code>O(n2)</code>，但只要适当选择哈希函数减少一级哈希时的碰撞，则可以使预期存储空间为 <code>O(n)</code>。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/40b433ac793224ebcb72cc9f75431695.jpeg" alt=""></p>
<p>构造 FCH 需要分为三个步骤：</p>
<ol>
<li>Mapping</li>
</ol>
<p>Mapping 阶段为了将 60% 的 key 分布到 30 % 的桶里，将 n 个 key 分为 S1 和 S2 两个集合，其中 S1 称为 dense set，key 的数量大概保持在 <code>0.6 * n</code>，S2 为 sparse set，key 的数量大概在 <code>0.4 * n</code> 左右。同时，把所有桶分为两个部分 B1 和 B2，B1 数量 p2 = <code>0.3 * m</code>，称为 dense buckets，B2 数量 <code>0.7 * m</code>，称为 sparse bucket。使用普通的 Hash 函数如 Cityhash/MurmurHash，将 S1 通过 H1 映射到 B1 中，同样道理将 S2 通过 H2 映射到 B2 中。</p>
<p>用数学语言描述：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/48b0db22296bdb522a46d59e33605423.jpeg" alt=""></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/f6c9076a02e3b9d0b9ca4fcf8b81b077.jpeg" alt=""></p>
<ol start="2">
<li>Ordering</li>
</ol>
<p>Ordering 阶段将所有的桶按照桶内冲突的数量排序，冲突数量最多的桶放在最前面。</p>
<ol start="3">
<li>Searching</li>
</ol>
<p>Searching 阶段会<strong>依次</strong>处理每个桶里的冲突，尝试将不重复的 Hash 值分配给每一个 key。经过了上一个阶段排序，该阶段会优先处理冲突最多的桶。对于每一个桶，尝试参数 di, bi，给桶内每一个 key 分配 Hash 值 <code>position(x, di, bi) = (h(x, s2 + b1) + di) mod table_size</code>，这个值在 <code>[0, table_size)</code> 之间，其中 s2 是全局随机种子，bi 是单个 bit，di 是一个从 0 开始的递增的整数，如果 Hash 值在桶内和之前计算过的 Hash 值冲突，则改变 bi 或者 di 直到 Hash 值不发生冲突（为了加速 di 的寻找，原始论文中提出了辅助数据结构和压缩方法，感兴趣可以参考论文）。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/f755e6f96be26054dff546d11481d88a.jpeg" alt=""></p>
<p>处理完冲突后，最终可以得到 m 个参数 bi，di 存入 P 数组中，只占用大概 <code>m * ((log2 n) + 1) = cn</code> bit （这只是理论上的结果，如何存储 bi 和 di 不在我们讨论范围内），即每一个 key 只占用了 c 个 bit。</p>
<p>查询时：对于给定的 key，计算一级 Hash，得到桶编号，通过该桶的 bi，di 和全局 s2 参数来计算二级哈希，即完成了一次查找，可以发现，任何 key 的查询步骤都时相同的，没有循环，即所有步骤都是确定的 O(1)。注意到这里无法判断 key 是否存在。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/b7576e677946fc0571e7eccf5221b405.jpeg" alt=""></p>
<p>在 FCH 中，c 越大，构造越快，但是空间利用率越低，特别是 FCH 寻找 MPHF 需要耗费巨量的时间：c = 3 时，1 亿 uint64 的数据需要花费 1 小时以上生成，所以它并不是一个实用的算法。</p>
<h4 id="CHD"><a href="#CHD" class="headerlink" title="CHD"></a>CHD</h4><p>为了解决 FCH 构建过慢的问题，出现了基于 FCH 思想的 <a target="_blank" rel="noopener" href="http://cmph.sourceforge.net/papers/esa09.pdf">CHD</a>，一种实现简单的 Perfect Hash 算法，支持 MPHF，空间利用率更高，但 lookup 更慢。</p>
<p>主要不同地方：使用通用 Hash 函数计算出为每一个 key 计算出三个 Hash 值：h, h0, h1，h 用来表示桶号，h0、h1 用来计算最终的 position，position 定义为 <code>position = (h0 + (h1 * d1) + d0) mod table_size</code>。</p>
<p>与 FCH 相同，CHD 一共分为三个阶段：</p>
<ol>
<li>Mapping</li>
</ol>
<p>Mapping 阶段不需要像 FCH 拆分两个集合，而是直接映射到一个集合中。</p>
<p>使用 c++ 来描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buckets.resize(m);  </span><br><span class="line">for (auto key : keys) &#123;  </span><br><span class="line">  auto [h, h0, h1] = hash(key);  </span><br><span class="line">  buckets[h].hash = h;  </span><br><span class="line">  buckets[h].keys.push_back(make_tuple(h0, h1));  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Ordering</li>
</ol>
<p>与 FCH 相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sort(buckets.begin(), buckets.end(), [](auto &amp;lhs, auto &amp;rhs)&#123;  </span><br><span class="line">  return lhs.keys.size() &gt; rhs.keys.size();  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Searching （也叫 displace）</li>
</ol>
<p>Searching 阶段同样是处理每个桶里的冲突，不同的是 position 函数发生了变化：为每一个桶初始化一个 pilot，其中 <code>pilot = d0 * table_size + d1</code>，使用 position 公式计算 key 的 Hash 值，发生冲突时，pilot 加上一（相当与 d1 加上 1，此时 position 的结果会发生较大的变化）重新计算 position 直到桶里所有 key 都不发生冲突。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">bool_vector position_used, position_used_in_bucket;  </span><br><span class="line">vector&lt;uint32&gt; p; // 结果数组  </span><br><span class="line">  </span><br><span class="line">position_used.resize(table_size);  </span><br><span class="line">position_used_in_bucket.resize(buckets[0].keys.size());  </span><br><span class="line">p.resize(m);  </span><br><span class="line">  </span><br><span class="line">for (auto &amp;bucket : buckets) &#123;  </span><br><span class="line">  if (bucket.keys.size() == 0) continue;  </span><br><span class="line">  // 单个桶 pilot = d0 * table_size + d1  </span><br><span class="line">  int d0 = 0;  </span><br><span class="line">  int d1 = 0;  </span><br><span class="line">  while(true) &#123;  </span><br><span class="line">    bool ok = true;  </span><br><span class="line">    position_used_in_bucket.clear();  </span><br><span class="line">  </span><br><span class="line">    for (auto [h0, h1] : bucket.keys) &#123;  </span><br><span class="line">      uint64 position = (h0 + (h1 * d1) + d0) % table_size;  </span><br><span class="line">      if (position_used[position]) &#123;  </span><br><span class="line">        // hash 结果冲突，换一个 pilot  </span><br><span class="line">        ok = false;  </span><br><span class="line">        break;  </span><br><span class="line">      &#125;  </span><br><span class="line">      if (position_used_in_bucket[position]) &#123;  </span><br><span class="line">        // 桶内 hash 结果冲突，换一个 pilot  </span><br><span class="line">        ok = false;  </span><br><span class="line">        break;  </span><br><span class="line">      &#125;  </span><br><span class="line">      position_used_in_bucket[position] = true;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    if (ok) &#123;  </span><br><span class="line">      // 单个桶处理完毕  </span><br><span class="line">      position_used.union(position_used_in_bucket);  </span><br><span class="line">      // pilot 存到 p 数组中  </span><br><span class="line">      p[bucket.h] = d0 * table_size + d1;  </span><br><span class="line">      break;  </span><br><span class="line">    &#125;  </span><br><span class="line">    d1++;  </span><br><span class="line">    if (d1 &gt;= table_size) &#123;  </span><br><span class="line">      d1 = 0;  </span><br><span class="line">      d0++;  </span><br><span class="line">      if (d0 &gt; table_size) &#123;  </span><br><span class="line">        // 构建失败，找不到一个可用的 pilot  </span><br><span class="line">        throw ...  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最终得到的 m 个 pilot 存入 P 数组中。</p>
<p>查询时：对于给定的 key，使用固定出的 Hash 函数计算出 h, h0, h1，根据 P[h] 得到 pilot 与 d0, d1，使用 poisition 易求得 Hash 值，即完成了一次查找（至少 4 次除法 or 求余操作，h &lt; m）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auto [h, h0, h1] = hash(key);  </span><br><span class="line">auto pilot = p[h];  </span><br><span class="line">auto d0 = pilot / table_size;  </span><br><span class="line">auto d1 = pilot % table_size;  </span><br><span class="line">return (h0 + (h1 * d1) + d0) % table_size;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果集 P 中，pilot 往往很小，有压缩空间，在作者的论文中，为了压缩 P 数组的大小，采用 <a target="_blank" rel="noopener" href="https://www.researchgate.net/publication/221131602_Simple_Compression_Code_Supporting_Random_Access_and_Fast_String_Matching">FN Encoding</a>，可以压缩到 2.08 bit/key 的开销，自己的实现可以直接用 bit vector（aka compact） 压缩，实现起来更简单。</p>
<blockquote>
<p>compact 压缩：给定一系列整数 S，已知 S 中最大的整数 x 需要使用 y 个 bit 表示，我们可以将所有的整数都通过固定 y bit 来表示而不牺牲精度和访问时间。</p>
</blockquote>
<p>CHD 算法比较简单，Github 上也有不同语言的实现， <a target="_blank" rel="noopener" href="https://github.com/kadds/phash/blob/32cc994c41361e431f85d104808fc6f30722b0ff/src/chd.rs#L110">rust 语言的实现</a>。<a target="_blank" rel="noopener" href="https://github.com/robskie/chd">Go 语言实现</a>。</p>
<h4 id="PTHash"><a href="#PTHash" class="headerlink" title="PTHash"></a>PTHash</h4><p>虽然 CHD 实现简单，但其中包含了大量除法求余计算，Encoding 后效率并不高，lookup 耗时过久。最近有一篇文章提出了 <a target="_blank" rel="noopener" href="https://dl.acm.org/doi/pdf/10.1145/3404835.3462849">PTHash</a> 方法，在 FCH 上改进了构建时间，并提高了空间利用率，作者还提供了<a target="_blank" rel="noopener" href="https://github.com/jermp/pthash">源代码</a>供参考。</p>
<p>设计思路和 FCH 相似，只不过 position 定义变成了 <code>position(x, pilot) = (h(x, s) xor h(pilot, s)) mod table_size</code>，其中 h 是普通 Hash 函数，x 是 key，s 是全局种子。与 FCH 相比可以提前计算所有 key 的 Hash <code>h(x, s)</code>，节约构造时间 。使用 compact 压缩方式效果很好，lookup 耗时也能达到 FCH 水平。</p>
<ol>
<li>Mapping</li>
</ol>
<p>与 FCH 相同</p>
<ol start="2">
<li>Ordering</li>
</ol>
<p>与 FCH 相同</p>
<ol start="3">
<li>Searching</li>
</ol>
<p>使用新的公式计算 position，得到 n 个 pilot，由 position 公式定义，可以发现大部分 pilot 都是比较小的值，作者还介绍了一种 Front-Back Encoding，将结果集前 30% 拆分成 front 集，后 (1- 30%) 拆分为 back 集，代价是运行时多一次分支判断。</p>
<p>由于 front 集合里的桶是最先处理冲突的，冲突发生次数低，大部分 pilot 都比 back 集合内的要小，<strong>压缩率更高</strong>。将 Front 和 Back 集合里的 pilot 通过 Compact 编码后，称为 Compact-Compact Encoding。</p>
<p>查询时，按照 bucket id 确定去 front 还是 back 集合查询 pilot，不考虑解压过程，只需要两次除法 or 求余操作。</p>
<blockquote>
<p>当然这里也可以牺牲部分空间，不做 Front-Back Encoding 以取得更快的查询速度，根据不同的 Encoding 方式，可以在时间&amp;空间上取得平衡：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/da048920296a18189d52e3863f4cc29b.jpeg" alt=""></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/roberto-trani/mphf_benchmark">benchmark</a>：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/46a320a2921e340c2aae30ae57c30517.jpeg" alt=""></p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap 本质上是根据给定的 key 获得 value 的地址。设计核心主要在于：</p>
<ol>
<li><p>HashMap 的空间开销：key 和 value 如何组织？单个 key 需要多少额外空间存储元信息？</p>
</li>
<li><p>HashMap 的查询与插入：如何通过 key 计算出 value 的地址？冲突如何处理？</p>
</li>
<li><p>不同的 HashMap 不同点在于冲突如何处理，除了常规可读可写的 HashMap，存在只读 HashMap，存储更小，性能更优。</p>
</li>
</ol>
<h4 id="常规-HashMap"><a href="#常规-HashMap" class="headerlink" title="常规 HashMap"></a>常规 HashMap</h4><p>在各个语言都有内置的 HashMap 实现，除了使用不同的 Hash 函数，不同实现对 Hash 冲突的解决方案也不同：</p>
<ul>
<li><p>拉链法：每一个桶都存着链表的 head 节点，冲突 key 将会被插入链表；</p>
</li>
<li><p>升级红黑树：Java8 在链表长度超过 8 时转换成红黑树；</p>
</li>
<li><p>线性探测法：发现冲突时向后找到第一个没有占用的桶存储，缓存命中率高，负载因子越高，插入效率越低；</p>
</li>
<li><p>多级 Hash 法：单次 Hash 结果冲突时，换一个 Hash 函数直到 Hash 值无冲突。</p>
</li>
</ul>
<h4 id="F14-amp-B16-系列-HashMap"><a href="#F14-amp-B16-系列-HashMap" class="headerlink" title="F14 &amp; B16 系列 HashMap"></a>F14 &amp; B16 系列 HashMap</h4><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg5MjU0NTI5OQ==&mid=2247485012&idx=1&sn=8948d52f405ff7f9064e54780d7b061e&scene=21#wechat_redirect">F14 &amp; B16</a> 是一种利用 SIMD 技术进行查找的链式 HashMap，它为每一个 Key 计算两个 Hash 值：H1 和 H2，H1 决定 Key 放在哪一个桶里，H2 用来处理桶内冲突，一般要求负载因子比较高，以获得较高的空间利用率。同时对桶内的 H2 通过 SIMD 指令对比，一次对比 14 个 key 或者 16 个 key，相比 PerfectHashMap，它可以支持动态插入，但是查找性能不如 PerfectHashMap。</p>
<h4 id="PerfectHashMap"><a href="#PerfectHashMap" class="headerlink" title="PerfectHashMap"></a>PerfectHashMap</h4><p>有没有办法把 Prefect Hash 利用起来做 HashMap？由于 Perfect Hash 已经映射到 [0, table_size) 内的整数，完全不需要考虑 key 的冲突处理，所以想用起来比较简单：</p>
<ul>
<li><p>当 hashmap 的 value 定长时，我们可以直接通过 Hash 值（Index）计算出 value 的 offset，无需使用任何额外空间。</p>
</li>
<li><p>当 hashmap 的 value 不定长时，引入一层 relocation，存储每一个 Hash 值对应 value 的 offset，由于 Hash 值是从 0 递增的，因此 offset 也是递增的，可以通过一定方法去压缩 value offset。</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/defb92c958f74e7167f33002a60a65a0.jpeg" alt=""></p>
<p>完美 Hash 要求查询的 key 需要存在于输入集内，其他 HashMap 没有这么苛刻的要求，如果使用一个不在输入集中的 key 会怎么样呢？从 CHD 算法的 lookup 过程来分析，输入未知 key 时可以认为返回一个<strong>随机的 Index</strong>，如果我们需要确认 key 是否存在 HashMap 里，需要将原始 key 存下来放在 Index 对应的 Value 中，查询到 Index 后再对比一次才能确认 key 是否存在。</p>
<blockquote>
<p>PerfectHashMap 一般用法是先离线生成 map 信息，再读到 buffer 里，或者像 rust-phf 一样编译时内置到二进制，直接读 P 数组，如果 HashMap 特别大，还可以通过 mmap 只读方式载入到内存中。</p>
</blockquote>
<h4 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h4><p>测试设备：MacBookPro m1 Pro 32G，MacOS 12.4，clang 13.1.6。</p>
<p>比较对象：</p>
<ul>
<li><p>unordered_map：标准库自带的 HashMap，链式实现；</p>
</li>
<li><p>Folly F14：Facebook HashMap 实现，使用 SIMD 优化查询过程；</p>
</li>
<li><p>abseil swiss table：Google HashMap 实现，为速度优化，包括使用额外指针的 node_hash_map，与原地存储适合小 value 的 flat_hash_map；</p>
</li>
<li><p>PTHashMap：PTHash + Value offset 映射，（内部使用 CityHash128），c = 7, alpha = 0.98，Compact-Compact Encoding，Value offset 使用 MILC 压缩。不存储 key；</p>
</li>
<li><p>PTHashMap3：与 PTHashMap 参数不同：c = 3, alpha=0.99；</p>
</li>
<li><p>PTHashMap10：与 PTHashMap 参数不同：c = 10, alpha=0.94。</p>
</li>
</ul>
<h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><p>测试场景：输入 100w 随机不重复不定长字符串（平均长度 8 bytes）作为 key，value 与 key 相同。全部随机 lookup 一遍。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/ebdfe8252d427845b516aa23421e35e7.jpeg" alt=""></p>
<blockquote>
<p>meta data 排除了 key 和 Value 之后统计占用内存大小，folly 使用 computeStats() 统计内存数据；total memory 值插入所有 key 后使用 gpertools 统计占用内存大小，包含 key 和 value 部分；注意 PTHashMap meta data 统计单位是 bit。</p>
</blockquote>
<h5 id="uint64"><a href="#uint64" class="headerlink" title="uint64"></a>uint64</h5><p>测试场景：输入 100w 随机不重复 uint64 数字作为 key，value 与 key 相同，全部随机 lookup 一遍。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/c999731e1beb6fa549e946a64ae0e14d.jpeg" alt=""></p>
<blockquote>
<p>由于该场景数据是长度固定，PTHashMap 去掉了 Value offset 映射表。</p>
</blockquote>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>完美 Hash 的概念扩展了 Hash 的使用场景，最近出现的新型完美 Hash 算法在运行速度&amp;构建速度上取得了较大的进步，针对海量只读场景使用完美 HashMap 不仅可以提升速度，同时能够节省大量内存占用。</p>
<p><strong>参考文章</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20820286">1.什么是哈希算法？</a></p>
<p><a target="_blank" rel="noopener" href="https://thiscute.world/posts/practical-cryptography-basics-2-hash">2.安全 Hash</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/MurmurHash">3. MurmurHash wiki</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gaochundong/p/hashtable_and_perfect_hashing.html">4.哈希表和完美哈希</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/50108837">5. 全域哈希是什么意思</a></p>
<p><a target="_blank" rel="noopener" href="https://www.mesalab.cn/download?id=1396&url=f%2Farticle%2Fdetail%3Fid%3D460">6. 完美 Hash 技术调研</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI1NDc5MzIxMw==&mid=2247484930&idx=1&sn=d6b04e2536b703b7863d1a4c6aac8785&scene=21#wechat_redirect">7. 倒排索引压缩技术在 58 搜索的实践</a></p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/M8Wcj8sZ7UF1CMr887Puog">https://mp.weixin.qq.com/s/M8Wcj8sZ7UF1CMr887Puog</a>，如有侵权，请联系删除。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">foxxiao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/M8Wcj8sZ7UF1CMr887Puog">https://mp.weixin.qq.com/s/M8Wcj8sZ7UF1CMr887Puog</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.lemongo97.com" target="_blank">LemonGo97のBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/default_cover_1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/a21e7a7c/"><img class="prev-cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/all_default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">一文搞懂 Redis 架构演化之路</div></div></a></div><div class="next-post pull-right"><a href="/posts/ffad71e9/"><img class="next-cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/default_cover_1.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">深入理解 Linux 的 TCP 三次握手</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By LemonGo97</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/instant.page/5.1.0/instantpage.min.js" type="module" defer></script><script src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.3.1/lazyload.iife.min.js" async></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'w7vT5VedMPyGHyDYppcacmtw-gzGzoHsz',
      appKey: 'YxBl09Aj50g5Ld621aydI4pz',
      placeholder: '来和大家一起讨论吧！',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div></div></body></html>