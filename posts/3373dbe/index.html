<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Go语言入门分享 | LemonGo97のBlog</title><meta name="description" content="前言曾经我是一名以Java语言为主的开发者，做过JavaWeb相关的开发，后来转Android，还是离不开Java，直到转去做大前端了，其实也就是一直在用JS写业务。如今由于个人发展原因，来到阿里云，由于项目需要就撸起了Go语言；多年编程经验告诉我，语言只是工具罢了，重要的还是其思想与逻辑，所以只需学学语法就好了，于是我便三天入门Go，期间主要用Java和JS来类比，语法变化之大，差点让我从入门到"><meta name="keywords" content="Golang"><meta name="author" content="LemonGo97"><meta name="copyright" content="LemonGo97"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.lemongo97.com/posts/3373dbe/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><meta property="og:type" content="article"><meta property="og:title" content="Go语言入门分享"><meta property="og:url" content="https://blog.lemongo97.com/posts/3373dbe/"><meta property="og:site_name" content="LemonGo97のBlog"><meta property="og:description" content="前言曾经我是一名以Java语言为主的开发者，做过JavaWeb相关的开发，后来转Android，还是离不开Java，直到转去做大前端了，其实也就是一直在用JS写业务。如今由于个人发展原因，来到阿里云，由于项目需要就撸起了Go语言；多年编程经验告诉我，语言只是工具罢了，重要的还是其思想与逻辑，所以只需学学语法就好了，于是我便三天入门Go，期间主要用Java和JS来类比，语法变化之大，差点让我从入门到"><meta property="og:image" content="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/build-your-applications-with-golang.jpeg"><meta property="article:published_time" content="2024-04-24T03:30:24.000Z"><meta property="article:modified_time" content="2024-04-24T03:30:24.000Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.1.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2024-04-24 11:30:24'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="LemonGo97のBlog" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="https://coding-net-production-static-ci.codehub.cn/d70d0fa9-08d5-4fc7-ba82-7b73fee22292.jpg?imageMogr2/auto-orient/format/jpeg/cut/700x700x0x0" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">54</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">36</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83"><span class="toc-number">3.</span> <span class="toc-text">环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E6%96%87%E6%9C%AC%E5%BC%80%E5%8F%91"><span class="toc-number">3.1.</span> <span class="toc-text">纯文本开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GoLand"><span class="toc-number">3.2.</span> <span class="toc-text">GoLand</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VSCODE"><span class="toc-number">3.3.</span> <span class="toc-text">VSCODE</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">工程结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Go-Modules"><span class="toc-number">4.1.</span> <span class="toc-text">Go Modules</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%EF%BC%9APackage-%E5%92%8C-Import"><span class="toc-number">5.1.</span> <span class="toc-text">包：Package 和 Import</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">5.2.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E8%B5%8B%E5%80%BC"><span class="toc-number">5.2.1.</span> <span class="toc-text">多重赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%8F%98%E9%87%8F"><span class="toc-number">5.2.2.</span> <span class="toc-text">匿名变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="toc-number">5.2.3.</span> <span class="toc-text">指针变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.4.</span> <span class="toc-text">变量类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%BC%BA%E8%BD%AC"><span class="toc-number">5.2.5.</span> <span class="toc-text">类型强转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87"><span class="toc-number">5.2.6.</span> <span class="toc-text">数组与切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E5%85%B8"><span class="toc-number">5.2.7.</span> <span class="toc-text">字典</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#make%E5%92%8Cnew"><span class="toc-number">5.2.7.1.</span> <span class="toc-text">make和new</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A5%9E%E5%A5%87%E7%9A%84nil"><span class="toc-number">5.2.8.</span> <span class="toc-text">神奇的nil</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E5%AF%B9%E8%B1%A1%EF%BC%9AObject"><span class="toc-number">5.2.9.</span> <span class="toc-text">根对象：Object</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.3.</span> <span class="toc-text">语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">5.3.1.</span> <span class="toc-text">控制流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%B5%81%E7%A8%8B"><span class="toc-number">5.3.2.</span> <span class="toc-text">循环流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E6%B5%81%E7%A8%8B"><span class="toc-number">5.3.3.</span> <span class="toc-text">跳转流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">5.4.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85"><span class="toc-number">5.4.1.</span> <span class="toc-text">匿名函数和闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%AE%9A%E5%8F%82%E6%95%B0"><span class="toc-number">5.4.2.</span> <span class="toc-text">不定参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">6.1.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">6.3.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.4.</span> <span class="toc-text">接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">并发编程</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/build-your-applications-with-golang.jpeg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">LemonGo97のBlog</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">【转载】 Go语言入门分享</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-24T03:30:24.000Z" title="发表于 2024-04-24 11:30:24">2024-04-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-24T03:30:24.000Z" title="更新于 2024-04-24 11:30:24">2024-04-24</time></span></div><div class="meta-secondline"> </div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>曾经我是一名以<code>Java</code>语言为主的开发者，做过<code>JavaWeb</code>相关的开发，后来转<code>Android</code>，还是离不开<code>Java</code>，直到转去做大前端了，其实也就是一直在用<code>JS</code>写业务。如今由于个人发展原因，来到阿里云，由于项目需要就撸起了<code>Go</code>语言；多年编程经验告诉我，语言只是工具罢了，重要的还是其思想与逻辑，所以只需学学语法就好了，于是我便三天入门<code>Go</code>，期间主要用<code>Java</code>和<code>JS</code>来类比，语法变化之大，差点让我从入门到放弃了！其实，还真不是学习语法就好了呢，其中包含了很多<code>Go</code>的设计理念。正所谓好记性不如敲烂键盘，学过的东西，还是要沉淀沉淀，也可以分享出来一起探讨，更有助于成长，于是我就简单记录了一下我的<code>Go</code>语言入门学习笔记。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Go</code>语言出自Ken Thompson、Rob Pike和Robert Griesemer之手，起源于2007年，并在2009年正式对外发布，其实都是Google的，设计<code>Go</code>语言的初衷都是为了满足Google的需求。<code>Go</code>的主要目标是“兼具<code>Python</code>等动态语言的开发速度和<code>C/C++</code>等编译型语言的性能与安全性”，旨在不损失应用程序性能的情况下降低代码的复杂性，具有“部署简单、并发性好、语言设计良好、执行性能好”等优势。最主要还是为了并发而生，并发是基于<code>goroutine</code>的，<code>goroutine</code>类似于线程，但并非线程，可以将<code>goroutine</code>理解为一种虚拟线程。<code>Go</code>语言运行时会参与调度<code>goroutine</code>，并将<code>goroutine</code>合理地分配到每个<code>CPU</code>中，最大限度地使用<code>CPU</code>性能。</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>我们玩<code>Java</code>的时候需要下载<code>JDK</code>，类似于此，用<code>Go</code>开发也需要下载<code>Go</code>，里面提供各种<code>develop-kit</code>、<code>library</code>以及编译器。在官网下载mac版本pkg后直接安装，最后用 <code>go version</code> 命令验证版本：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/347c00cc1deb3ff6ff3ec7eea494d0db.png" alt=""></p>
<p>然后就是设置这两个环境变量，mac系统是在 <code>.bash_profile</code> 文件里面：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=$HOME/go</span><br></pre></td></tr></table></figure>

<ul>
<li><code>GOROOT</code>：表示的是Go语言编译、工具、标准库等的安装路径，其实就相当于配置<code>JAVA_HOME</code>那样。  </li>
<li><code>GOPATH</code>：这个和Java有点不一样，Java里并不需要设置这个变量，这个表示Go的工作目录，是全局的，当执行Go命令的时候会依赖这个目录，相当于一个全局的workspace。一般还会把<code>$GOPATH/bin</code>设置到PATH目录，这样编译过的代码就可以直接执行了。</li>
</ul>
<h3 id="纯文本开发"><a href="#纯文本开发" class="headerlink" title="纯文本开发"></a>纯文本开发</h3><p>编写代码，可以保存在任意地方，例如新建一个<code>helloworld</code>目录，创建<code>hello.go</code>文件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    </span><br><span class="line">    fmt.Println(<span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后执行 <code>go build hello.go</code> 就可以编译出hello文件，在<code>./hello</code>就可以执行了；或者直接 <code>go run hello.go</code> 合二为一去执行。执行这个命令并不需要设置环境变量就可以了。看起来和c差不多，但是和Java不一样，运行的时候不需要虚拟机。早期的GO工程也是使用<code>Makefile</code>来编译，后来有了强大的命令 <code>go build</code>、<code>go run</code>，可以直接识别目录还是文件。  </p>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/3dfb7ce569814de2202dc027ff519a3d.png" alt=""></p>
<h3 id="GoLand"><a href="#GoLand" class="headerlink" title="GoLand"></a>GoLand</h3><p>自动<code>import</code>，超爽的体验！不用按<code>command + /</code>了！</p>
<p>运行项目需要设置<code>build config</code>，和Android、Java的都差不多，例如创建一个hello-goland项目：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/5d2fd8a6e8f596521283271bbf96e48a.png" alt=""></p>
<p>导入<code>go module</code>项目的时候需要勾选这项，否则无法像<code>maven/gradle</code>那样<code>sync</code>下载依赖：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/c92c1b1013fb9835ba0eb7347e4fa5d4.png" alt=""></p>
<h3 id="VSCODE"><a href="#VSCODE" class="headerlink" title="VSCODE"></a>VSCODE</h3><p>直接搜索Go插件，第一个最多安装量的就是了，我还没用过所以不太清楚如何。</p>
<h2 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h2><p>在设置<code>GOPATH</code>环境变量的时候，这个目录里面又分了三个子目录<code>bin</code>、<code>pkg</code>、<code>src</code>，分别用于存放可执行文件、包文件和源码文件。当我们执行Go命令的时候，如果我们指定的不是当前目录的文件或者绝对路径的目录的话，就会去<code>GOPATH</code>目录的去找。这样在<code>GOPATH</code>目录创建了xxx的目录后，就可以在任意地方执行 <code>go build xx</code> 命令来构建或者运行了。</p>
<p>pkg目录应该是在执行 <code>go install</code> 后生成的包文件，包括.a这样的文件，相当于一个归档。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">├── bin</span><br><span class="line">│   ├── air</span><br><span class="line">│   ├── govendor</span><br><span class="line">│   ├── swag</span><br><span class="line">│   └── wire</span><br><span class="line">├── pkg</span><br><span class="line">│   ├── darwin_amd64</span><br><span class="line">│   ├── mod</span><br><span class="line">│   └── sumdb</span><br><span class="line">└── src</span><br><span class="line">    ├── calc</span><br><span class="line">    ├── gin-blog</span><br><span class="line">    ├── github.com</span><br><span class="line">    ├── golang.org</span><br><span class="line">    ├── google.golang.org</span><br><span class="line">    ├── gopkg.in</span><br><span class="line">    └── simplemath</span><br></pre></td></tr></table></figure>

<p>这样对于我们具体项目来说并不好，没有Workspace的概念来隔离每个项目了，所以我觉得这个GOPATH目录放的应该是公用的项目，例如开源依赖的。我们在开发过程中，也会下载很多的依赖，这些依赖都下载到这个目录，和我们的项目文件混在一起了。</p>
<p>另外，通过IDE可以设置project的<code>GOPATH</code>，相当于在执行的时候给<code>GOPATH</code>增加了一个目录变量，也就是说，我们创建一个项目，然后里面也有bin、src、pkg这三个目录，和<code>GOPATH</code>一样的，本质上，IDE在运行的时候其实就是设置了一下<code>GOPATH</code>：</p>
<blockquote>
<p><code>GOPATH=/Users/fuxing/develop/testgo/calc-outside:/Users/fuxing/develop/go</code><br>#gosetup</p>
</blockquote>
<p>Go语言在寻找变量、函数、类属性及方法的时候，会先查看<code>GOPATH</code>这个系统环境变量，然后根据该变量配置的路径列表依次去对应路径下的src目录下根据包名查找对应的目录，如果对应目录存在，则再到该目录下查找对应的变量、函数、类属性和方法。</p>
<p>其实官方提供了Go Modules的方法更好解决。</p>
<h3 id="Go-Modules"><a href="#Go-Modules" class="headerlink" title="Go Modules"></a>Go Modules</h3><p>从Go 1.11版本开始，官方提供了Go Modules管理项目和依赖，从1.13版本开始，更是默认开启了对Go Modules的支持，使用Go Modules的好处是显而易见的 —— 不需要再依赖<code>GOPATH</code>，你可以在任何位置创建Go项目，并且在国内，可以通过 <code>GOPROXY</code> 配置镜像源加速依赖包的下载。也就是说，创建一个项目就是一个mod，基本上目前Go开源项目都是这样做的。其实就是类似于Maven和Gradle。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 创建mod项目，也是可以用IDE来new一个mod项目的：</span><br><span class="line">go mod init calc-mod</span><br><span class="line"></span><br><span class="line">// 一般开源在github上面的项目名字是这样的；和maven、gradle不一样的是，开发完成根本不需要发布到仓库！只要提交代码后打tag就可以了</span><br><span class="line">go mod init github.com/fuxing-repo/fuxing-module-name</span><br><span class="line"></span><br><span class="line">// 创建一个模块：执行这个命令主要是多了一个go.mod文件，里面就一行内容：</span><br><span class="line">module calc-mod</span><br><span class="line"></span><br><span class="line">// import以后，执行下载依赖命令，不需要编辑go.mod文件。依赖会下载到GOPATH/pkg/mod目录</span><br><span class="line">go list</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用GoLand来打开不同的项目，显示依赖的外部库是不一样的，如果是用<code>GOPATH</code>创建的项目，需要用命令下载依赖包到<code>GOPATH</code>：</p>
<blockquote>
<p><code>go get -u github.com/fuxing-repo/fuxing-module-name</code></p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/2877c6e4dd613b47eb5bbeafe3d3ec82.png" alt=""></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/38179343f3396f56e154458d82ef5aa8.png" alt=""></p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="包：Package-和-Import"><a href="#包：Package-和-Import" class="headerlink" title="包：Package 和 Import"></a>包：<code>Package</code> 和 <code>Import</code></h3><p>Java里面的包名一般是很长的，和文件夹名称对应，作用就是命名空间，引入的时候需要写长长的一串，也可以用通配符：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/d209c5b3c377a6a1037e6ec5da770cc3.png" alt=""></p>
<p>Go里面一般的包名是当前的文件夹名称，同一个项目里面，可以存在同样的包名，如果同时都需要引用同样包名的时候，就可以用<code>alias</code>区分，类似于JS那样。一般<code>import</code>的是一个包，不像Java那样<code>import</code>具体的类。同一个包内，不同文件，但是里面的东西是可以使用的，不需要<code>import</code>。这有点类似于C的<code>include</code>吧。如果多行的话，用括号换行包起来。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/480637b1635de73c09f9900a8ec704c5.png" alt=""></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/df6657e72c456b38fcf3c7dbb80c7864.png" alt=""></p>
<p>Go语言中，无论是变量、函数还是类属性及方法，它们的可见性都是与包相关联的，而不是类似Java那样，类属性和方法的可见性封装在对应的类中，然后通过 private、protected 和 public 这些关键字来描述其可见性，Go语言没有这些关键字，和变量和函数一样，对应Go语言的自定义类来说，属性和方法的可见性根据其首字母大小写来决定，如果属性名或方法名首字母大写，则可以在其他包中直接访问这些属性和方法，否则只能在包内访问，所以Go语言中的可见性都是包一级的，而不是类一级的。</p>
<p>在Java里面，只有静态，或者对象就可以使用点运算符，而且是极其常用的操作，而在Go里面，还可以用一个包名来点，这就是结合了import来使用，可以点出一个函数调用，也可以点出一个结构体，一个接口。另外区别于C，不管是指针地址，还是对象引用，都是用点运算符，不需要考虑用点还是箭头了！</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/053086723511adc0e23384621e67e28d.png" alt=""></p>
<p>入口的<code>package</code>必须是<code>main</code>，否则可以编译成功，但是跑不起来：</p>
<blockquote>
<p>Compiled binary cannot be executed.</p>
</blockquote>
<p>原因就是找不到入口函数，跟C和Java一样吧，也需要main函数。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li>用 <code>var</code> 关键字修饰（类似于JS），有多个变量的时候用括号 () 包起来，默认是有初始化值的，和Java一样。</li>
<li>如果初始化的时候就赋值了那可以不需要 <code>var</code> 来修饰，和Java不同的是变量类型在变量后面而不是前面，不过需要 <code>:=</code> 符号。</li>
<li>最大的变化就是类型在变量后面！</li>
<li>语句可以省略分号 <code>;</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 <span class="type">int</span> = <span class="number">10</span>   <span class="comment">// 方式一，常规的初始化操作</span></span><br><span class="line"><span class="keyword">var</span> v2 = <span class="number">10</span>       <span class="comment">// 方式二，此时变量类型会被编译器自动推导出来</span></span><br><span class="line">v3 := <span class="number">10</span>          <span class="comment">// 方式三，可以省略 var，编译器可以自动推导出v3的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//java</span></span><br><span class="line">private HashMap&lt;String, UGCUserDetail&gt; mBlockInfo;</span><br></pre></td></tr></table></figure>
<h4 id="多重赋值"><a href="#多重赋值" class="headerlink" title="多重赋值"></a>多重赋值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i, j = j, i</span><br></pre></td></tr></table></figure>

<p>可以实现变量交换，有点像JS的对象析构，但是其实不一样。有了这个能力，函数是可以返回多个值了！</p>
<h4 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h4><p>用 <code>_</code> 来表示，作用就是可以避免创建定义一些无意义的变量，还有就是不会分配内存。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/df50f0166984503a2d6fe6127e4198f2.png" alt=""></p>
<h4 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h4><p>和C语言一样的，回想一下交换值的例子即可，到底传值和传址作为参数的区别是啥。</p>
<p>Go语言之所以引入指针类型，主要基于两点考虑，一个是为程序员提供操作变量对应内存数据结构的能力；另一个是为了提高程序的性能（指针可以直接指向某个变量值的内存地址，可以极大节省内存空间，操作效率也更高），这在系统编程、操作系统或者网络应用中是不容忽视的因素。</p>
<p>指针在Go语言中有两个使用场景：类型指针和数组切片。</p>
<p>作为类型指针时，允许对这个指针类型的数据进行修改指向其它内存地址，传递数据时如果使用指针则无须拷贝数据从而节省内存空间，此外和C语言中的指针不同，Go语言中的类型指针不能进行偏移和运算，因此更为安全。</p>
<h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><p>Go语言内置对以下这些基本数据类型的支持：</p>
<ul>
<li>布尔类型：<code>bool</code></li>
<li>整型：<code>int8</code>、<code>byte</code>、<code>int16</code>、<code>int</code>、<code>uint</code>、<code>uintptr</code> 等</li>
<li>浮点类型：<code>float32</code>、<code>float64</code></li>
<li>复数类型：<code>complex64</code>、<code>complex128</code></li>
<li>字符串：<code>string</code></li>
<li>字符类型：<code>rune</code>，本质上是<code>uint32</code></li>
<li>错误类型：<code>error</code></li>
</ul>
<p>此外，Go语言也支持以下这些复合类型：</p>
<ul>
<li>指针（<code>pointer</code>）</li>
<li>数组（<code>array</code>）</li>
<li>切片（<code>slice</code>）</li>
<li>字典（<code>map</code>）</li>
<li>通道（<code>chan</code>）</li>
<li>结构体（<code>struct</code>）</li>
<li>接口（<code>interface</code>）</li>
</ul>
<p>还有<code>const</code>常量，<code>iota</code>这个预定义常量用来定义枚举。可以被认为是一个可被编译器修改的常量，在每一个<code>const</code>关键字出现时被重置为0，然后在下一个<code>const</code>出现之前，每出现一次<code>iota</code>，其所代表的数字会自动增1。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Sunday = <span class="literal">iota</span> </span><br><span class="line">    Monday </span><br><span class="line">    Tuesday </span><br><span class="line">    Wednesday </span><br><span class="line">    Thursday </span><br><span class="line">    Friday </span><br><span class="line">    Saturday </span><br><span class="line">    numberOfDays</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="类型强转"><a href="#类型强转" class="headerlink" title="类型强转"></a>类型强转</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">v1 := <span class="number">99.99</span></span><br><span class="line">v2 := <span class="type">int</span>(v1)  <span class="comment">// v2 = 99</span></span><br><span class="line"></span><br><span class="line">v1 := []<span class="type">byte</span>&#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;</span><br><span class="line">v2 := <span class="type">string</span>(v1)  <span class="comment">// v2 = hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符相关的转化一般用strconv包</span></span><br><span class="line">v1 := <span class="string">&quot;100&quot;</span></span><br><span class="line">v2, err := strconv.Atoi(v1)  <span class="comment">// 将字符串转化为整型，v2 = 100</span></span><br><span class="line"></span><br><span class="line">v3 := <span class="number">100</span></span><br><span class="line">v4 := strconv.Itoa(v3)   <span class="comment">// 将整型转化为字符串, v4 = &quot;100&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体类型转换</span></span><br><span class="line"><span class="comment">//类型断言 </span></span><br><span class="line"><span class="comment">//x.(T) 其实就是判断 T 是否实现了 x 接口，如果实现了，就把 x 接口类型具体化为 T 类型；</span></span><br><span class="line">claims, ok := tokenClaims.Claims.(*jwt.StandardClaims)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="数组与切片"><a href="#数组与切片" class="headerlink" title="数组与切片"></a>数组与切片</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义数组</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">8</span>]<span class="type">byte</span> <span class="comment">// 长度为8的数组，每个元素为一个字节</span></span><br><span class="line"><span class="keyword">var</span> b [<span class="number">3</span>][<span class="number">3</span>]<span class="type">int</span> <span class="comment">// 二维数组（9宫格）</span></span><br><span class="line"><span class="keyword">var</span> c [<span class="number">3</span>][<span class="number">3</span>][<span class="number">3</span>]<span class="type">float64</span> <span class="comment">// 三维数组（立体的9宫格）</span></span><br><span class="line"><span class="keyword">var</span> d = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  <span class="comment">// 声明时初始化</span></span><br><span class="line"><span class="keyword">var</span> e = <span class="built_in">new</span>([<span class="number">3</span>]<span class="type">string</span>)   <span class="comment">// 通过 new 初始化</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">3</span>) <span class="comment">// 通过 make初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">b := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//切片</span></span><br><span class="line">b := []<span class="type">int</span>&#123;&#125; <span class="comment">//数组切片slice就是一个可变长数组</span></span><br><span class="line">c := a[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">// 有点类似于subString，或者js.slice</span></span><br><span class="line">d := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>) <span class="comment">//make相当于，new、alloc，用来分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组的长度</span></span><br><span class="line">length := <span class="built_in">len</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个元素</span></span><br><span class="line">b = <span class="built_in">append</span>(b, <span class="number">4</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>其实就是Java里的map，使用上语法有很多不同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testMap <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">testMap = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">  <span class="string">&quot;one&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">&quot;two&quot;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">&quot;three&quot;</span>: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还可以这样初始化：</span></span><br><span class="line"><span class="keyword">var</span> testMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>) <span class="comment">//map[string]int&#123;&#125;</span></span><br><span class="line">testMap[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span></span><br><span class="line">testMap[<span class="string">&quot;two&quot;</span>] = <span class="number">2</span></span><br><span class="line">testMap[<span class="string">&quot;three&quot;</span>] = <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h5 id="make和new"><a href="#make和new" class="headerlink" title="make和new"></a>make和new</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The make built-in function allocates and initializes an object of type</span></span><br><span class="line"><span class="comment">// slice, map, or chan (only). Like new, the first argument is a type, not a</span></span><br><span class="line"><span class="comment">// value. Unlike new, make&#x27;s return type is the same as the type of its</span></span><br><span class="line"><span class="comment">// argument, not a pointer to it. The specification of the result depends on</span></span><br><span class="line"><span class="comment">// the type:</span></span><br><span class="line"><span class="comment">//  Slice: The size specifies the length. The capacity of the slice is</span></span><br><span class="line"><span class="comment">//  equal to its length. A second integer argument may be provided to</span></span><br><span class="line"><span class="comment">//  specify a different capacity; it must be no smaller than the</span></span><br><span class="line"><span class="comment">//  length. For example, make([]int, 0, 10) allocates an underlying array</span></span><br><span class="line"><span class="comment">//  of size 10 and returns a slice of length 0 and capacity 10 that is</span></span><br><span class="line"><span class="comment">//  backed by this underlying array.</span></span><br><span class="line"><span class="comment">//  Map: An empty map is allocated with enough space to hold the</span></span><br><span class="line"><span class="comment">//  specified number of elements. The size may be omitted, in which case</span></span><br><span class="line"><span class="comment">//  a small starting size is allocated.</span></span><br><span class="line"><span class="comment">//  Channel: The channel&#x27;s buffer is initialized with the specified</span></span><br><span class="line"><span class="comment">//  buffer capacity. If zero, or the size is omitted, the channel is</span></span><br><span class="line"><span class="comment">//  unbuffered.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span></span> Type</span><br><span class="line"></span><br><span class="line"><span class="comment">// The new built-in function allocates memory. The first argument is a type,</span></span><br><span class="line"><span class="comment">// not a value, and the value returned is a pointer to a newly</span></span><br><span class="line"><span class="comment">// allocated zero value of that type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span></span> *Type</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>区别就是返回值和参数不同，一个是值，一个是指针，slice、chan、map只能用make，本身就是指针。其他make、new都行。</p>
<h4 id="神奇的nil"><a href="#神奇的nil" class="headerlink" title="神奇的nil"></a>神奇的nil</h4><p>Java里面用null比较舒服，直接就判空了，除了在string类型的时候，还要判断字符为 “”，但是Go里面的string要判断为空就简单一点，不能判断nil，只能判断 “”。然而Go里面的nil却和null不一样，其实是和JS里面 <code>==</code>、<code>===</code> 很像。</p>
<p>nil也是有类型的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err *os.PathError = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// …</span></span><br><span class="line">    <span class="keyword">return</span> err  <span class="comment">//实际返回的是[nil, *os.PathError]</span></span><br><span class="line">    <span class="comment">//return nil //正确的方式是直接return nil  实际返回的是[nil, nil]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := Foo()</span><br><span class="line">    fmt.Println(err)        <span class="comment">// &lt;nil&gt;</span></span><br><span class="line">    fmt.Println(err == <span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line">    fmt.Println(err == (*os.PathError)(<span class="literal">nil</span>)) <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="根对象：Object"><a href="#根对象：Object" class="headerlink" title="根对象：Object"></a>根对象：Object</h4><p>在Java里面，如果不用多态，没有接口，父类，超类的话，就用Object作为根对象，在Go里面，如果函数参数不知道用什么类型，通常会用 interface{}，这是个空接口，表示任意类型，因为不是弱类型语言，没有any类型，也不是强面向对象语言，没有Object，所以就有这个空接口的出现。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/8b647feb66695feaed045ba94b165f80.png" alt=""></p>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>比较大的一个特点就是能不用括号的地方都不用了。</p>
<h4 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h4><p>if语句的判断条件都没有了括号包起来，还可以前置写变量初始化语句，类似于for循环，左花括号 { 必须与 if 或者 else 处于同一行。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/21197e83fda0ccbc59b60762caf2e580.png" alt=""></p>
<p>switch语句变得更强大了，有这些变化：</p>
<ul>
<li>switch关键字后面可以不跟变量，这样case后面就必须跟条件表达式，其实本质上就是美化了if-else-if。</li>
<li>如果switch后面跟变量，case也变得强大了，可以出现多个结果选项，通过逗号分隔。</li>
<li>swtich后面还可以跟一个函数。</li>
<li>不需要用break来明确退出一个case，如果要穿透执行一层，可以用 fallthrough 关键字。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">score := <span class="number">100</span></span><br><span class="line"><span class="keyword">switch</span> score &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">90</span>, <span class="number">100</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Grade: A&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">80</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Grade: B&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">70</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Grade: C&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">60</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">65</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Grade: D&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Grade: F&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s == <span class="string">&quot;hello&quot;</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> s == <span class="string">&quot;xxxx&quot;</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;xxxx&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> s != <span class="string">&quot;world&quot;</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output：hello xxxx</span></span><br></pre></td></tr></table></figure>



<h4 id="循环流程"><a href="#循环流程" class="headerlink" title="循环流程"></a>循环流程</h4><p>去掉了 while、repeat 这些关键字了，只保留了 for 这个关键字，其实用起来差不多。break , continue 这些关键字还是有的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用的用法</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类似于while的用法</span></span><br><span class="line">a := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> a &lt;= <span class="number">5</span> &#123;</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    a ++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//死循环</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">   <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ;; &#123;</span><br><span class="line">       <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类似java for-each的用法</span></span><br><span class="line">listArray := [...]<span class="type">string</span>&#123;<span class="string">&quot;xiaobi&quot;</span>, <span class="string">&quot;xiaoda&quot;</span>, <span class="string">&quot;xiaoji&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> index, item := <span class="keyword">range</span> listArray &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;hello, %d, %s\n&quot;</span>, index, item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="keyword">for</span> (String item : someList) &#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="跳转流程"><a href="#跳转流程" class="headerlink" title="跳转流程"></a>跳转流程</h4><p>Go很神奇的保留了一直被放弃的goto语句，记得是Basic、Pascal那些语言才会有，不知道为啥。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">1</span></span><br><span class="line">flag:</span><br><span class="line"><span class="keyword">for</span> i &lt;= <span class="number">10</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        <span class="keyword">goto</span> flag</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>defer流程有点像Java里面的finally，保证了一定能执行，我感觉底层也是goto的实现吧。在后面跟一个函数的调用，就能实现将这个xxx函数的调用延迟到当前函数执行完后再执行。</p>
<p>这是压栈的变量快照实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printName</span><span class="params">(name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  fmt.Println(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  name := <span class="string">&quot;go&quot;</span></span><br><span class="line">  <span class="keyword">defer</span> printName(name) <span class="comment">// output: go</span></span><br><span class="line"></span><br><span class="line">  name = <span class="string">&quot;python&quot;</span></span><br><span class="line">  <span class="keyword">defer</span> printName(name) <span class="comment">// output: python</span></span><br><span class="line"></span><br><span class="line">  name = <span class="string">&quot;java&quot;</span></span><br><span class="line">  printName(name) <span class="comment">// output: java</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line">java</span><br><span class="line">python</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//defer后于return执行</span></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&quot;go&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        name = <span class="string">&quot;python&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;myfunc 函数里的name：%s\n&quot;</span>, name)</span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myname := myfunc()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;main 函数里的name: %s\n&quot;</span>, name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;main 函数里的myname: &quot;</span>, myname)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line">myfunc 函数里的name：<span class="keyword">go</span></span><br><span class="line">main 函数里的name: python</span><br><span class="line">main 函数里的myname:  <span class="keyword">go</span></span><br></pre></td></tr></table></figure>



<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>关键字是 func，Java则完全没有 function 关键字，而是用 public、void 等等这样的关键字，JS也可以用箭头函数来去掉 function 关键字了。</li>
<li>函数的花括号强制要求在首行的末尾。</li>
<li>可以返回多个值！返回值的类型定义在参数后面了，而不是一开始定义函数就需要写上，跟定义变量一样，参数的类型定义也是一样在后面的，如果相同则保留最右边的类型，其他省略。</li>
<li>可以显式声明了返回值就可以了，必须每个返回值都显式，就可以省略 return 变量。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetEventHandleMsg</span><span class="params">(code <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  msg, ok := EventHandleMsgMaps[code]</span><br><span class="line">  <span class="keyword">if</span> ok &#123;</span><br><span class="line">    <span class="keyword">return</span> msg</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//多个返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetEventHandleMsg</span><span class="params">(code <span class="type">int</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  msg, ok := EventHandleMsgMaps[code]</span><br><span class="line">  <span class="keyword">if</span> ok &#123;</span><br><span class="line">    <span class="keyword">return</span> msg, <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不显式return变量值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetEventHandleMsg</span><span class="params">(code <span class="type">int</span>)</span></span> (msg <span class="type">string</span>, e <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ok <span class="type">bool</span></span><br><span class="line">  msg, ok = EventHandleMsgMaps[code]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ok &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="匿名函数和闭包"><a href="#匿名函数和闭包" class="headerlink" title="匿名函数和闭包"></a>匿名函数和闭包</h4><p>在Java里面的实现一般是内部类、匿名对象，不能通过方法传递函数作为参数，只能传一个对象，实现接口。</p>
<p>Go则和JS一样方便，可以传递函数，定义匿名函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传递匿名函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">10</span></span><br><span class="line">    add := <span class="function"><span class="keyword">func</span> <span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Variable i from main func: %d\n&quot;</span>, i)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;The sum of %d and %d is: %d\n&quot;</span>, a, b, a+b)</span><br><span class="line">    &#125;</span><br><span class="line">    callback(<span class="number">1</span>, add);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callback</span><span class="params">(x <span class="type">int</span>, f <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span>) &#123;</span><br><span class="line">    f(x, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//return 匿名函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := addfunc(<span class="number">1</span>)</span><br><span class="line">    fmt.Println(f(<span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addfunc</span><span class="params">(a <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="不定参数"><a href="#不定参数" class="headerlink" title="不定参数"></a>不定参数</h4><p>和Java类似，不同的是在调用是也需要用 … 来标识。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SkipHandler</span><span class="params">(c *gin.Context, skippers ...SkipperFunc)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> _, skipper := <span class="keyword">range</span> skippers &#123;</span><br><span class="line">    <span class="keyword">if</span> skipper(c) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">middlewares.SkipHandler(c, skippers...)</span><br></pre></td></tr></table></figure>



<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>在C语言里面经常会有用到别名的用法，可以用 type 类起一个别名，很常用，特别是在看源码的时候经常出现：</p>
<blockquote>
<p><code>type Integer int</code></p>
</blockquote>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>没有 class 的定义，Go里面的类是用结构体来定义的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="type">uint</span></span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    male <span class="type">bool</span></span><br><span class="line">    score <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有构造函数，但是可以用函数来创建实例对象，并且可以指定字段初始化，类似于Java里面的静态工厂方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span><span class="params">(id <span class="type">uint</span>, name <span class="type">string</span>, male <span class="type">bool</span>, score <span class="type">float64</span>)</span></span> *Student &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Student&#123;id, name, male, score&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStudent2</span><span class="params">(id <span class="type">uint</span>, name <span class="type">string</span>, male <span class="type">bool</span>, score <span class="type">float64</span>)</span></span> Student &#123;</span><br><span class="line">  <span class="keyword">return</span> Student&#123;id, name, male, score&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>定义类的成员函数方法比较隐式，方向是反的，不是声明这个类有哪些成员方法，而是声明这个函数是属于哪个类的。声明语法就是在 func 关键字之后，函数名之前，注意不要把Java的返回值定义给混淆了！</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种声明方式和C++一样的，这个就是不是普通函数了，而是成员函数。</span></span><br><span class="line"><span class="comment">//注意到的是，两个方法一个声明的是地址，一个声明的是结构体，两个都能直接通过点操作。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span></span> GetName() <span class="type">string</span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> s.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span></span> SetName(name <span class="type">string</span>) &#123;</span><br><span class="line">    s.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//a是指针类型</span></span><br><span class="line">  a := NewStudent(<span class="number">1</span>, <span class="string">&quot;aa&quot;</span>, <span class="literal">false</span>, <span class="number">45</span>)</span><br><span class="line">  a.SetName(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;a name:%s\n&quot;</span>, a.GetName())</span><br><span class="line"></span><br><span class="line">  b := NewStudent2(<span class="number">2</span>, <span class="string">&quot;bb&quot;</span>, <span class="literal">false</span>, <span class="number">55</span>)</span><br><span class="line">  b.SetName(<span class="string">&quot;bbb&quot;</span>)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;b name:%s\n&quot;</span>, b.GetName())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果SetName方法和GetName方法归属于Student，而不是*Student的话，那么修改名字就会不成功</span></span><br><span class="line"><span class="comment">//本质上，声明成员函数，就是在非函数参数的地方来传递对象、指针、或者说是引用，也就是变相传递this指针</span></span><br><span class="line"><span class="comment">//所以才会出现修改名字不成功的case</span></span><br></pre></td></tr></table></figure>



<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>没有 extend 关键字，也就没有了继承，只能通过组合的方式来实现。组合就解决了多继承问题，而且多继承的顺序不同，内存结构也不同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Animal)</span></span> FavorFood() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;FavorFood...&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Animal)</span></span> Call() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Voice...&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    Animal</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span></span> Call() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;汪汪汪&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方式，在初始化就需要指定地址，其他都没变化</span></span><br><span class="line"><span class="keyword">type</span> Dog2 <span class="keyword">struct</span> &#123; </span><br><span class="line">    *Animal</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">  d1 := Dog&#123;&#125;</span><br><span class="line">  d1.name = <span class="string">&quot;mydog&quot;</span></span><br><span class="line"></span><br><span class="line">  d2 := Dog2&#123;&#125;</span><br><span class="line">  d2.name = <span class="string">&quot;mydog2&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//结构体是值类型，如果传入值变量的话，实际上传入的是结构体值的副本，对内存耗费更大，</span></span><br><span class="line">    <span class="comment">//所以传入指针性能更好</span></span><br><span class="line">  a := Animal&#123;<span class="string">&quot;ddog&quot;</span>&#125;</span><br><span class="line">  d3 := Dog&#123;a&#125;</span><br><span class="line">  d4 := Dog2&#123;&amp;a&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这种语法并不是像Java里面的组合，使用成员变量，而是直接引用Animal并没有定义变量名称（当然也是可以的，不过没必要了），然后就可以访问Animal中的所有属性和方法（如果两个类不在同一个包中，只能访问父类中首字母大写的公共属性和方法），还可以实现方法重写。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>Java的接口是侵入式的，指的是实现类必须明确声明自己实现了某个接口。带来的问题就是，如果接口改了，实现类都必须改，所以以前总是会有一个抽象类在中间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义接口：</span></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;</span><br><span class="line">   call()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现接口：</span></span><br><span class="line"><span class="keyword">type</span> IPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(phone IPhone)</span></span> call() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Iphone calling.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Go的接口是非侵入式的，因为类与接口的实现关系不是通过显式声明，而是系统根据两者的方法集合进行判断。一个类必须实现接口所有的方法才算是实现了这个接口。接口之间的继承和类的继承一样，通过组合实现，多态的实现逻辑是一样的，如果接口A的方法列表是接口B的方法列表的子集，那么接口B可以赋值给接口A。</p>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p>目前并发编程方面还没学习多少，就简单从网上摘了这一个经典的生产者消费者模型例子来初步感受一下，后续深入学习过后再进行分享。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/49bcc75d13728e3546174c18c3fcf197.png" alt=""></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据生产者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(header <span class="type">string</span>, channel <span class="keyword">chan</span>&lt;- <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">     <span class="comment">// 无限循环, 不停地生产数据</span></span><br><span class="line">     <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// 将随机数和字符串格式化为字符串发送给通道</span></span><br><span class="line">            channel &lt;- fmt.Sprintf(<span class="string">&quot;%s: %v&quot;</span>, header, rand.Int31())</span><br><span class="line">            <span class="comment">// 等待1秒</span></span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数据消费者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">customer</span><span class="params">(channel &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">     <span class="comment">// 不停地获取数据</span></span><br><span class="line">     <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// 从通道中取出数据, 此处会阻塞直到信道中返回数据</span></span><br><span class="line">            message := &lt;-channel</span><br><span class="line">            <span class="comment">// 打印数据</span></span><br><span class="line">            fmt.Println(message)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个字符串类型的通道</span></span><br><span class="line">    channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    <span class="comment">// 创建producer()函数的并发goroutine</span></span><br><span class="line">    <span class="keyword">go</span> producer(<span class="string">&quot;cat&quot;</span>, channel)</span><br><span class="line">    <span class="keyword">go</span> producer(<span class="string">&quot;dog&quot;</span>, channel)</span><br><span class="line">    <span class="comment">// 数据消费函数</span></span><br><span class="line">    customer(channel)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line">dog: <span class="number">1298498081</span></span><br><span class="line">cat: <span class="number">2019727887</span></span><br><span class="line">cat: <span class="number">1427131847</span></span><br><span class="line">dog: <span class="number">939984059</span></span><br><span class="line">dog: <span class="number">1474941318</span></span><br><span class="line">cat: <span class="number">911902081</span></span><br><span class="line">cat: <span class="number">140954425</span></span><br><span class="line">dog: <span class="number">336122540</span></span><br></pre></td></tr></table></figure>


<p>本文转自 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ojCbksSAOEhuSJOT1udiEQ">https://mp.weixin.qq.com/s/ojCbksSAOEhuSJOT1udiEQ</a>，如有侵权，请联系删除。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">赋行</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ojCbksSAOEhuSJOT1udiEQ">https://mp.weixin.qq.com/s/ojCbksSAOEhuSJOT1udiEQ</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.lemongo97.com" target="_blank">LemonGo97のBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Golang/">Golang</a></div><div class="post_share"><div class="social-share" data-image="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/build-your-applications-with-golang.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/2fe1e71a/"><img class="prev-cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/build-your-applications-with-golang.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Golang与Java全方位对比总结</div></div></a></div><div class="next-post pull-right"><a href="/posts/33bcc5a1/"><img class="next-cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/default_cover_1.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">更优雅的使用Gson解析Json</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/posts/4895093/" title="Golang异步编程方式和技巧"><img class="relatedPosts_cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/build-your-applications-with-golang.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-24</div><div class="relatedPosts_title">Golang异步编程方式和技巧</div></div></a></div><div class="relatedPosts_item"><a href="/posts/6b50a5f8/" title="Golang 整洁架构实践"><img class="relatedPosts_cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/build-your-applications-with-golang.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-24</div><div class="relatedPosts_title">Golang 整洁架构实践</div></div></a></div><div class="relatedPosts_item"><a href="/posts/da348609/" title="如何真正写好Golang代码?"><img class="relatedPosts_cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/build-your-applications-with-golang.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-24</div><div class="relatedPosts_title">如何真正写好Golang代码?</div></div></a></div><div class="relatedPosts_item"><a href="/posts/2fe1e71a/" title="Golang与Java全方位对比总结"><img class="relatedPosts_cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/build-your-applications-with-golang.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-24</div><div class="relatedPosts_title">Golang与Java全方位对比总结</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By LemonGo97</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/instant.page/5.1.0/instantpage.min.js" type="module" defer></script><script src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.3.1/lazyload.iife.min.js" async></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'w7vT5VedMPyGHyDYppcacmtw-gzGzoHsz',
      appKey: 'YxBl09Aj50g5Ld621aydI4pz',
      placeholder: '来和大家一起讨论吧！',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div></div></body></html>