<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>MongoDB 报文解读 | LemonGo97のBlog</title><meta name="description" content="前言由于工作和学习的需要，需要对 MongoDB 的报文进行分析和解读，故通过 Wireshark 进行 MongoDB 的抓包进行分析和学习 正文在抓包过程中，我们发现 MongoDB 在3.6之后引入了新的数据交换格式，与之前不同，但总体报文解析逻辑是相同的 话不多说，先上MongoDB数据包的正确打开方式 配置MongoDB协议解码器 配置需要解码的端口号和协议  过滤掉除MongoDB外的"><meta name="keywords" content="MongoDB,TCP"><meta name="author" content="LemonGo97"><meta name="copyright" content="LemonGo97"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.lemongo97.com/posts/c88df007/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><meta property="og:type" content="article"><meta property="og:title" content="MongoDB 报文解读"><meta property="og:url" content="https://blog.lemongo97.com/posts/c88df007/"><meta property="og:site_name" content="LemonGo97のBlog"><meta property="og:description" content="前言由于工作和学习的需要，需要对 MongoDB 的报文进行分析和解读，故通过 Wireshark 进行 MongoDB 的抓包进行分析和学习 正文在抓包过程中，我们发现 MongoDB 在3.6之后引入了新的数据交换格式，与之前不同，但总体报文解析逻辑是相同的 话不多说，先上MongoDB数据包的正确打开方式 配置MongoDB协议解码器 配置需要解码的端口号和协议  过滤掉除MongoDB外的"><meta property="og:image" content="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/20200804150521.png"><meta property="article:published_time" content="2020-04-02T03:30:19.000Z"><meta property="article:modified_time" content="2021-03-01T03:37:10.065Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.1.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-03-01 11:37:10'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="LemonGo97のBlog" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="https://coding-net-production-static-ci.codehub.cn/d70d0fa9-08d5-4fc7-ba82-7b73fee22292.jpg?imageMogr2/auto-orient/format/jpeg/cut/700x700x0x0" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">33</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">28</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%A3%E6%96%87"><span class="toc-number">2.</span> <span class="toc-text">正文</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEMongoDB%E5%8D%8F%E8%AE%AE%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">配置MongoDB协议解码器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E7%B1%BB%E5%9E%8B%E7%9A%84-OP-CODE-%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">具体类型的 OP_CODE 格式解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OP-INSERT"><span class="toc-number">2.2.1.</span> <span class="toc-text">OP_INSERT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OP-DELETE"><span class="toc-number">2.2.2.</span> <span class="toc-text">OP_DELETE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OP-UPDATE"><span class="toc-number">2.2.3.</span> <span class="toc-text">OP_UPDATE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OP-QUERY"><span class="toc-number">2.2.4.</span> <span class="toc-text">OP_QUERY</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OP-GET-MORE"><span class="toc-number">2.2.5.</span> <span class="toc-text">OP_GET_MORE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OP-KILL-CURSORS"><span class="toc-number">2.2.6.</span> <span class="toc-text">OP_KILL_CURSORS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OP-MSG"><span class="toc-number">2.2.7.</span> <span class="toc-text">OP_MSG</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#flagBits"><span class="toc-number">2.2.7.1.</span> <span class="toc-text">flagBits</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sections"><span class="toc-number">2.2.7.2.</span> <span class="toc-text">Sections</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Checksum"><span class="toc-number">2.2.7.3.</span> <span class="toc-text">Checksum</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OP-REPLY"><span class="toc-number">2.2.8.</span> <span class="toc-text">OP_REPLY</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/20200804150521.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">LemonGo97のBlog</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">MongoDB 报文解读</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-04-02T03:30:19.000Z" title="发表于 2020-04-02 11:30:19">2020-04-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-03-01T03:37:10.065Z" title="更新于 2021-03-01 11:37:10">2021-03-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/">数据库相关</a></span></div><div class="meta-secondline"> </div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于工作和学习的需要，需要对 MongoDB 的报文进行分析和解读，故通过 Wireshark 进行 MongoDB 的抓包进行分析和学习</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>在抓包过程中，我们发现 MongoDB 在3.6之后引入了新的数据交换格式，与之前不同，但总体报文解析逻辑是相同的</p>
<p>话不多说，先上MongoDB数据包的正确打开方式</p>
<h2 id="配置MongoDB协议解码器"><a href="#配置MongoDB协议解码器" class="headerlink" title="配置MongoDB协议解码器"></a>配置MongoDB协议解码器</h2><ol>
<li><p>配置需要解码的端口号和协议<br><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/20200402145752.png" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/20200402145814.png" alt="配置端口和协议"></p>
</li>
<li><p>过滤掉除MongoDB外的其他报文<br><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/20200402145842.png" alt="配置过滤规则"></p>
</li>
<li><p>打开一个已经解码好的报文<br><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/20200402145858.png" alt="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/20200402145858.png"><br><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/20200402145926.png" alt="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/20200402145926.png"></p>
</li>
</ol>
<p>这样，我们就可以很直观的看到数据包中都传递了那些数据</p>
<p>对于 MongoDB 的协议来说，OpCode是一个很重要的东西，根据OpCode，MongoDB区分了不同版本的报文结构。我们在Wireshark中看到的报文结构，都是经过完全解码后的数据。</p>
<p>官方文档中也有对协议内容的一个大致说明：<a href="https://docs.mongodb.com/manual/reference/mongodb-wire-protocol/" target="_blank" rel="noopener">官方的协议说明</a></p>
<p>在报文中有固定的一些字段，如下：</p>
<table>
<thead>
<tr>
<th align="center">Field</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">messageLength</td>
<td align="left">The total size of the message in bytes. This total includes the 4 bytes that holds the message length.</td>
</tr>
<tr>
<td align="center">requestID</td>
<td align="left">A client or database-generated identifier that uniquely identifies this message. For the case of client-generated messages (e.g. OP_QUERY and OP_GET_MORE), it will be returned in the responseTo field of the OP_REPLY message. Clients can use the requestID and the responseTo fields to associate query responses with the originating query.</td>
</tr>
<tr>
<td align="center">responseTo</td>
<td align="left">In the case of a message from the database, this will be the requestID taken from the OP_QUERY or OP_GET_MORE messages from the client. Clients can use the requestID and the responseTo fields to associate query responses with the originating query.</td>
</tr>
<tr>
<td align="center">opCode</td>
<td align="left">Type of message. See Request Opcodes for details.</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MsgHeader</span> &#123;</span></span><br><span class="line">    int32   messageLength; <span class="comment">// total message size, including this</span></span><br><span class="line">    int32   requestID;     <span class="comment">// identifier for this message</span></span><br><span class="line">    int32   responseTo;    <span class="comment">// requestID from the original request</span></span><br><span class="line">                           <span class="comment">//   (used in responses from db)</span></span><br><span class="line">    int32   opCode;        <span class="comment">// request type - see table below for details</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>messageLength：代表了MongoDB一次消息通讯中的消息总长度，位置在消息头部。</p>
<p>requestId：一般为请求发起方的消息包ID，此ID是自增长的，MongoDB会根据这个Id来返回这个ID对应的数据包</p>
<p>responseTo：一般为MongoDB返回的消息包ID，这个ID为请求包的requestId</p>
<p>opCode：代表了数据包中的消息类型，具体的OpCode的对应关系如下</p>
<p>OpCode编号与其含义对应如下：</p>
<blockquote>
<p>NOTE:<br>Starting with MongoDB 2.6 and maxWireVersion 3, MongoDB drivers use the database commands insert, update, and delete instead of OP_INSERT, OP_UPDATE, and OP_DELETE for acknowledged writes. Most drivers continue to use opcodes for unacknowledged writes.<br>In version 4.2, MongoDB removes the deprecated internal OP_COMMAND and OP_COMMANDREPLY protocol.</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">Opcode Name</th>
<th align="center">Value</th>
<th align="left">Comment</th>
</tr>
</thead>
<tbody><tr>
<td align="center">OP_REPLY</td>
<td align="center">1</td>
<td align="left">Reply to a client request. responseTo is set.</td>
</tr>
<tr>
<td align="center">OP_UPDATE</td>
<td align="center">2001</td>
<td align="left">Update document.</td>
</tr>
<tr>
<td align="center">OP_INSERT</td>
<td align="center">2002</td>
<td align="left">Insert new document.</td>
</tr>
<tr>
<td align="center">RESERVED</td>
<td align="center">2003</td>
<td align="left">Formerly used for OP_GET_BY_OID.</td>
</tr>
<tr>
<td align="center">OP_QUERY</td>
<td align="center">2004</td>
<td align="left">Query a collection.</td>
</tr>
<tr>
<td align="center">OP_GET_MORE</td>
<td align="center">2005</td>
<td align="left">Get more data from a query. See Cursors.</td>
</tr>
<tr>
<td align="center">OP_DELETE</td>
<td align="center">2006</td>
<td align="left">Delete documents.</td>
</tr>
<tr>
<td align="center">OP_KILL_CURSORS</td>
<td align="center">2007</td>
<td align="left">Notify database that the client has finished with the cursor.</td>
</tr>
<tr>
<td align="center">OP_MSG</td>
<td align="center">2013</td>
<td align="left">Send a message using the format introduced in MongoDB 3.6.</td>
</tr>
</tbody></table>
<h2 id="具体类型的-OP-CODE-格式解析"><a href="#具体类型的-OP-CODE-格式解析" class="headerlink" title="具体类型的 OP_CODE 格式解析"></a>具体类型的 OP_CODE 格式解析</h2><h3 id="OP-INSERT"><a href="#OP-INSERT" class="headerlink" title="OP_INSERT"></a>OP_INSERT</h3><p>OP_INSERT消息用于将一个或多个文档插入到集合中。OP_INSERT消息的格式为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    MsgHeader header;             <span class="comment">// standard message header</span></span><br><span class="line">    int32     flags;              <span class="comment">// bit vector - see below</span></span><br><span class="line">    cstring   fullCollectionName; <span class="comment">// "dbname.collectionname"</span></span><br><span class="line">    document* documents;          <span class="comment">// one or more documents to insert into the collection</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">Field</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">header</td>
<td align="left">消息头，参照上方标准消息头</td>
</tr>
<tr>
<td align="center">flags</td>
<td align="left">位向量，用于指定操作标志。如果为0，则数据库不会因为某条数据插入失败而停止插入。1-31为数据库保留</td>
</tr>
<tr>
<td align="center">fullCollectionName</td>
<td align="left">完整的集合名称，也被称为命名空间，一般格式为: &lt;数据库.集合名&gt;</td>
</tr>
<tr>
<td align="center">documents</td>
<td align="left">一个或多个要插入集合的文档。如果有多个，则依次将它们依次写入socket。</td>
</tr>
</tbody></table>
<p>OP_INSERT消息无响应。</p>
<h3 id="OP-DELETE"><a href="#OP-DELETE" class="headerlink" title="OP_DELETE"></a>OP_DELETE</h3><p>OP_DELETE消息用于从集合中删除一个或多个文档。OP_DELETE消息的格式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    MsgHeader header;             <span class="comment">// standard message header</span></span><br><span class="line">    int32     ZERO;               <span class="comment">// 0 - reserved for future use</span></span><br><span class="line">    cstring   fullCollectionName; <span class="comment">// "dbname.collectionname"</span></span><br><span class="line">    int32     flags;              <span class="comment">// bit vector - see below for details.</span></span><br><span class="line">    document  selector;           <span class="comment">// query object.  See below for details.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">Field</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">header</td>
<td align="left">消息头，参照上方标准消息头</td>
</tr>
<tr>
<td align="center">ZERO</td>
<td align="left">整数值0。暂未使用，官方称保留以备将来使用</td>
</tr>
<tr>
<td align="center">numberOfCursorIDs</td>
<td align="left">消息中的游标ID的数量</td>
</tr>
<tr>
<td align="center">cursorIDs</td>
<td align="left">要删除的游标ID的“数组”。如果有多个，则依次将它们依次写入套接字</td>
</tr>
</tbody></table>
<p>如果游标被读取直到用尽（直到OP_QUERY 或OP_GET_MORE返回零作为游标ID），就没有必要终止游标</p>
<h3 id="OP-UPDATE"><a href="#OP-UPDATE" class="headerlink" title="OP_UPDATE"></a>OP_UPDATE</h3><p>OP_UPDATE消息用于更新集合中的文档。OP_UPDATE消息的格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OP_UPDATE</span> &#123;</span></span><br><span class="line">    MsgHeader header;             <span class="comment">// standard message header</span></span><br><span class="line">    int32     ZERO;               <span class="comment">// 0 - reserved for future use</span></span><br><span class="line">    cstring   fullCollectionName; <span class="comment">// "dbname.collectionname"</span></span><br><span class="line">    int32     flags;              <span class="comment">// bit vector. see below</span></span><br><span class="line">    document  selector;           <span class="comment">// the query to select the document</span></span><br><span class="line">    document  update;             <span class="comment">// specification of the update to perform</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">Field</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">header</td>
<td align="left">消息头，参照上方标准消息头</td>
</tr>
<tr>
<td align="center">ZERO</td>
<td align="left">整数值0。暂未使用，官方称保留以备将来使用</td>
</tr>
<tr>
<td align="center">fullCollectionName</td>
<td align="left">完整的集合名称，也被称为命名空间，一般格式为: &lt;数据库.集合名&gt;</td>
</tr>
<tr>
<td align="center">flags</td>
<td align="left">位向量，用于指定操作标志。0：对应于Upsert。如果设置，则如果找不到匹配的文档，数据库将把提供的对象插入集合中。1：对应于MultiUpdate。如果设置，数据库将更新集合中的所有匹配对象。否则，仅更新第一个匹配的文档。2- 31保留。必须设置为0。</td>
</tr>
<tr>
<td align="center">selector</td>
<td align="left">BSON文档，指定用于选择要更新的文档的查询。</td>
</tr>
<tr>
<td align="center">update</td>
<td align="left">BSON文档，指定要执行的更新</td>
</tr>
</tbody></table>
<p>OP_UPDATE消息无响应。</p>
<h3 id="OP-QUERY"><a href="#OP-QUERY" class="headerlink" title="OP_QUERY"></a>OP_QUERY</h3><p>OP_QUERY消息用于在数据库中查询集合中的文档。OP_QUERY消息的格式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OP_QUERY</span> &#123;</span></span><br><span class="line">    MsgHeader header;                 <span class="comment">// standard message header</span></span><br><span class="line">    int32     flags;                  <span class="comment">// bit vector of query options.  See below for details.</span></span><br><span class="line">    cstring   fullCollectionName ;    <span class="comment">// "dbname.collectionname"</span></span><br><span class="line">    int32     numberToSkip;           <span class="comment">// number of documents to skip</span></span><br><span class="line">    int32     numberToReturn;         <span class="comment">// number of documents to return</span></span><br><span class="line">                                      <span class="comment">//  in the first OP_REPLY batch</span></span><br><span class="line">    document  query;                  <span class="comment">// query object.  See below for details.</span></span><br><span class="line">  [ document  returnFieldsSelector; ] <span class="comment">// Optional. Selector indicating the fields</span></span><br><span class="line">                                      <span class="comment">//  to return.  See below for details.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">Field</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">header</td>
<td align="left">消息头，参照上方标准消息头</td>
</tr>
<tr>
<td align="center">flags</td>
<td align="left">位向量，用于指定操作标志。</td>
</tr>
<tr>
<td align="center">fullCollectionName</td>
<td align="left">完整的集合名称，也被称为命名空间，一般格式为: &lt;数据库.集合名&gt;</td>
</tr>
<tr>
<td align="center">numberToSkip</td>
<td align="left">设置要跳过的文档数-从结果数据集中的第一个文档开始-返回查询结果时。</td>
</tr>
<tr>
<td align="center">numberToReturn</td>
<td align="left">将第一个OP_REPLY消息中的文档数限制为查询。但是，cursorID如果结果多于，数据库仍将建立游标并将其返回给客户端numberToReturn。如果客户端驱动程序提供了“限制”功能（例如SQL LIMIT关键字），则由客户端驱动程序来确保将不超过指定数量的文档返回给调用应用程序。如果numberToReturn为0，则数据库将使用默认的返回大小。如果数字为负，则数据库将返回该数字并关闭游标。无法获取该查询的其他结果。如果numberToReturn为， 1则服务器会将其视为-1（自动关闭光标）。</td>
</tr>
<tr>
<td align="center">query</td>
<td align="left">代表查询的BSON文档。该查询将包含一个或多个元素，所有这些元素都必须匹配才能使文档包含在结果集中。可能的因素包括 $query，$orderby，$hint，和$explain。</td>
</tr>
<tr>
<td align="center">returnFieldsSelector</td>
<td align="left">可选BSON文档，用于限制返回文档中的字段。所述returnFieldsSelector含有一种或多种元素，其中的每一个是应返回字段的名称，以及整数值1。</td>
</tr>
</tbody></table>
<p>对于上方flags字段，具体描述如下：</p>
<ul>
<li>0被预定了。必须设置为0。</li>
<li>1对应于TailableCursor。可拖尾表示检索到最后一个数据时光标未关闭。而是，光标标记最终对象的位置。如果收到更多数据，则可以稍后从光标所在的位置继续使用它。像任何“潜在游标”一样，游标可能会在某个时候失效（CursorNotFound）–例如，如果删除了它所引用的最终对象。</li>
<li>2对应于SlaveOk.Allow查询副本从属。通常，这些返回错误，但名称空间“ local”除外。</li>
<li>3对应于OplogReplay。仅供内部复制使用-不应设置驱动程序。</li>
<li>4对应于NoCursorTimeout。服务器通常在闲置时间（10分钟）后使空闲游标超时，以防止过多使用内存。设置此选项可以防止这种情况。</li>
<li>5对应于AwaitData。与TailableCursor一起使用。如果我们在数据的末尾，请阻塞一会儿，而不要返回任何数据。超时后，我们照常返回。</li>
<li>6对应于排气。假设客户端将完全读取所有查询的数据，则将数据以多个“更多”包的形式完整传输。当您提取大量数据并知道要全部提取时，速度更快。注意：除非客户端关闭连接，否则不允许客户端不读取所有数据。</li>
<li>7对应于部分。如果某些分片发生故障，则从mongos获得部分结果（而不是引发错误）</li>
<li>8-31保留。必须设置为0。</li>
</ul>
<p>数据库使用OP_REPLY消息来响应 OP_QUERY消息。</p>
<h3 id="OP-GET-MORE"><a href="#OP-GET-MORE" class="headerlink" title="OP_GET_MORE"></a>OP_GET_MORE</h3><p>OP_GET_MORE消息用于在数据库中查询集合中的文档。OP_GET_MORE消息的格式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    MsgHeader header;             <span class="comment">// standard message header</span></span><br><span class="line">    int32     ZERO;               <span class="comment">// 0 - reserved for future use</span></span><br><span class="line">    cstring   fullCollectionName; <span class="comment">// "dbname.collectionname"</span></span><br><span class="line">    int32     numberToReturn;     <span class="comment">// number of documents to return</span></span><br><span class="line">    int64     cursorID;           <span class="comment">// cursorID from the OP_REPLY</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">Field</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">header</td>
<td align="left">消息头，参照上方标准消息头</td>
</tr>
<tr>
<td align="center">ZERO</td>
<td align="left">整数值0。暂未使用，官方称保留以备将来使用</td>
</tr>
<tr>
<td align="center">fullCollectionName</td>
<td align="left">完整的集合名称，也被称为命名空间，一般格式为: &lt;数据库.集合名&gt;</td>
</tr>
<tr>
<td align="center">numberToReturn</td>
<td align="left">将第一个OP_REPLY消息中的文档数限制为查询。但是，cursorID如果结果多于，数据库仍将建立游标并将其返回给客户端numberToReturn。如果客户端驱动程序提供了“限制”功能（例如SQL LIMIT关键字），则由客户端驱动程序来确保将不超过指定数量的文档返回给调用应用程序。如果numberToReturn为0，则数据库将使用默认的返回大小。</td>
</tr>
<tr>
<td align="center">cursorID</td>
<td align="left">OP_REPLY中的光标标识符。这必须是来自数据库的值。</td>
</tr>
</tbody></table>
<p>数据库将以OP_REPLY消息响应 OP_GET_MORE消息。</p>
<h3 id="OP-KILL-CURSORS"><a href="#OP-KILL-CURSORS" class="headerlink" title="OP_KILL_CURSORS"></a>OP_KILL_CURSORS</h3><p>OP_KILL_CURSORS消息用于关闭数据库中的活动游标。这是确保查询结束时回收数据库资源所必需的。OP_KILL_CURSORS消息的格式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    MsgHeader header;            <span class="comment">// standard message header</span></span><br><span class="line">    int32     ZERO;              <span class="comment">// 0 - reserved for future use</span></span><br><span class="line">    int32     numberOfCursorIDs; <span class="comment">// number of cursorIDs in message</span></span><br><span class="line">    int64*    cursorIDs;         <span class="comment">// sequence of cursorIDs to close</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">Field</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">header</td>
<td align="left">消息头，参照上方标准消息头</td>
</tr>
<tr>
<td align="center">ZERO</td>
<td align="left">整数值0。暂未使用，官方称保留以备将来使用</td>
</tr>
<tr>
<td align="center">numberOfCursorIDs</td>
<td align="left">消息中的游标ID的数量。</td>
</tr>
<tr>
<td align="center">cursorIDs</td>
<td align="left">要关闭的游标ID的“数组”。如果有多个，则依次将它们依次写入socket。</td>
</tr>
<tr>
<td align="center">如果游标被读取直到用尽（直到OP_QUERY 或OP_GET_MORE返回零作为游标ID），就没有必要终止游标。</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="OP-MSG"><a href="#OP-MSG" class="headerlink" title="OP_MSG"></a>OP_MSG</h3><blockquote>
<p>MongoDB版本中的新功能： 3.6</p>
</blockquote>
<p>OP_MSG是一种可扩展的消息格式，旨在包含其他操作码的功能。OP_MSG消息的格式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OP_MSG &#123;</span><br><span class="line">    MsgHeader header;          <span class="comment">// standard message header</span></span><br><span class="line">    uint32 flagBits;           <span class="comment">// message flags</span></span><br><span class="line">    Sections[] sections;       <span class="comment">// data sections</span></span><br><span class="line">    optional&lt;uint32&gt; checksum; <span class="comment">// optional CRC-32C checksum</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">Field</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">header</td>
<td align="left">消息头，参照上方标准消息头</td>
</tr>
<tr>
<td align="center">flagBits</td>
<td align="left">包含消息标志的整数位掩码</td>
</tr>
<tr>
<td align="center">sections</td>
<td align="left">消息主体部中，如所描述的章节</td>
</tr>
<tr>
<td align="center">checksum</td>
<td align="left">可选的CRC-32C校验和，如 Checksum中所述</td>
</tr>
</tbody></table>
<p>具体信息参照下方描述：</p>
<h4 id="flagBits"><a href="#flagBits" class="headerlink" title="flagBits"></a>flagBits</h4><p>该flagBits整数是编码修改的格式和行为的标志位掩码OP_MSG。</p>
<p>前16位（0-15）是必需的， 如果设置了一个位置的bit，则解析器务必出错。</p>
<p>最后16位（16-31）是可选的，解析器务必忽略任何未知的被设置的bit。代理和其他消息转发器必须在转发消息之前清除所有未知的可选位。</p>
<table>
<thead>
<tr>
<th align="center">Bit</th>
<th align="center">Name</th>
<th align="center">Request</th>
<th align="center">Response</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">checksumPresent</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="left">该消息以4个字节结尾，其中包含CRC-32C [1] 校验和。</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">moreToCome</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="left">另一条消息将跟随此消息，而无需接收者采取进一步措施。接收器必须不发送另一消息，直到接收到一个具有moreToCome设置为0作为发送可能阻塞，引起死锁。moreToCome 设置了该位的请求将不会收到答复。答复将仅在设置了该exhaustAllowed位的情况下响应此请求。</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">exhaustAllowed</td>
<td align="center">✓</td>
<td align="center">-</td>
<td align="left">客户端已准备好使用该moreToCome位对该请求进行多次答复。moreToCome除非请求设置了该位，否则服务器将永远不会产生设置了位的回复。这样可以确保仅在请求者的网络层已准备好多个答复时才发送它们。</td>
</tr>
</tbody></table>
<p>MongoDB 3.6会忽略此标志，并将以一条消息进行响应</p>
<h4 id="Sections"><a href="#Sections" class="headerlink" title="Sections"></a>Sections</h4><p>一条OP_MSG消息包含一个或多个部分。每个部分都以一个kind指示其类型的字节开头。kind 字节之后的所有内容均构成该节的有效负载。</p>
<p>可用的部分如下：</p>
<ul>
<li>Kind 0: Body</li>
</ul>
<p>正文部分被编码为单个 BSON对象。BSON对象中的大小也用作部分的大小。此部分类型是标准命令请求和答复正文。</p>
<p>所有顶级字段都必须具有唯一的名称。</p>
<ul>
<li>Kind 1: Document Sequence</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int32</td>
<td>section的大小.</td>
</tr>
<tr>
<td align="center">C String</td>
<td>文档序列标识符。在所有当前命令中，此字段是从body section替换的（可能是嵌套的）字段。但是不得也存在于主体部分。</td>
</tr>
<tr>
<td align="center">Zero or more BSON objects</td>
<td>零个或多个BSON对象。对象不使用分隔符来背对背排序。</td>
</tr>
</tbody></table>
<p>对于Zero or more BSON objects来说，每个对象仅限于maxBSONObjectSize服务器的。所有对象的组合不限于 maxBSONObjSize。<br>一旦size消耗完字节，文档序列就结束。<br>转换为语言级对象时，解析器可以选择将这些对象作为数组合并到序列标识符指定的路径处的数组中。</p>
<h4 id="Checksum"><a href="#Checksum" class="headerlink" title="Checksum"></a>Checksum</h4><p>每条消息可以以CRC-32C [1]校验和结尾，该校验和覆盖消息中所有字节，校验和本身除外</p>
<p>从MongoDB 4.2开始：</p>
<ul>
<li>mongod如果不使用TLS / SSL连接mongos，则实例，实例和 mongo外壳程序实例将与校验和交换消息。</li>
<li>mongod如果使用TLS / SSL连接mongos，则实例，实例和 mongo外壳程序实例将跳过校验和。</li>
</ul>
<p>如果驱动程序和较旧的二进制文件带有带有校验和的消息，则它们将忽略校验和。</p>
<p>checksumPresent标志位指示存在校验和。</p>
<h3 id="OP-REPLY"><a href="#OP-REPLY" class="headerlink" title="OP_REPLY"></a>OP_REPLY</h3><p>该OP_REPLY消息由数据库发送，以响应 OP_QUERY或OP_GET_MORE消息。OP_REPLY消息的格式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    MsgHeader header;         <span class="comment">// standard message header</span></span><br><span class="line">    int32     responseFlags;  <span class="comment">// bit vector - see details below</span></span><br><span class="line">    int64     cursorID;       <span class="comment">// cursor id if client needs to do get more's</span></span><br><span class="line">    int32     startingFrom;   <span class="comment">// where in the cursor this reply is starting</span></span><br><span class="line">    int32     numberReturned; <span class="comment">// number of documents in the reply</span></span><br><span class="line">    document* documents;      <span class="comment">// documents</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th align="center">Field</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">header</td>
<td>消息头，参照上方标准消息头</td>
</tr>
<tr>
<td align="center">responseFlags</td>
<td>指定标志的bit向量</td>
</tr>
<tr>
<td align="center">cursorID</td>
<td>该cursorID 为 OP_REPLY的一部分。如果查询的结果集适合一个OP_REPLY消息， cursorID则将为0。cursorID必须在用于获取更多数据的任何 OP_GET_MORE消息中使用此值，并且当不再需要通过OP_KILL_CURSORS 消息将其关闭时，客户端也必须将其关闭。</td>
</tr>
<tr>
<td align="center">startingFrom</td>
<td>游标开始位置</td>
</tr>
<tr>
<td align="center">numberReturned</td>
<td>返回的文档数量.</td>
</tr>
<tr>
<td align="center">documents</td>
<td>返回的文档</td>
</tr>
</tbody></table>
<p>对于responseFlags的说明</p>
<ul>
<li>0对应于CursorNotFound。在getMore调用时设置，但光标ID在服务器上无效。返回结果为零。</li>
<li>1对应于QueryFailure。查询失败时设置。结果由一个文档组成，其中包含描述失败的“ $ err”字段。</li>
<li>2对应于ShardConfigStale。驱动应忽略这一点。只有mongos将看到此设置，在这种情况下，它需要从服务器更新配置。</li>
<li>3对应于AwaitCapable。当服务器支持AwaitData查询选项时设置。如果不是这样，则客户端应该在Tailable游标的getMore之间睡一会儿。Mongod 1.6版支持AwaitData，因此始终设置AwaitCapable。</li>
<li>4-31保留。忽视。</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">LemonGo97</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.lemongo97.com/posts/c88df007/">https://blog.lemongo97.com/posts/c88df007/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.lemongo97.com" target="_blank">LemonGo97のBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MongoDB/">MongoDB</a><a class="post-meta__tags" href="/tags/TCP/">TCP</a></div><div class="post_share"><div class="social-share" data-image="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/20200804150521.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/posts/8662ab0e/"><img class="prev-cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/timothy-meinberg-b079C-_tUbM-unsplash.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java 网络编程之 SSL加密连接</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/posts/ff140f31/" title="MongoDB全方位知识图谱"><img class="relatedPosts_cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/20200804150521.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-30</div><div class="relatedPosts_title">MongoDB全方位知识图谱</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By LemonGo97</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/instant.page/5.1.0/instantpage.min.js" type="module" defer></script><script src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.3.1/lazyload.iife.min.js" async></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'w7vT5VedMPyGHyDYppcacmtw-gzGzoHsz',
      appKey: 'YxBl09Aj50g5Ld621aydI4pz',
      placeholder: '来和大家一起讨论吧！',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div></div></body></html>