<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>深入理解 Linux 的 TCP 三次握手 | LemonGo97のBlog</title><meta name="description" content="作者：yanfeizhang，腾讯 PCG 后台开发工程师 在后端相关岗位的入职面试中，三次握手的出场频率非常的高，甚至说它是必考题也不为过。一般的答案都是说客户端如何发起 SYN 握手进入 SYN_SENT 状态，服务器响应 SYN 并回复 SYNACK，然后进入 SYN_RECV 等诸如此类。但今天我想给出一份不一样的答案。 其实三次握手在内核的实现中，并不只是简单的状态的流转，还包括端口选择"><meta name="keywords" content="tcp"><meta name="author" content="LemonGo97"><meta name="copyright" content="LemonGo97"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.lemongo97.com/posts/ffad71e9/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><meta property="og:type" content="article"><meta property="og:title" content="深入理解 Linux 的 TCP 三次握手"><meta property="og:url" content="https://blog.lemongo97.com/posts/ffad71e9/"><meta property="og:site_name" content="LemonGo97のBlog"><meta property="og:description" content="作者：yanfeizhang，腾讯 PCG 后台开发工程师 在后端相关岗位的入职面试中，三次握手的出场频率非常的高，甚至说它是必考题也不为过。一般的答案都是说客户端如何发起 SYN 握手进入 SYN_SENT 状态，服务器响应 SYN 并回复 SYNACK，然后进入 SYN_RECV 等诸如此类。但今天我想给出一份不一样的答案。 其实三次握手在内核的实现中，并不只是简单的状态的流转，还包括端口选择"><meta property="og:image" content="https://image.lemongo97.com/default_cover_1.jpg"><meta property="article:published_time" content="2023-01-07T15:57:02.000Z"><meta property="article:modified_time" content="2023-01-07T15:57:02.000Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.1.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2023-01-07 23:57:02'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="LemonGo97のBlog" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="https://coding-net-production-static-ci.codehub.cn/d70d0fa9-08d5-4fc7-ba82-7b73fee22292.jpg?imageMogr2/auto-orient/format/jpeg/cut/700x700x0x0" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">65</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">39</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84-listen"><span class="toc-number">1.</span> <span class="toc-text">一、服务器的 listen</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF-connect"><span class="toc-number">2.</span> <span class="toc-text">二、客户端 connect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94-SYN"><span class="toc-number">3.</span> <span class="toc-text">三、服务器响应 SYN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%93%8D%E5%BA%94-SYNACK"><span class="toc-number">4.</span> <span class="toc-text">四、客户端响应 SYNACK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94-ACK"><span class="toc-number">5.</span> <span class="toc-text">五、服务器响应 ACK</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E5%88%9B%E5%BB%BA%E5%AD%90-socket"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 创建子 socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E5%88%A0%E9%99%A4%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 删除半连接队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E6%B7%BB%E5%8A%A0%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 添加全连接队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-%E8%AE%BE%E7%BD%AE%E8%BF%9E%E6%8E%A5%E4%B8%BA-ESTABLISHED"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 设置连接为 ESTABLISHED</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8-accept"><span class="toc-number">6.</span> <span class="toc-text">六、服务器 accept</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E6%96%87%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">本文总结</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://image.lemongo97.com/default_cover_1.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">LemonGo97のBlog</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">【转载】 深入理解 Linux 的 TCP 三次握手</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-07T15:57:02.000Z" title="发表于 2023-01-07 23:57:02">2023-01-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-07T15:57:02.000Z" title="更新于 2023-01-07 23:57:02">2023-01-07</time></span></div><div class="meta-secondline"> </div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>作者：yanfeizhang，腾讯 PCG 后台开发工程师</p>
<p>在后端相关岗位的入职面试中，三次握手的出场频率非常的高，甚至说它是必考题也不为过。一般的答案都是说客户端如何发起 SYN 握手进入 SYN_SENT 状态，服务器响应 SYN 并回复 SYNACK，然后进入 SYN_RECV 等诸如此类。但今天我想给出一份不一样的答案。</p>
<p>其实三次握手在内核的实现中，并不只是简单的状态的流转，还包括端口选择，半连接队列、syncookie、全连接队列、重传计时器等关键操作。如果能深刻理解这些，你对线上把握和理解将更进一步。如果有面试官问起你三次握手，相信这份答案一定能帮你在面试官面前赢得非常多的加分。</p>
<p>在基于 TCP 的服务开发中，三次握手的主要流程图如下：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/c21c64a78617fdf943c253386545adc4.jpeg" alt=""></p>
<p>服务器中的核心代码是创建 socket，绑定端口，listen 监听，最后 accept 接收客户端的请求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//服务端核心代码  </span><br><span class="line">int main(int argc, char const *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line"> int fd = socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line"> bind(fd, ...);  </span><br><span class="line"> listen(fd, 128);  </span><br><span class="line"> accept(fd, ...);  </span><br><span class="line"> ...  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端的相关代码是创建 socket，然后调用 connect 连接 server。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//客户端核心代码  </span><br><span class="line">int main()&#123;  </span><br><span class="line"> fd = socket(AF_INET,SOCK_STREAM, 0);  </span><br><span class="line"> connect(fd, ...);  </span><br><span class="line"> ...  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看起来简单的几个系统调用，实际上却包含了非常复杂的内核底层操作。根据内核工作原理，我深度展开一下三次握手过程中的内部操作。</p>
<p><strong>友情提示</strong>：本文中内核源码会比较多。如果你能理解的了更好，如果觉得理解起来有困难，那直接重点看本文中的描述性的文字，尤其是加粗部分的即可。另外文章最后有一张总结图归纳和整理了全文内容。</p>
<h3 id="一、服务器的-listen"><a href="#一、服务器的-listen" class="headerlink" title="一、服务器的 listen"></a>一、服务器的 listen</h3><p>我们都知道，服务器在开始提供服务之前都需要先 listen 一下。但 listen 内部究竟干了啥，我们平时很少去琢磨。</p>
<p>今天就让我们详细来看看，直接上一段 listen 时执行到的内核代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//file: net/core/request_sock.c  </span><br><span class="line">int reqsk_queue_alloc(struct request_sock_queue *queue,  </span><br><span class="line">     unsigned int nr_table_entries)  </span><br><span class="line">&#123;  </span><br><span class="line"> size_t lopt_size = sizeof(struct listen_sock);  </span><br><span class="line"> struct listen_sock *lopt;  </span><br><span class="line">  </span><br><span class="line"> //计算半连接队列的长度  </span><br><span class="line"> nr_table_entries = min_t(u32, nr_table_entries, sysctl_max_syn_backlog);  </span><br><span class="line"> nr_table_entries = ......  </span><br><span class="line">  </span><br><span class="line"> //为半连接队列申请内存  </span><br><span class="line"> lopt_size += nr_table_entries * sizeof(struct request_sock *);  </span><br><span class="line"> if (lopt_size &gt; PAGE_SIZE)  </span><br><span class="line">  lopt = vzalloc(lopt_size);  </span><br><span class="line"> else  </span><br><span class="line">  lopt = kzalloc(lopt_size, GFP_KERNEL);  </span><br><span class="line">  </span><br><span class="line"> //全连接队列头初始化  </span><br><span class="line"> queue-&gt;rskq_accept_head = NULL;  </span><br><span class="line">  </span><br><span class="line"> //半连接队列设置  </span><br><span class="line"> lopt-&gt;nr_table_entries = nr_table_entries;  </span><br><span class="line"> queue-&gt;listen_opt = lopt;  </span><br><span class="line"> ......  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这段代码里，内核计算了半连接队列的长度。然后据此算出半连接队列所需要的实际内存大小，开始申请用于管理半连接队列对象的内存（半连接队列需要快速查找，所以内核是用哈希表来管理半连接队列的，具体在 listen_sock 下的 syn_table 下）。最后将半连接队列挂到了接收队列 queue 上。</p>
<p>另外 queue-&gt;rskq_accept_head 代表的是全连接队列，它是一个链表的形式。在 listen 这里因为还没有连接，所以将全连接队列头 queue-&gt;rskq_accept_head 设置成 NULL。</p>
<p>当全连接队列和半连接队列中有元素的时候，他们在内核中的结构图大致如下。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/5e407df93ba9b00fafef164025e43377.png" alt=""></p>
<p><strong>在服务器 listen 的时候，主要是进行了全/半连接队列的长度限制计算，以及相关的内存申请和初始化</strong>。全/连接队列初始化了以后才可以相应来自客户端的握手请求。</p>
<p>如果想了解更多的 listen 内部操作细节可以看之前的一篇文章<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247485737&idx=1&sn=baba45ad4fb98afe543bdfb06a5720b8&scene=21#wechat_redirect">《为什么服务端程序都需要先 listen 一下？》</a></p>
<h3 id="二、客户端-connect"><a href="#二、客户端-connect" class="headerlink" title="二、客户端 connect"></a>二、客户端 connect</h3><p>客户端通过调用 connect 来发起连接。在 connect 系统调用中会进入到内核源码的 tcp_v4_connect。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//file: net/ipv4/tcp_ipv4.c  </span><br><span class="line">int tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)  </span><br><span class="line">&#123;  </span><br><span class="line"> //设置 socket 状态为 TCP_SYN_SENT  </span><br><span class="line"> tcp_set_state(sk, TCP_SYN_SENT);  </span><br><span class="line">  </span><br><span class="line"> //动态选择一个端口  </span><br><span class="line"> err = inet_hash_connect(&amp;tcp_death_row, sk);  </span><br><span class="line">  </span><br><span class="line"> //函数用来根据 sk 中的信息，构建一个完成的 syn 报文，并将它发送出去。  </span><br><span class="line"> err = tcp_connect(sk);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这里将完成把 socket 状态设置为 TCP_SYN_SENT。再通过 inet_hash_connect 来动态地选择一个可用的端口后（端口选择详细过程参考前文<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247485577&idx=1&sn=24220fcc3782f61b4a691585251f1c27&scene=21#wechat_redirect">《TCP 连接中客户端的端口号是如何确定的？》</a>），进入到 tcp_connect 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//file:net/ipv4/tcp_output.c  </span><br><span class="line">int tcp_connect(struct sock *sk)  </span><br><span class="line">&#123;  </span><br><span class="line"> tcp_connect_init(sk);  </span><br><span class="line">  </span><br><span class="line"> //申请 skb 并构造为一个 SYN 包  </span><br><span class="line"> ......  </span><br><span class="line">  </span><br><span class="line"> //添加到发送队列 sk_write_queue 上  </span><br><span class="line"> tcp_connect_queue_skb(sk, buff);  </span><br><span class="line">  </span><br><span class="line"> //实际发出 syn  </span><br><span class="line"> err = tp-&gt;fastopen_req ? tcp_send_syn_data(sk, buff) :  </span><br><span class="line">    tcp_transmit_skb(sk, buff, 1, sk-&gt;sk_allocation);  </span><br><span class="line">  </span><br><span class="line"> //启动重传定时器  </span><br><span class="line"> inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,  </span><br><span class="line">      inet_csk(sk)-&gt;icsk_rto, TCP_RTO_MAX);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 tcp_connect 申请和构造 SYN 包，然后将其发出。同时还启动了一个重传定时器，该定时器的作用是等到一定时间后收不到服务器的反馈的时候来开启重传。在 3.10 版本中首次超时时间是 1 s，一些老版本中是 3 s。</p>
<p><strong>总结一下，客户端在 connect 的时候，把本地 socket 状态设置成了 TCP_SYN_SENT，选了一个可用的端口，接着发出 SYN 握手请求并启动重传定时器</strong>。</p>
<h3 id="三、服务器响应-SYN"><a href="#三、服务器响应-SYN" class="headerlink" title="三、服务器响应 SYN"></a>三、服务器响应 SYN</h3><p>在服务器端，所有的 TCP 包（包括客户端发来的 SYN 握手请求）都经过网卡、软中断，进入到 tcp_v4_rcv。在该函数中根据网络包（skb）TCP 头信息中的目的 IP 信息查到当前在 listen 的 socket。然后继续进入 tcp_v4_do_rcv 处理握手过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//file: net/ipv4/tcp_ipv4.c  </span><br><span class="line">int tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb)  </span><br><span class="line">&#123;  </span><br><span class="line"> ...  </span><br><span class="line"> //服务器收到第一步握手 SYN 或者第三步 ACK 都会走到这里  </span><br><span class="line"> if (sk-&gt;sk_state == TCP_LISTEN) &#123;  </span><br><span class="line">  struct sock *nsk = tcp_v4_hnd_req(sk, skb);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> if (tcp_rcv_state_process(sk, skb, tcp_hdr(skb), skb-&gt;len)) &#123;  </span><br><span class="line">  rsk = sk;  </span><br><span class="line">  goto reset;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 tcp_v4_do_rcv 中判断当前 socket 是 listen 状态后，首先会到 tcp_v4_hnd_req 去查看半连接队列。服务器第一次响应 SYN 的时候，半连接队列里必然是空空如也，所以相当于什么也没干就返回了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//file:net/ipv4/tcp_ipv4.c  </span><br><span class="line">static struct sock *tcp_v4_hnd_req(struct sock *sk, struct sk_buff *skb)  </span><br><span class="line">&#123;  </span><br><span class="line"> // 查找 listen socket 的半连接队列  </span><br><span class="line"> struct request_sock *req = inet_csk_search_req(sk, &amp;prev, th-&gt;source,  </span><br><span class="line">          iph-&gt;saddr, iph-&gt;daddr);  </span><br><span class="line"> ...  </span><br><span class="line"> return sk;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 tcp_rcv_state_process 里根据不同的 socket 状态进行不同的处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//file:net/ipv4/tcp_input.c  </span><br><span class="line">int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb,  </span><br><span class="line">     const struct tcphdr *th, unsigned int len)  </span><br><span class="line">&#123;  </span><br><span class="line"> switch (sk-&gt;sk_state) &#123;  </span><br><span class="line">  //第一次握手  </span><br><span class="line">  case TCP_LISTEN:  </span><br><span class="line">   if (th-&gt;syn) &#123; //判断是 SYN 握手包  </span><br><span class="line">    ...  </span><br><span class="line">    if (icsk-&gt;icsk_af_ops-&gt;conn_request(sk, skb) &lt; 0)  </span><br><span class="line">     return 1;  </span><br><span class="line"> ......  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中 conn_request 是一个函数指针，指向 tcp_v4_conn_request。<strong>服务器响应 SYN 的主要处理逻辑都在这个 tcp_v4_conn_request 里</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//file: net/ipv4/tcp_ipv4.c  </span><br><span class="line">int tcp_v4_conn_request(struct sock *sk, struct sk_buff *skb)  </span><br><span class="line">&#123;  </span><br><span class="line"> //看看半连接队列是否满了  </span><br><span class="line"> if (inet_csk_reqsk_queue_is_full(sk) &amp;&amp; !isn) &#123;  </span><br><span class="line">  want_cookie = tcp_syn_flood_action(sk, skb, &quot;TCP&quot;);  </span><br><span class="line">  if (!want_cookie)  </span><br><span class="line">   goto drop;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> //在全连接队列满的情况下，如果有 young_ack，那么直接丢  </span><br><span class="line"> if (sk_acceptq_is_full(sk) &amp;&amp; inet_csk_reqsk_queue_young(sk) &gt; 1) &#123;  </span><br><span class="line">  NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);  </span><br><span class="line">  goto drop;  </span><br><span class="line"> &#125;  </span><br><span class="line"> ...  </span><br><span class="line"> //分配 request_sock 内核对象  </span><br><span class="line"> req = inet_reqsk_alloc(&amp;tcp_request_sock_ops);  </span><br><span class="line">  </span><br><span class="line"> //构造 syn+ack 包  </span><br><span class="line"> skb_synack = tcp_make_synack(sk, dst, req,  </span><br><span class="line">  fastopen_cookie_present(&amp;valid_foc) ? &amp;valid_foc : NULL);  </span><br><span class="line">  </span><br><span class="line"> if (likely(!do_fastopen)) &#123;  </span><br><span class="line">  //发送 syn + ack 响应  </span><br><span class="line">  err = ip_build_and_send_pkt(skb_synack, sk, ireq-&gt;loc_addr,  </span><br><span class="line">    ireq-&gt;rmt_addr, ireq-&gt;opt);  </span><br><span class="line">  </span><br><span class="line">  //添加到半连接队列，并开启计时器  </span><br><span class="line">  inet_csk_reqsk_queue_hash_add(sk, req, TCP_TIMEOUT_INIT);  </span><br><span class="line"> &#125;else ...  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这里首先判断半连接队列是否满了，如果满了的话进入 tcp_syn_flood_action 去判断是否开启了 tcp_syncookies 内核参数。<strong>如果队列满，且未开启 tcp_syncookies，那么该握手包将直接被丢弃！！</strong></p>
<p>接着还要判断全连接队列是否满。因为全连接队列满也会导致握手异常的，那干脆就在第一次握手的时候也判断了。<strong>如果全连接队列满了，且有 young_ack 的话，那么同样也是直接丢弃。</strong></p>
<blockquote>
<p>young_ack 是半连接队列里保持着的一个计数器。记录的是刚有 SYN 到达，没有被 SYN_ACK 重传定时器重传过 SYN_ACK，同时也没有完成过三次握手的 sock 数量</p>
</blockquote>
<p>接下来是构造 synack 包，然后通过 ip_build_and_send_pkt 把它发送出去。</p>
<p>最后把当前握手信息添加到半连接队列，并开启计时器。计时器的作用是如果某个时间之内还收不到客户端的第三次握手的话，服务器会重传 synack 包。</p>
<p><strong>总结一下，服务器响应 ack 是主要工作是判断下接收队列是否满了，满的话可能会丢弃该请求，否则发出 synack。申请 request_sock 添加到半连接队列中，同时启动定时器</strong>。</p>
<h3 id="四、客户端响应-SYNACK"><a href="#四、客户端响应-SYNACK" class="headerlink" title="四、客户端响应 SYNACK"></a>四、客户端响应 SYNACK</h3><p>客户端收到服务器端发来的 synack 包的时候，也会进入到 tcp_rcv_state_process 函数中来。不过由于自身 socket 的状态是 TCP_SYN_SENT，所以会进入到另一个不同的分支中去。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//file:net/ipv4/tcp_input.c  </span><br><span class="line">//除了 ESTABLISHED 和 TIME_WAIT，其他状态下的 TCP 处理都走这里  </span><br><span class="line">int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb,  </span><br><span class="line">     const struct tcphdr *th, unsigned int len)  </span><br><span class="line">&#123;  </span><br><span class="line"> switch (sk-&gt;sk_state) &#123;  </span><br><span class="line">  //服务器收到第一个ACK包  </span><br><span class="line">  case TCP_LISTEN:  </span><br><span class="line">   ...  </span><br><span class="line">  //客户端第二次握手处理  </span><br><span class="line">  case TCP_SYN_SENT:  </span><br><span class="line">   //处理 synack 包  </span><br><span class="line">   queued = tcp_rcv_synsent_state_process(sk, skb, th, len);  </span><br><span class="line">   ...  </span><br><span class="line">   return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>tcp_rcv_synsent_state_process 是客户端响应 synack 的主要逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//file:net/ipv4/tcp_input.c  </span><br><span class="line">static int tcp_rcv_synsent_state_process(struct sock *sk, struct sk_buff *skb,  </span><br><span class="line">      const struct tcphdr *th, unsigned int len)  </span><br><span class="line">&#123;  </span><br><span class="line"> ...  </span><br><span class="line">  </span><br><span class="line"> tcp_ack(sk, skb, FLAG_SLOWPATH);  </span><br><span class="line">  </span><br><span class="line"> //连接建立完成  </span><br><span class="line"> tcp_finish_connect(sk, skb);  </span><br><span class="line">  </span><br><span class="line"> if (sk-&gt;sk_write_pending ||  </span><br><span class="line">   icsk-&gt;icsk_accept_queue.rskq_defer_accept ||  </span><br><span class="line">   icsk-&gt;icsk_ack.pingpong)  </span><br><span class="line">  //延迟确认...  </span><br><span class="line"> else &#123;  </span><br><span class="line">  tcp_send_ack(sk);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>tcp_ack()-&gt;tcp_clean_rtx_queue()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//file: net/ipv4/tcp_input.c  </span><br><span class="line">static int tcp_clean_rtx_queue(struct sock *sk, int prior_fackets,  </span><br><span class="line">       u32 prior_snd_una)  </span><br><span class="line">&#123;  </span><br><span class="line"> //删除发送队列  </span><br><span class="line"> ...  </span><br><span class="line">  </span><br><span class="line"> //删除定时器  </span><br><span class="line"> tcp_rearm_rto(sk);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//file: net/ipv4/tcp_input.c  </span><br><span class="line">void tcp_finish_connect(struct sock *sk, struct sk_buff *skb)  </span><br><span class="line">&#123;  </span><br><span class="line"> //修改 socket 状态  </span><br><span class="line"> tcp_set_state(sk, TCP_ESTABLISHED);  </span><br><span class="line">  </span><br><span class="line"> //初始化拥塞控制  </span><br><span class="line"> tcp_init_congestion_control(sk);  </span><br><span class="line"> ...  </span><br><span class="line">  </span><br><span class="line"> //保活计时器打开  </span><br><span class="line"> if (sock_flag(sk, SOCK_KEEPOPEN))  </span><br><span class="line">  inet_csk_reset_keepalive_timer(sk, keepalive_time_when(tp));  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端修改自己的 socket 状态为 ESTABLISHED，接着打开 TCP 的保活计时器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//file:net/ipv4/tcp_output.c  </span><br><span class="line">void tcp_send_ack(struct sock *sk)  </span><br><span class="line">&#123;  </span><br><span class="line"> //申请和构造 ack 包  </span><br><span class="line"> buff = alloc_skb(MAX_TCP_HEADER, sk_gfp_atomic(sk, GFP_ATOMIC));  </span><br><span class="line"> ...  </span><br><span class="line">  </span><br><span class="line"> //发送出去  </span><br><span class="line"> tcp_transmit_skb(sk, buff, 0, sk_gfp_atomic(sk, GFP_ATOMIC));  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 tcp_send_ack 中构造 ack 包，并把它发送了出去。</p>
<p><strong>客户端响应来自服务器端的 synack 时清除了 connect 时设置的重传定时器，把当前 socket 状态设置为 ESTABLISHED，开启保活计时器后发出第三次握手的 ack 确认。</strong></p>
<h3 id="五、服务器响应-ACK"><a href="#五、服务器响应-ACK" class="headerlink" title="五、服务器响应 ACK"></a>五、服务器响应 ACK</h3><p>服务器响应第三次握手的 ack 时同样会进入到 tcp_v4_do_rcv</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//file: net/ipv4/tcp_ipv4.c  </span><br><span class="line">int tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb)  </span><br><span class="line">&#123;  </span><br><span class="line"> ...  </span><br><span class="line"> if (sk-&gt;sk_state == TCP_LISTEN) &#123;  </span><br><span class="line">  struct sock *nsk = tcp_v4_hnd_req(sk, skb);  </span><br><span class="line">  </span><br><span class="line">  if (nsk != sk) &#123;  </span><br><span class="line">   if (tcp_child_process(sk, nsk, skb)) &#123;  </span><br><span class="line">    ...  </span><br><span class="line">   &#125;  </span><br><span class="line">   return 0;  </span><br><span class="line">  &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> ...  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不过由于这已经是第三次握手了，半连接队列里会存在上次第一次握手时留下的半连接信息。所以 tcp_v4_hnd_req 的执行逻辑会不太一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//file:net/ipv4/tcp_ipv4.c  </span><br><span class="line">static struct sock *tcp_v4_hnd_req(struct sock *sk, struct sk_buff *skb)  </span><br><span class="line">&#123;  </span><br><span class="line"> ...  </span><br><span class="line"> struct request_sock *req = inet_csk_search_req(sk, &amp;prev, th-&gt;source,  </span><br><span class="line">          iph-&gt;saddr, iph-&gt;daddr);  </span><br><span class="line"> if (req)  </span><br><span class="line">  return tcp_check_req(sk, skb, req, prev, false);  </span><br><span class="line"> ...  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>inet_csk_search_req 负责在半连接队列里进行查找，找到以后返回一个半连接 request_sock 对象。然后进入到 tcp_check_req 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//file：net/ipv4/tcp_minisocks.c  </span><br><span class="line">struct sock *tcp_check_req(struct sock *sk, struct sk_buff *skb,  </span><br><span class="line">      struct request_sock *req,  </span><br><span class="line">      struct request_sock **prev,  </span><br><span class="line">      bool fastopen)  </span><br><span class="line">&#123;  </span><br><span class="line"> ...  </span><br><span class="line"> //创建子 socket  </span><br><span class="line"> child = inet_csk(sk)-&gt;icsk_af_ops-&gt;syn_recv_sock(sk, skb, req, NULL);  </span><br><span class="line"> ...  </span><br><span class="line">  </span><br><span class="line"> //清理半连接队列  </span><br><span class="line"> inet_csk_reqsk_queue_unlink(sk, req, prev);  </span><br><span class="line"> inet_csk_reqsk_queue_removed(sk, req);  </span><br><span class="line">  </span><br><span class="line"> //添加全连接队列  </span><br><span class="line"> inet_csk_reqsk_queue_add(sk, req, child);  </span><br><span class="line"> return child;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-1-创建子-socket"><a href="#5-1-创建子-socket" class="headerlink" title="5.1 创建子 socket"></a>5.1 创建子 socket</h4><p>icsk_af_ops-&gt;syn_recv_sock 对应的是 tcp_v4_syn_recv_sock 函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//file:net/ipv4/tcp_ipv4.c  </span><br><span class="line">const struct inet_connection_sock_af_ops ipv4_specific = &#123;  </span><br><span class="line"> ......  </span><br><span class="line"> .conn_request      = tcp_v4_conn_request,  </span><br><span class="line"> .syn_recv_sock     = tcp_v4_syn_recv_sock,  </span><br><span class="line">  </span><br><span class="line">//三次握手接近就算是完毕了，这里创建 sock 内核对象  </span><br><span class="line">struct sock *tcp_v4_syn_recv_sock(struct sock *sk, struct sk_buff *skb,  </span><br><span class="line">      struct request_sock *req,  </span><br><span class="line">      struct dst_entry *dst)  </span><br><span class="line">&#123;  </span><br><span class="line"> //判断接收队列是不是满了  </span><br><span class="line"> if (sk_acceptq_is_full(sk))  </span><br><span class="line">  goto exit_overflow;  </span><br><span class="line">  </span><br><span class="line"> //创建 sock &amp;&amp; 初始化  </span><br><span class="line"> newsk = tcp_create_openreq_child(sk, req, skb);  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意，在第三次握手的这里又继续判断一次全连接队列是否满了，如果满了修改一下计数器就丢弃了</strong>。如果队列不满，那么就申请创建新的 sock 对象。</p>
<h4 id="5-2-删除半连接队列"><a href="#5-2-删除半连接队列" class="headerlink" title="5.2 删除半连接队列"></a>5.2 删除半连接队列</h4><p>把连接请求块从半连接队列中删除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//file: include/net/inet_connection_sock.h  </span><br><span class="line">static inline void inet_csk_reqsk_queue_unlink(struct sock *sk, struct request_sock *req,  </span><br><span class="line"> struct request_sock **prev)  </span><br><span class="line">&#123;  </span><br><span class="line"> reqsk_queue_unlink(&amp;inet_csk(sk)-&gt;icsk_accept_queue, req, prev);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>reqsk_queue_unlink 中把连接请求块从半连接队列中删除。</p>
<h4 id="5-3-添加全连接队列"><a href="#5-3-添加全连接队列" class="headerlink" title="5.3 添加全连接队列"></a>5.3 添加全连接队列</h4><p>接着添加到全连接队列里边来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//file:net/ipv4/syncookies.c  </span><br><span class="line">static inline void inet_csk_reqsk_queue_add(struct sock *sk,  </span><br><span class="line">      struct request_sock *req,  </span><br><span class="line">      struct sock *child)  </span><br><span class="line">&#123;  </span><br><span class="line"> reqsk_queue_add(&amp;inet_csk(sk)-&gt;icsk_accept_queue, req, sk, child);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 reqsk_queue_add 中将握手成功的 request_sock 对象插入到全连接队列链表的尾部。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//file: include/net/request_sock.h  </span><br><span class="line">static inline void reqsk_queue_add(...)  </span><br><span class="line">&#123;  </span><br><span class="line"> req-&gt;sk = child;  </span><br><span class="line"> sk_acceptq_added(parent);  </span><br><span class="line">  </span><br><span class="line"> if (queue-&gt;rskq_accept_head == NULL)  </span><br><span class="line">  queue-&gt;rskq_accept_head = req;  </span><br><span class="line"> else  </span><br><span class="line">  queue-&gt;rskq_accept_tail-&gt;dl_next = req;  </span><br><span class="line">  </span><br><span class="line"> queue-&gt;rskq_accept_tail = req;  </span><br><span class="line"> req-&gt;dl_next = NULL;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-4-设置连接为-ESTABLISHED"><a href="#5-4-设置连接为-ESTABLISHED" class="headerlink" title="5.4 设置连接为 ESTABLISHED"></a>5.4 设置连接为 ESTABLISHED</h4><p>tcp_v4_do_rcv =&gt; tcp_child_process =&gt; tcp_rcv_state_process</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//file:net/ipv4/tcp_input.c  </span><br><span class="line">int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb,  </span><br><span class="line">     const struct tcphdr *th, unsigned int len)  </span><br><span class="line">&#123;  </span><br><span class="line"> ...  </span><br><span class="line"> switch (sk-&gt;sk_state) &#123;  </span><br><span class="line">  </span><br><span class="line">  //服务端第三次握手处理  </span><br><span class="line">  case TCP_SYN_RECV:  </span><br><span class="line">  </span><br><span class="line">   //改变状态为连接  </span><br><span class="line">   tcp_set_state(sk, TCP_ESTABLISHED);  </span><br><span class="line">   ...  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将连接设置为 TCP_ESTABLISHED 状态。</p>
<p><strong>服务器响应第三次握手 ack 所做的工作是把当前半连接对象删除，创建了新的 sock 后加入到全连接队列中，最后将新连接状态设置为 ESTABLISHED</strong>。</p>
<h3 id="六、服务器-accept"><a href="#六、服务器-accept" class="headerlink" title="六、服务器 accept"></a>六、服务器 accept</h3><p>最后 accept 一步咱们长话短说。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//file: net/ipv4/inet_connection_sock.c  </span><br><span class="line">struct sock *inet_csk_accept(struct sock *sk, int flags, int *err)  </span><br><span class="line">&#123;  </span><br><span class="line"> //从全连接队列中获取  </span><br><span class="line"> struct request_sock_queue *queue = &amp;icsk-&gt;icsk_accept_queue;  </span><br><span class="line"> req = reqsk_queue_remove(queue);  </span><br><span class="line">  </span><br><span class="line"> newsk = req-&gt;sk;  </span><br><span class="line"> return newsk;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>reqsk_queue_remove 这个操作很简单，就是从全连接队列的链表里获取出第一个元素返回就行了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//file:include/net/request_sock.h  </span><br><span class="line">static inline struct request_sock *reqsk_queue_remove(struct request_sock_queue *queue)  </span><br><span class="line">&#123;  </span><br><span class="line"> struct request_sock *req = queue-&gt;rskq_accept_head;  </span><br><span class="line">  </span><br><span class="line"> queue-&gt;rskq_accept_head = req-&gt;dl_next;  </span><br><span class="line"> if (queue-&gt;rskq_accept_head == NULL)  </span><br><span class="line">  queue-&gt;rskq_accept_tail = NULL;  </span><br><span class="line">  </span><br><span class="line"> return req;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>所以，accept 的重点工作就是从已经建立好的全连接队列中取出一个返回给用户进程。</strong></p>
<h3 id="本文总结"><a href="#本文总结" class="headerlink" title="本文总结"></a>本文总结</h3><p>在后端相关岗位的入职面试中，三次握手的出场频率非常的高。其实在三次握手的过程中，不仅仅是一个握手包的发送 和 TCP 状态的流转。还包含了端口选择，连接队列创建与处理等很多关键技术点。通过今天一篇文章，我们深度去了解了三次握手过程中内核中的这些内部操作。</p>
<p>全文洋洋洒洒上万字字，其实可以用一幅图总结起来。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/ec72c83155dbee068dc3471a2f000afe.png" alt=""></p>
<ul>
<li><p>服务器 listen 时，计算了全/半连接队列的长度，还申请了相关内存并初始化。</p>
</li>
<li><p>客户端 connect 时，把本地 socket 状态设置成了 TCP_SYN_SENT，选则一个可用的端口，发出 SYN 握手请求并启动重传定时器。</p>
</li>
<li><p>服务器响应 ack 时，会判断下接收队列是否满了，满的话可能会丢弃该请求。否则发出 synack，申请 request_sock 添加到半连接队列中，同时启动定时器。</p>
</li>
<li><p>客户端响应 synack 时，清除了 connect 时设置的重传定时器，把当前 socket 状态设置为 ESTABLISHED，开启保活计时器后发出第三次握手的 ack 确认。</p>
</li>
<li><p>服务器响应 ack 时，把对应半连接对象删除，创建了新的 sock 后加入到全连接队列中，最后将新连接状态设置为 ESTABLISHED。</p>
</li>
<li><p>accept 从已经建立好的全连接队列中取出一个返回给用户进程。</p>
</li>
</ul>
<p>另外要注意的是，如果握手过程中发生丢包（网络问题，或者是连接队列溢出），内核会等待定时器到期后重试，重试时间间隔在 3.10 版本里分别是 1s 2s 4s …。在一些老版本里，比如 2.6 里，第一次重试时间是 3 秒。最大重试次数分别由 tcp_syn_retries 和 tcp_synack_retries 控制。</p>
<p>如果你的线上接口正常都是几十毫秒内返回，但偶尔出现了 1 s、或者 3 s 等这种偶发的响应耗时变长的问题，那么你就要去定位一下看看是不是出现了握手包的超时重传了。</p>
<p>以上就是三次握手中一些更详细的内部操作。深度理解这个握手过程对于你排查线上问题会有极大的帮助的。</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/G2LuRZjQE15F6fSU-Bv_jw">https://mp.weixin.qq.com/s/G2LuRZjQE15F6fSU-Bv_jw</a>，如有侵权，请联系删除。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">yanfeizhang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/G2LuRZjQE15F6fSU-Bv_jw">https://mp.weixin.qq.com/s/G2LuRZjQE15F6fSU-Bv_jw</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.lemongo97.com" target="_blank">LemonGo97のBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/tcp/">tcp</a></div><div class="post_share"><div class="social-share" data-image="https://image.lemongo97.com/default_cover_1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/8671c4ed/"><img class="prev-cover" data-lazy-src="https://image.lemongo97.com/default_cover_1.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">深入理解完美哈希</div></div></a></div><div class="next-post pull-right"><a href="/posts/ad0e1ee3/"><img class="next-cover" data-lazy-src="https://image.lemongo97.com/all_default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">分布式唯一 ID 生成方案浅谈</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By LemonGo97</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/instant.page/5.1.0/instantpage.min.js" type="module" defer></script><script src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.3.1/lazyload.iife.min.js" async></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'w7vT5VedMPyGHyDYppcacmtw-gzGzoHsz',
      appKey: 'YxBl09Aj50g5Ld621aydI4pz',
      placeholder: '来和大家一起讨论吧！',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div></div></body></html>