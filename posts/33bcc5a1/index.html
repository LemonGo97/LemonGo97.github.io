<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>更优雅的使用Gson解析Json | LemonGo97のBlog</title><meta name="description" content="转载自掘金：沈剑心 原文地址：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7355800792073469992 著作权归原作者所有 如果这篇文件对大家有帮助，请给原作者点个 Star⭐  Gson背靠Google这棵大树，拥有广泛的社区支持和相对丰富的文档资源，同时因其简单直观的API，一直以来基本稳坐Android开发序列化的头把交椅（直到Google宣布kotlin成为Android开发"><meta name="keywords" content="Java,JSON"><meta name="author" content="LemonGo97"><meta name="copyright" content="LemonGo97"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.lemongo97.com/posts/33bcc5a1/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><meta property="og:type" content="article"><meta property="og:title" content="更优雅的使用Gson解析Json"><meta property="og:url" content="https://blog.lemongo97.com/posts/33bcc5a1/"><meta property="og:site_name" content="LemonGo97のBlog"><meta property="og:description" content="转载自掘金：沈剑心 原文地址：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7355800792073469992 著作权归原作者所有 如果这篇文件对大家有帮助，请给原作者点个 Star⭐  Gson背靠Google这棵大树，拥有广泛的社区支持和相对丰富的文档资源，同时因其简单直观的API，一直以来基本稳坐Android开发序列化的头把交椅（直到Google宣布kotlin成为Android开发"><meta property="og:image" content="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/all_default.jpg"><meta property="article:published_time" content="2024-04-22T07:58:16.000Z"><meta property="article:modified_time" content="2024-04-22T07:58:16.000Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.1.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2024-04-22 15:58:16'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="LemonGo97のBlog" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="https://coding-net-production-static-ci.codehub.cn/d70d0fa9-08d5-4fc7-ba82-7b73fee22292.jpg?imageMogr2/auto-orient/format/jpeg/cut/700x700x0x0" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">63</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">39</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Gson%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">Gson的基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEGson"><span class="toc-number">1.1.</span> <span class="toc-text">配置Gson</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gson%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.2.</span> <span class="toc-text">Gson中的注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%A3%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">自定义解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JsonSerializer-%E5%92%8C-JsonDeserializer"><span class="toc-number">1.3.1.</span> <span class="toc-text">JsonSerializer 和 JsonDeserializer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TypeAdapter"><span class="toc-number">1.3.2.</span> <span class="toc-text">TypeAdapter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TypeAdapter-%E5%92%8C-JsonSerializer-JsonDeserializer-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.3.</span> <span class="toc-text">TypeAdapter 和 JsonSerializer&#x2F;JsonDeserializer 的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Gson%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E8%A7%A3%E6%9E%90%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">Gson是如何进行解析工作的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E5%90%88%E9%80%82%E7%9A%84%E7%B1%BB%E5%9E%8B%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">找到合适的类型适配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gson%E8%A7%A3%E6%9E%90%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">Gson解析基础数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gson%E8%A7%A3%E6%9E%90map%E5%92%8C%E9%9B%86%E5%90%88"><span class="toc-number">2.3.</span> <span class="toc-text">Gson解析map和集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gson%E8%A7%A3%E6%9E%90%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.</span> <span class="toc-text">Gson解析枚举类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gson%E8%A7%A3%E6%9E%90Java-Bean"><span class="toc-number">2.5.</span> <span class="toc-text">Gson解析Java Bean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gson%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">Gson如何创建对象？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Gson%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E2%9A%A0"><span class="toc-number">3.</span> <span class="toc-text">使用Gson需要注意⚠</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8Gson%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88"><span class="toc-number">4.</span> <span class="toc-text">关于更优雅的使用Gson的一些经验之谈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%85%8D%E7%BD%AEGson"><span class="toc-number">4.1.</span> <span class="toc-text">正确的配置Gson</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8Fnull%E5%80%BC"><span class="toc-number">4.1.1.</span> <span class="toc-text">注意null值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99%E7%9A%84%E6%9E%9A%E4%B8%BE%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">4.1.2.</span> <span class="toc-text">不区分大小写的枚举反序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E7%90%86%E8%AE%BE%E7%BD%AEFieldNamingPolicy"><span class="toc-number">4.1.3.</span> <span class="toc-text">合理设置FieldNamingPolicy</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E7%90%86%E5%AE%9A%E4%B9%89%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">合理定义字段类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A7%E7%94%A8TypeAdapter"><span class="toc-number">4.3.</span> <span class="toc-text">巧用TypeAdapter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E8%87%AA%E8%BA%AB%E4%BA%A7%E5%93%81%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%94%E5%9B%9E%E5%AD%97%E6%AE%B5%E7%9A%84%E8%A7%84%E8%8C%83%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8TypeAdapter"><span class="toc-number">4.3.1.</span> <span class="toc-text">结合自身产品服务端返回字段的规范合理使用TypeAdapter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E5%B9%B3%E5%8F%B0%E7%89%B9%E6%80%A7%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8TypeAdapter"><span class="toc-number">4.3.2.</span> <span class="toc-text">结合平台特性合理使用TypeAdapter</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/all_default.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">LemonGo97のBlog</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">【转载】 更优雅的使用Gson解析Json</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-22T07:58:16.000Z" title="发表于 2024-04-22 15:58:16">2024-04-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-22T07:58:16.000Z" title="更新于 2024-04-22 15:58:16">2024-04-22</time></span></div><div class="meta-secondline"> </div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><blockquote>
<p>转载自掘金：<a target="_blank" rel="noopener" href="https://juejin.cn/user/4019470242156759">沈剑心</a></p>
<p>原文地址：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7355800792073469992">https://juejin.cn/post/7355800792073469992</a></p>
<p>著作权归原作者所有</p>
<p>如果这篇文件对大家有帮助，请给原作者点个 Star⭐</p>
</blockquote>
<p><code>Gson</code>背靠Google这棵大树，拥有广泛的社区支持和相对丰富的文档资源，同时因其简单直观的API，一直以来基本稳坐Android开发序列化的头把交椅（直到Google宣布kotlin成为Android开发的首选语言）。本文对Gson的使用及主要流程做下分析。</p>
<h2 id="Gson的基本使用"><a href="#Gson的基本使用" class="headerlink" title="Gson的基本使用"></a>Gson的基本使用</h2><p><code>Gson依赖</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  implementation &#x27;com.google.code.gson:gson:2.10.1&#x27;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>下文的Gson源码同样基于<code>v2.10.1</code>版本</p>
</blockquote>
<h3 id="配置Gson"><a href="#配置Gson" class="headerlink" title="配置Gson"></a>配置Gson</h3><p>Gson类是整个Gson类库的核心类。开发者只需要通过调用<code>new Gson()</code>即可获取到gson实例，但我建议你通过<code>GsonBuilder</code>来创建并配置Gson类的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private val gson = GsonBuilder()</span><br><span class="line">        // 为特定类型注册自定义的序列化器或反序列化器（不支持协变）</span><br><span class="line">        .registerTypeAdapter(Boolean::class.java, BooleanTypeAdapter())</span><br><span class="line">        // 为特定类型注册自定义的序列化器或反序列化器（支持协变）</span><br><span class="line">        .registerTypeHierarchyAdapter(xxxx)</span><br><span class="line">        // 注册一个能够为多种类型提供适配器的工厂</span><br><span class="line">        .registerTypeAdapterFactory(xxxx)</span><br><span class="line">        // 设置长整型（Long）字段的序列化策略，例如将其序列化为字符串而不是数字</span><br><span class="line">        .setLongSerializationPolicy(LongSerializationPolicy.STRING)</span><br><span class="line">        // 自定义日期/时间字段的序列化格式</span><br><span class="line">        .setDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;)</span><br><span class="line">        // 设置字段命名策略，以控制字段如何映射到JSON键名（默认不改变命名风格）</span><br><span class="line">        .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)</span><br><span class="line">        // 设置自定义的字段命名策略，用于控制字段如何映射到JSON键名</span><br><span class="line">        .setFieldNamingStrategy(xxxx)</span><br><span class="line">        // 排除具有特定Java修饰符（默认 transient 和 static）的字段</span><br><span class="line">        .excludeFieldsWithModifiers(java.lang.reflect.Modifier.TRANSIENT or java.lang.reflect.Modifier.STATIC)</span><br><span class="line">        // 设置只序列化和反序列化带有@Expose注解的字段</span><br><span class="line">        .excludeFieldsWithoutExposeAnnotation()</span><br><span class="line">        // 设置类或字段过滤规则</span><br><span class="line">        .setExclusionStrategies(xxxx)</span><br><span class="line">        // 设置过滤规则（只适用于序列化）</span><br><span class="line">        .addSerializationExclusionStrategy(xxxx)</span><br><span class="line">        // 设置过滤规则（只适用于反序列化）</span><br><span class="line">        .addDeserializationExclusionStrategy(xxxx)</span><br><span class="line">        // 设置版本号，Gson将忽略所有高于此版本号的@Since注解和@Until注解的字段</span><br><span class="line">        .setVersion(1.0)</span><br><span class="line">        // 启用非基础类型 Map Key</span><br><span class="line">        .enableComplexMapKeySerialization()</span><br><span class="line">        // 默认情况下，Gson在序列化时会忽略值为null的字段。启用该设置后，Gson将包括值为null的字段</span><br><span class="line">        .serializeNulls()</span><br><span class="line">        // Gson将以更易读的格式输出JSON字符串，即格式化后的JSON，其中包含换行符和缩进。</span><br><span class="line">        .setPrettyPrinting()</span><br><span class="line">        .create() </span><br></pre></td></tr></table></figure>

<p>Gson实例在调用JSON进行序列化/反序列化操作的过程中不维护任何状态，不同的Gson实例的配置和缓存等也不会复用，我们可以自由地使用同一个Gson实例对多个JSON进行序列化/反序列化操作。因此，我们应该在项目中提供一个全局的Gson实例，避免创建冗余的Gson实例。</p>
<blockquote>
<p>这些设置提供了强大的定制能力，使得Gson能够适应各种不同的序列化和反序列化需求。通过链式调用这些方法，开发者可以轻松地构建出满足特定需求的Gson实例。</p>
</blockquote>
<p>完成以上配置，你就可以在项目中愉快的使用Gson完成序列化/反序列化工作了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Serialization</span><br><span class="line">Gson gson = new Gson();</span><br><span class="line">gson.toJson(1);            // ==&gt; 1</span><br><span class="line">gson.toJson(&quot;abcd&quot;);       // ==&gt; &quot;abcd&quot;</span><br><span class="line">gson.toJson(new Long(10)); // ==&gt; 10</span><br><span class="line">int[] values = &#123; 1 &#125;;</span><br><span class="line">gson.toJson(values);       // ==&gt; [1]</span><br><span class="line"></span><br><span class="line">// Deserialization</span><br><span class="line">int i = gson.fromJson(&quot;1&quot;, int.class);</span><br><span class="line">Integer intObj = gson.fromJson(&quot;1&quot;, Integer.class);</span><br><span class="line">Long longObj = gson.fromJson(&quot;1&quot;, Long.class);</span><br><span class="line">Boolean boolObj = gson.fromJson(&quot;false&quot;, Boolean.class);</span><br><span class="line">String str = gson.fromJson(&quot;\&quot;abc\&quot;&quot;, String.class);</span><br><span class="line">String[] strArray = gson.fromJson(&quot;[\&quot;abc\&quot;]&quot;, String[].class); </span><br></pre></td></tr></table></figure>

<h3 id="Gson中的注解"><a href="#Gson中的注解" class="headerlink" title="Gson中的注解"></a>Gson中的注解</h3><p>Gson库提供了一些注解，通过这些注解可以更加灵活地控制Java对象到JSON字符串的序列化和反序列化过程。</p>
<ul>
<li><strong>@SerializedName</strong>：指定一个字段在JSON中的名称。常用于Java字段名和JSON键名不一致的情况。</li>
<li><strong>@Expose</strong>：标记一个字段是否应该被序列化或反序列化。它用于在序列化/反序列化过程中包含或排除字段。</li>
<li><strong>@Since</strong>：指定一个字段自某个版本号之后才被序列化或反序列化。这允许版本控制，可以用于向后兼容。</li>
<li><strong>@Until</strong>：指定一个字段在某个版本号之前被序列化或反序列化。它与@Since注解相反，用于版本控制和向后兼容。</li>
<li><strong>@JsonAdapter</strong>：指定一个字段使用自定义的序列化器和反序列化器。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">data class User(</span><br><span class="line">	// username字段在序列化/反序列化时会使用name作为键名</span><br><span class="line">    @SerializedName(&quot;name&quot;)</span><br><span class="line">    val username: String,</span><br><span class="line">	// 标记password不参与序列化/反序列化</span><br><span class="line">    @Expose</span><br><span class="line">    val password: String,</span><br><span class="line">	// phoneNumber字段只有在版本号为1.1或更高时才会参与序列化/反序列化</span><br><span class="line">    @Since(1.1)</span><br><span class="line">    val phoneNumber: String,</span><br><span class="line">	// email字段只有在版本号低于1.2时才会参与序列化/反序列化</span><br><span class="line">    @Until(1.2)</span><br><span class="line">    val email: String,</span><br><span class="line">	// 使用自定义的GenderAdapter解析器序列化/反序列化gender字段</span><br><span class="line">    @JsonAdapter(GenderAdapter::class)</span><br><span class="line">    val gender: Gender,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">enum class Gender &#123;</span><br><span class="line">    MALE,</span><br><span class="line">    FEMALE,</span><br><span class="line">    UNKNOWN,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class GenderAdapter: TypeAdapter&lt;Gender&gt;() &#123;</span><br><span class="line">    override fun write(out: JsonWriter, value: Gender) &#123;</span><br><span class="line">        when (value) &#123;</span><br><span class="line">            Gender.UNKNOWN -&gt; out.nullValue()</span><br><span class="line">            Gender.MALE -&gt; out.value(&quot;1&quot;)</span><br><span class="line">            Gender.FEMALE -&gt; out.value(&quot;2&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    override fun read(`in`: JsonReader): Gender &#123;</span><br><span class="line">        return when (`in`.peek()) &#123;</span><br><span class="line">            JsonToken.NULL -&gt; &#123;</span><br><span class="line">                `in`.nextNull()</span><br><span class="line">                Gender.UNKNOWN</span><br><span class="line">            &#125;</span><br><span class="line">            JsonToken.NUMBER -&gt; &#123;</span><br><span class="line">                when(`in`.nextInt()) &#123;</span><br><span class="line">                    1 -&gt; Gender.MALE</span><br><span class="line">                    2 -&gt; Gender.FEMALE</span><br><span class="line">                    else -&gt; Gender.UNKNOWN</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else -&gt; Gender.UNKNOWN</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="自定义解析"><a href="#自定义解析" class="headerlink" title="自定义解析"></a>自定义解析</h3><p>对于序列化/反序列化，Gson提供了三个关键接口：<code>JsonSerializer</code>、<code>JsonDeserializer</code>以及<code>TypeAdapter</code>，他们提供了不同级别的控制和灵活性。</p>
<h4 id="JsonSerializer-和-JsonDeserializer"><a href="#JsonSerializer-和-JsonDeserializer" class="headerlink" title="JsonSerializer 和 JsonDeserializer"></a>JsonSerializer 和 JsonDeserializer</h4><p><code>JsonSerializer</code>和<code>JsonDeserializer</code>是<code>Gson</code>在<code>1.x版本</code>提供的用以自定义解析的两个接口，从名字也能明显看出来，<code>JsonSerializer</code>负责自定义序列化工作，而<code>JsonDeserializer</code>负责反序列化。</p>
<ul>
<li><strong>JsonSerializer</strong> 定义如何将类型T的对象转换成JSON。它只有一个方法serialize(T src, Type typeOfSrc, JsonSerializationContext context)，返回一个JsonElement对象。</li>
<li><strong>JsonDeserializer</strong> 定义如何将JSON转换回类型T的对象。它只有一个方法deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)，返回一个类型为T的对象。</li>
</ul>
<p>可以看到，不管是 JsonSerializer 还是 JsonDeserializer，都依赖 <code>JsonElement</code> 类进行序列化/反序列化工作。 <code>JsonElement</code>类是Gson中用以表示Json元素的抽象类，他有4个实现类：<code>JsonObject</code>、<code>JsonArray</code>、<code>JsonPrimitive</code>和<code>JsonNull</code>，分别对应表示Json中可能出现的所有类型：Json对象、数组、原始数据类型和空值。</p>
<ul>
<li>JsonObject: 表示JSON对象，即一组键值对，其中键是字符串，值可以是任意类型的JsonElement。JsonObject提供了添加、删除和访问这些键值对的方法。</li>
<li>JsonArray: 表示JSON数组，即一个元素列表，这些元素本身可以是任意类型的JsonElement。JsonArray提供了添加、删除和访问这些元素的方法。</li>
<li>JsonPrimitive: 表示JSON的原始数据类型，如字符串、数字、布尔值等。JsonPrimitive封装了这些基本类型的值。</li>
<li>JsonNull: 表示JSON的空值。在Gson中，JsonNull是单例，用于表示值为null的情况。</li>
</ul>
<p>通过操作JsonElement及其子类的实例，开发者可以灵活的构造、遍历和操作JSON数据结构。</p>
<h4 id="TypeAdapter"><a href="#TypeAdapter" class="headerlink" title="TypeAdapter"></a>TypeAdapter</h4><p><code>TypeAdapter</code>是Gson 从<code>2.1</code>版本后提供的、用来同时处理序列化和反序列化的接口。与<code>JsonSerializer</code>和<code>JsonDeserializer</code>不同的是，TypeAdapter提供了一个单一的实现点，通过两个方法<code>write(JsonWriter out, T value)</code>和<code>read(JsonReader in)</code>来分别处理序列化和反序列化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class GenderAdapter: TypeAdapter&lt;Gender&gt;() &#123;</span><br><span class="line">	// 自定义序列化过程：</span><br><span class="line">	// Gender.UNKNOWN -&gt; null</span><br><span class="line">	// Gender.MALE -&gt; &quot;1&quot;</span><br><span class="line">	// Gender.FEMALE -&gt; &quot;2&quot;</span><br><span class="line">    override fun write(out: JsonWriter, value: Gender) &#123;</span><br><span class="line">        when (value) &#123;</span><br><span class="line">            Gender.UNKNOWN -&gt; out.nullValue()</span><br><span class="line">            Gender.MALE -&gt; out.value(&quot;1&quot;)</span><br><span class="line">            Gender.FEMALE -&gt; out.value(&quot;2&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	// 自定义反序列化过程：</span><br><span class="line">	// null -&gt; Gender.UNKNOWN</span><br><span class="line">	// &quot;1&quot; -&gt; Gender.MALE</span><br><span class="line">	// &quot;2&quot; -&gt; Gender.FEMALE</span><br><span class="line">    override fun read(`in`: JsonReader): Gender &#123;</span><br><span class="line">        return when (`in`.peek()) &#123;</span><br><span class="line">            JsonToken.NULL -&gt; &#123;</span><br><span class="line">                `in`.nextNull()</span><br><span class="line">                Gender.UNKNOWN</span><br><span class="line">            &#125;</span><br><span class="line">            JsonToken.NUMBER -&gt; &#123;</span><br><span class="line">                when(`in`.nextInt()) &#123;</span><br><span class="line">                    1 -&gt; Gender.MALE</span><br><span class="line">                    2 -&gt; Gender.FEMALE</span><br><span class="line">                    else -&gt; Gender.UNKNOWN</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else -&gt; Gender.UNKNOWN</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>TypeAdapter提供了更高的灵活性和控制力，因为它直接操作JsonReader和JsonWriter，这使得它可以更高效地处理JSON，避免了中间JsonElement的创建和解析。这在处理大量数据或需要高性能序列化/反序列化时特别有用。</p>
<h4 id="TypeAdapter-和-JsonSerializer-JsonDeserializer-的区别"><a href="#TypeAdapter-和-JsonSerializer-JsonDeserializer-的区别" class="headerlink" title="TypeAdapter 和 JsonSerializer/JsonDeserializer 的区别"></a>TypeAdapter 和 JsonSerializer/JsonDeserializer 的区别</h4><p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/285d23b0d1b6fa9e74ce7920b381f9d3.webp" alt=""> 从上图<code>TypeAdapter</code>和<code>JsonSerializer/JsonDeserializer</code>工作流图可以明显看出来，<code>TypeAdapter</code>直接操作<code>JsonReader</code>和<code>JsonWriter</code>，相对于<code>JsonSerializer/JsonDeserializer</code>避免了中间<code>JsonElement</code>的创建和解析。</p>
<ul>
<li>使用场景: JsonSerializer和JsonDeserializer通常用于更简单的场景，当你只需要定制某个类型的序列化或反序列化行为时。TypeAdapter用于更复杂或性能敏感的场景，提供了完全控制序列化和反序列化过程的能力。</li>
<li>性能: TypeAdapter通常比JsonSerializer和JsonDeserializer更高效，因为它避免了中间JsonElement的创建和解析。</li>
<li>灵活性: TypeAdapter提供了对序列化和反序列化过程的完全控制，而JsonSerializer和JsonDeserializer则在某种程度上受限于Gson的序列化和反序列化框架。</li>
</ul>
<p>根据具体需求选择合适的接口是关键。对于大多数简单用途，使用<code>JsonSerializer</code>和<code>JsonDeserializer</code>可能就足够了。但对于需要细粒度控制或优化性能的场景，<code>TypeAdapter</code>将是更好的选择。</p>
<blockquote>
<p>事实上，Gson 2.x 版本 也会将JsonSerializer和JsonDeserializer转换成<code>TreeTypeAdapter</code></p>
</blockquote>
<h2 id="Gson是如何进行解析工作的？"><a href="#Gson是如何进行解析工作的？" class="headerlink" title="Gson是如何进行解析工作的？"></a>Gson是如何进行解析工作的？</h2><p>通过上面的基本使用，我们应该能清晰的感知到，<code>TypeAdapter</code>在Gson的解析工作中担任重要角色。在创建Gson实例时，Gson内置了许多TypeAdapter：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#com.google.gson.Gson#Gson()</span><br><span class="line">List&lt;TypeAdapterFactory&gt; factories = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 内置类型的适配器，不可覆盖</span><br><span class="line">factories.add(TypeAdapters.JSON_ELEMENT_FACTORY);</span><br><span class="line">factories.add(ObjectTypeAdapter.getFactory(objectToNumberStrategy));</span><br><span class="line"></span><br><span class="line">// 忽略的字段、类型适配器</span><br><span class="line">factories.add(excluder);</span><br><span class="line"></span><br><span class="line">// 用户自定义的适配器</span><br><span class="line">factories.addAll(factoriesToBeAdded);</span><br><span class="line"></span><br><span class="line">// 平台的基础类型适配器</span><br><span class="line">factories.add(TypeAdapters.STRING_FACTORY);</span><br><span class="line">factories.add(TypeAdapters.INTEGER_FACTORY);</span><br><span class="line">factories.add(TypeAdapters.BOOLEAN_FACTORY);</span><br><span class="line">factories.add(TypeAdapters.BYTE_FACTORY);</span><br><span class="line">factories.add(TypeAdapters.SHORT_FACTORY);</span><br><span class="line">TypeAdapter&lt;Number&gt; longAdapter = longAdapter(longSerializationPolicy);</span><br><span class="line">factories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));</span><br><span class="line">factories.add(TypeAdapters.newFactory(double.class, Double.class,</span><br><span class="line">										  doubleAdapter(serializeSpecialFloatingPointValues)));</span><br><span class="line">factories.add(TypeAdapters.newFactory(float.class, Float.class,</span><br><span class="line">										  floatAdapter(serializeSpecialFloatingPointValues)));</span><br><span class="line">factories.add(NumberTypeAdapter.getFactory(numberToNumberStrategy));</span><br><span class="line">factories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);</span><br><span class="line">factories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);</span><br><span class="line">factories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));</span><br><span class="line">factories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));</span><br><span class="line">factories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);</span><br><span class="line">factories.add(TypeAdapters.CHARACTER_FACTORY);</span><br><span class="line">factories.add(TypeAdapters.STRING_BUILDER_FACTORY);</span><br><span class="line">factories.add(TypeAdapters.STRING_BUFFER_FACTORY);</span><br><span class="line">factories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));</span><br><span class="line">factories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));</span><br><span class="line">factories.add(TypeAdapters.newFactory(LazilyParsedNumber.class, TypeAdapters.LAZILY_PARSED_NUMBER));</span><br><span class="line">factories.add(TypeAdapters.URL_FACTORY);</span><br><span class="line">factories.add(TypeAdapters.URI_FACTORY);</span><br><span class="line">factories.add(TypeAdapters.UUID_FACTORY);</span><br><span class="line">factories.add(TypeAdapters.CURRENCY_FACTORY);</span><br><span class="line">factories.add(TypeAdapters.LOCALE_FACTORY);</span><br><span class="line">factories.add(TypeAdapters.INET_ADDRESS_FACTORY);</span><br><span class="line">factories.add(TypeAdapters.BIT_SET_FACTORY);</span><br><span class="line">factories.add(DateTypeAdapter.FACTORY);</span><br><span class="line">factories.add(TypeAdapters.CALENDAR_FACTORY);</span><br><span class="line"></span><br><span class="line">if (SqlTypesSupport.SUPPORTS_SQL_TYPES) &#123;</span><br><span class="line">	factories.add(SqlTypesSupport.TIME_FACTORY);</span><br><span class="line">	factories.add(SqlTypesSupport.DATE_FACTORY);</span><br><span class="line">	factories.add(SqlTypesSupport.TIMESTAMP_FACTORY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factories.add(ArrayTypeAdapter.FACTORY);</span><br><span class="line">factories.add(TypeAdapters.CLASS_FACTORY);</span><br><span class="line"></span><br><span class="line">// map、集合类型适配器</span><br><span class="line">factories.add(new CollectionTypeAdapterFactory(constructorConstructor));</span><br><span class="line">factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));</span><br><span class="line">this.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);</span><br><span class="line">factories.add(jsonAdapterFactory);</span><br><span class="line">factories.add(TypeAdapters.ENUM_FACTORY);</span><br><span class="line">// JavaBean类型适配器</span><br><span class="line">factories.add(new ReflectiveTypeAdapterFactory(</span><br><span class="line">	constructorConstructor, fieldNamingStrategy, excluder, jsonAdapterFactory, reflectionFilters)); </span><br></pre></td></tr></table></figure>

<p>抛开用户自定义的适配器不谈，剩下的适配器我们将其大致分为三类：</p>
<ul>
<li>基础数据类型适配器</li>
<li>map、集合等容器类型适配器</li>
<li>枚举类型适配器</li>
<li>JavaBean类型适配器</li>
</ul>
<p>对应Gson解析工作的三种情况，Gson是如何解析基础数据类型的、Gson是如何解析map、集合容器类型的、Gson时如何解析枚举类型的、Gson是如何解析JavaBean类型的。我们一个一个来看。</p>
<h3 id="找到合适的类型适配器"><a href="#找到合适的类型适配器" class="headerlink" title="找到合适的类型适配器"></a>找到合适的类型适配器</h3><p>Gson进行解析操作的关键就是找到合适的类型适配器，代码在Gson.getAdapter中，源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#Gson.getAdapter()</span><br><span class="line">public &lt;T&gt; TypeAdapter&lt;T&gt; getAdapter(TypeToken&lt;T&gt; type) &#123;</span><br><span class="line">	// 1.检查传入的TypeToken参数是否为null，若为null则抛出异常。</span><br><span class="line">	Objects.requireNonNull(type, &quot;type must not be null&quot;);</span><br><span class="line">	// 2.从类型缓存typeTokenCache中尝试获取该类型的适配器，如果缓存中存在，则直接返回。</span><br><span class="line">	TypeAdapter&lt;?&gt; cached = typeTokenCache.get(type);</span><br><span class="line">	if (cached != null) &#123;</span><br><span class="line">		@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">		TypeAdapter&lt;T&gt; adapter = (TypeAdapter&lt;T&gt;) cached;</span><br><span class="line">		return adapter;</span><br><span class="line">	&#125;</span><br><span class="line">	// 3.从线程本地缓存threadLocalAdapterResults中获取当前线程的适配器请求记录，如果不存在则创建一个新的HashMap，并将其设置到线程本地缓存中。</span><br><span class="line">	Map&lt;TypeToken&lt;?&gt;, TypeAdapter&lt;?&gt;&gt; threadCalls = threadLocalAdapterResults.get();</span><br><span class="line">	boolean isInitialAdapterRequest = false;</span><br><span class="line">	if (threadCalls == null) &#123;</span><br><span class="line">		threadCalls = new HashMap&lt;&gt;();</span><br><span class="line">		threadLocalAdapterResults.set(threadCalls);</span><br><span class="line">		isInitialAdapterRequest = true;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		// 在线程本地缓存中查找当前类型是否有适配器，如果存在则直接返回该适配器。</span><br><span class="line">		@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">		TypeAdapter&lt;T&gt; ongoingCall = (TypeAdapter&lt;T&gt;) threadCalls.get(type);</span><br><span class="line">		if (ongoingCall != null) &#123;</span><br><span class="line">			return ongoingCall;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TypeAdapter&lt;T&gt; candidate = null;</span><br><span class="line">	try &#123;</span><br><span class="line">		// 4.创建一个FutureTypeAdapter对象，并将其设置为当前类型的适配器请求记录，存入threadLocalAdapterResults</span><br><span class="line">		FutureTypeAdapter&lt;T&gt; call = new FutureTypeAdapter&lt;&gt;();</span><br><span class="line">		threadCalls.put(type, call);</span><br><span class="line"></span><br><span class="line">		for (TypeAdapterFactory factory : factories) &#123;</span><br><span class="line">			// 5.遍历TypeAdapterFactory工厂，尝试为当前类型创建适配器，若成功创建，则将该适配器设置给FutureTypeAdapter对象，并替换线程本地缓存中的适配器请求记录。</span><br><span class="line">			candidate = factory.create(this, type);</span><br><span class="line">			if (candidate != null) &#123;</span><br><span class="line">				call.setDelegate(candidate);</span><br><span class="line">				threadCalls.put(type, candidate);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		if (isInitialAdapterRequest) &#123;</span><br><span class="line">			threadLocalAdapterResults.remove();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (candidate == null) &#123;</span><br><span class="line">		// 6.没有找到能够创建适配器的工厂，则抛出IllegalArgumentException异常。</span><br><span class="line">		throw new IllegalArgumentException(&quot;GSON (&quot; + GsonBuildConfig.VERSION + &quot;) cannot handle &quot; + type);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (isInitialAdapterRequest) &#123;</span><br><span class="line">		// 7.当前线程首次请求适配器，则将线程本地缓存中的适配器发布到全局缓存typeTokenCache中。</span><br><span class="line">		typeTokenCache.putAll(threadCalls);</span><br><span class="line">	&#125;</span><br><span class="line">	return candidate;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>本质上就是通过传入的<code>TypeToken</code>参数来确定需要获取的类型适配器<code>TypeAdapter</code>，只不过加入了缓存相关的逻辑，通过缓存来提高获取效率。</p>
<blockquote>
<p>tips：当多个线程并发调用<code>getAdapter()</code>方法请求同一类型的适配器时，此方法可能会返回不同的TypeAdapter实例。如果对应的TypeAdapter的实现是无状态的，这就不会有什么问题，反之就会带来意想不到的问题。谨记‼️</p>
</blockquote>
<p>找到合适的适配器后，Gson会通过适配器来进行具体的序列化/反序列化操作。</p>
<h3 id="Gson解析基础数据类型"><a href="#Gson解析基础数据类型" class="headerlink" title="Gson解析基础数据类型"></a>Gson解析基础数据类型</h3><p>Gson内置了平台的基础类型适配器，我们以boolean类型为例，来看看Gson是怎么对boolean类型进行序列化/反序列化工作的。boolean类型对应的适配器是TypeAdapters.Boolean，相关代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static final TypeAdapter&lt;Boolean&gt; BOOLEAN = new TypeAdapter&lt;Boolean&gt;() &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public Boolean read(JsonReader in) throws IOException &#123;</span><br><span class="line">		JsonToken peek = in.peek();</span><br><span class="line">		if (peek == JsonToken.NULL) &#123;</span><br><span class="line">			in.nextNull();</span><br><span class="line">			return null;</span><br><span class="line">		&#125; else if (peek == JsonToken.STRING) &#123;</span><br><span class="line">			// GSON 1.7版本后支持将String解析成boolean类型</span><br><span class="line">			return Boolean.parseBoolean(in.nextString());</span><br><span class="line">		&#125;</span><br><span class="line">		return in.nextBoolean();</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void write(JsonWriter out, Boolean value) throws IOException &#123;</span><br><span class="line">		out.value(value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h3 id="Gson解析map和集合"><a href="#Gson解析map和集合" class="headerlink" title="Gson解析map和集合"></a>Gson解析map和集合</h3><p>Gson通过<code>CollectionTypeAdapterFactory</code>工厂来获取集合类型的适配器并进行序列化/反序列化操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#CollectionTypeAdapterFactory.java</span><br><span class="line">public &lt;T&gt; TypeAdapter&lt;T&gt; create(Gson gson, TypeToken&lt;T&gt; typeToken) &#123;</span><br><span class="line">	Type type = typeToken.getType();</span><br><span class="line"></span><br><span class="line">	Class&lt;? super T&gt; rawType = typeToken.getRawType();</span><br><span class="line">	if (!Collection.class.isAssignableFrom(rawType)) &#123;</span><br><span class="line">		// 判断传入类型是否为集合类型，如果不是则返回null</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 获取集合元素的类型</span><br><span class="line">	Type elementType = $Gson$Types.getCollectionElementType(type, rawType);</span><br><span class="line">	// 使用gson.getAdapter()方法获取该元素类型的适配器。</span><br><span class="line">	TypeAdapter&lt;?&gt; elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));</span><br><span class="line">	ObjectConstructor&lt;T&gt; constructor = constructorConstructor.get(typeToken);</span><br><span class="line">	// 创建并返回对应的TypeAdapter</span><br><span class="line">	@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span><br><span class="line">	TypeAdapter&lt;T&gt; result = new Adapter(gson, elementType, elementTypeAdapter, constructor);</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static final class Adapter&lt;E&gt; extends TypeAdapter&lt;Collection&lt;E&gt;&gt; &#123;</span><br><span class="line">	private final TypeAdapter&lt;E&gt; elementTypeAdapter;</span><br><span class="line">	private final ObjectConstructor&lt;? extends Collection&lt;E&gt;&gt; constructor;</span><br><span class="line"></span><br><span class="line">	public Adapter(Gson context, Type elementType,</span><br><span class="line">				   TypeAdapter&lt;E&gt; elementTypeAdapter,</span><br><span class="line">				   ObjectConstructor&lt;? extends Collection&lt;E&gt;&gt; constructor) &#123;</span><br><span class="line">		this.elementTypeAdapter =</span><br><span class="line">		new TypeAdapterRuntimeTypeWrapper&lt;&gt;(context, elementTypeAdapter, elementType);</span><br><span class="line">		this.constructor = constructor;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override public Collection&lt;E&gt; read(JsonReader in) throws IOException &#123;</span><br><span class="line">		if (in.peek() == JsonToken.NULL) &#123;</span><br><span class="line">			in.nextNull();</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		// 通过constructor.construct()创建集合实例</span><br><span class="line">		Collection&lt;E&gt; collection = constructor.construct();</span><br><span class="line">		// 消费json字符串中的&#x27;[&#x27;</span><br><span class="line">		in.beginArray();</span><br><span class="line">		while (in.hasNext()) &#123;</span><br><span class="line">			// 调用元素TypeAdapter.read(in)生成元素实例</span><br><span class="line">			E instance = elementTypeAdapter.read(in);</span><br><span class="line">			// 加入集合</span><br><span class="line">			collection.add(instance);</span><br><span class="line">		&#125;</span><br><span class="line">		// 消费json字符串中的&#x27;]&#x27;</span><br><span class="line">		in.endArray();</span><br><span class="line">		// 返回集合实例</span><br><span class="line">		return collection;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override public void write(JsonWriter out, Collection&lt;E&gt; collection) throws IOException &#123;</span><br><span class="line">		if (collection == null) &#123;</span><br><span class="line">			out.nullValue();</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		// 生成json字符串中的&#x27;[&#x27;</span><br><span class="line">		out.beginArray();</span><br><span class="line">		// 遍历集合，调用子元素的TypeAdapter.write序列化子元素</span><br><span class="line">		for (E element : collection) &#123;</span><br><span class="line">			elementTypeAdapter.write(out, element);</span><br><span class="line">		&#125;</span><br><span class="line">		// 生成json字符串中的&#x27;]&#x27;</span><br><span class="line">		out.endArray();</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>解析Map类型的过程和集合类似，只不过Map类型需要维护 Key 和 Value 两个TypeAdapter来进行序列化和反序列化操作，此处不再赘述，感兴趣的童鞋可以自行查看源码。</p>
<h3 id="Gson解析枚举类型"><a href="#Gson解析枚举类型" class="headerlink" title="Gson解析枚举类型"></a>Gson解析枚举类型</h3><p>Gson在处理枚举类型时，默认使用内置的<code>EnumTypeAdapter</code>。EnumTypeAdapter的工作原理基于枚举值的名称，而不是其序数或任何其他属性。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">private static final class EnumTypeAdapter&lt;T extends Enum&lt;T&gt;&gt; extends TypeAdapter&lt;T&gt; &#123;</span><br><span class="line">	private final Map&lt;String, T&gt; nameToConstant = new HashMap&lt;&gt;();</span><br><span class="line">	private final Map&lt;String, T&gt; stringToConstant = new HashMap&lt;&gt;();</span><br><span class="line">	private final Map&lt;T, String&gt; constantToName = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	public EnumTypeAdapter(final Class&lt;T&gt; classOfT) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			// 使用反射查找枚举常量，以解决混淆类名称的不匹配问题</span><br><span class="line">			// 通过访问控制器以特权上下文运行代码，并获取类的声明字段，筛选出枚举常量字段</span><br><span class="line">			Field[] constantFields = AccessController.doPrivileged(new PrivilegedAction&lt;Field[]&gt;() &#123;</span><br><span class="line">				@Override public Field[] run() &#123;</span><br><span class="line">					Field[] fields = classOfT.getDeclaredFields();</span><br><span class="line">					ArrayList&lt;Field&gt; constantFieldsList = new ArrayList&lt;&gt;(fields.length);</span><br><span class="line">					for (Field f : fields) &#123;</span><br><span class="line">						if (f.isEnumConstant()) &#123;</span><br><span class="line">							constantFieldsList.add(f);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					Field[] constantFields = constantFieldsList.toArray(new Field[0]);</span><br><span class="line">					// 将字段设置为可访问</span><br><span class="line">					AccessibleObject.setAccessible(constantFields, true);</span><br><span class="line">					return constantFields;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			// 遍历枚举常量字段，并构三个关键的map结构表：</span><br><span class="line">			// 1.名称 -&gt; 枚举常量 表 nameToConstant</span><br><span class="line">			// 1.字符串 -&gt; 枚举常量 表 stringToConstant</span><br><span class="line">			// 3.枚举常量 -&gt; 名称 表 constantToName</span><br><span class="line">			for (Field constantField : constantFields) &#123;</span><br><span class="line">				@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">				T constant = (T)(constantField.get(null));</span><br><span class="line">				String name = constant.name();</span><br><span class="line">				String toStringVal = constant.toString();</span><br><span class="line"></span><br><span class="line">				SerializedName annotation = constantField.getAnnotation(SerializedName.class);</span><br><span class="line">				if (annotation != null) &#123;</span><br><span class="line">					name = annotation.value();</span><br><span class="line">					for (String alternate : annotation.alternate()) &#123;</span><br><span class="line">						// 字段上有@SerializedName注解，则使用注解的值作为名称</span><br><span class="line">						nameToConstant.put(alternate, constant);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			</span><br><span class="line">				nameToConstant.put(name, constant);</span><br><span class="line">				stringToConstant.put(toStringVal, constant);</span><br><span class="line">				constantToName.put(constant, name);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">			throw new AssertionError(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override public T read(JsonReader in) throws IOException &#123;</span><br><span class="line">		if (in.peek() == JsonToken.NULL) &#123;</span><br><span class="line">			in.nextNull();</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		String key = in.nextString();</span><br><span class="line">		// 根据名称获取枚举常量</span><br><span class="line">		T constant = nameToConstant.get(key);</span><br><span class="line">		return (constant == null) ? stringToConstant.get(key) : constant;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override public void write(JsonWriter out, T value) throws IOException &#123;</span><br><span class="line">		// 根据常量获取名称</span><br><span class="line">		out.value(value == null ? null : constantToName.get(value));</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="Gson解析Java-Bean"><a href="#Gson解析Java-Bean" class="headerlink" title="Gson解析Java Bean"></a>Gson解析Java Bean</h3><p>Gson中，Java Bean类型的TypeAdapter都是由<code>ReflectiveTypeAdapterFactory</code>工厂创建的。我们来看创建TypeAdapter的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; TypeAdapter&lt;T&gt; create(Gson gson, final TypeToken&lt;T&gt; type) &#123;</span><br><span class="line">    Class&lt;? super T&gt; raw = type.getRawType();</span><br><span class="line"></span><br><span class="line">	// Object类型，返回null</span><br><span class="line">    if (!Object.class.isAssignableFrom(raw)) &#123;</span><br><span class="line">      return null; // it&#x27;s a primitive!</span><br><span class="line">    &#125;</span><br><span class="line">	// 根据反射过滤器的配置，判断是否允许使用反射来访问该类型字段</span><br><span class="line">    FilterResult filterResult =</span><br><span class="line">        ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, raw);</span><br><span class="line">    if (filterResult == FilterResult.BLOCK_ALL) &#123;</span><br><span class="line">	  // 不允许，抛出 JsonIOException 异常</span><br><span class="line">      throw new JsonIOException(</span><br><span class="line">          &quot;ReflectionAccessFilter does not permit using reflection for &quot; + raw</span><br><span class="line">              + &quot;. Register a TypeAdapter for this type or adjust the access filter.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    boolean blockInaccessible = filterResult == FilterResult.BLOCK_INACCESSIBLE;</span><br><span class="line"></span><br><span class="line">	// 如果为Java记录（Record）类型，使用RecordAdapter来处理解析工作</span><br><span class="line">    if (ReflectionHelper.isRecord(raw)) &#123;</span><br><span class="line">      @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">      TypeAdapter&lt;T&gt; adapter = (TypeAdapter&lt;T&gt;) new RecordAdapter&lt;&gt;(raw,</span><br><span class="line">          getBoundFields(gson, type, raw, blockInaccessible, true), blockInaccessible);</span><br><span class="line">      return adapter;</span><br><span class="line">    &#125;</span><br><span class="line">	// 根据该类型的构造函数和字段信息，创建FieldReflectionAdapter实例，并返回该实例作为TypeAdapter的实现</span><br><span class="line">    ObjectConstructor&lt;T&gt; constructor = constructorConstructor.get(type);</span><br><span class="line">    return new FieldReflectionAdapter&lt;&gt;(constructor, getBoundFields(gson, type, raw, blockInaccessible, false));</span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>

<p>这段代码关键点有以下几点：</p>
<ul>
<li>根据传入的类型是否为<code>Java记录类型</code>返回不同的TypeAdapter。Java记录（Record）类型，使用<code>RecordAdapter</code>来处理解析工作；反之使用<code>FieldReflectionAdapter</code>处理。</li>
<li>无论是<code>RecordAdapter</code>还是<code>FieldReflectionAdapter</code>，都会通过<code>getBoundFields()</code>方法生成一个用以表示<code>字段名和绑定字段（serializeName - boundFiled）</code>的映射关系的Map对象。</li>
</ul>
<blockquote>
<p>Java 记录类型是Java 14中引入的一个预览特性，并在Java 16中成为正式特性。记录提供了一种简洁的方式来声明只包含数据的不可变类。其特性类似于 kotlin 中的 <code>data class</code></p>
</blockquote>
<p>然后在TypeAdapter中借助这个map对象进行解析工作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public static abstract class Adapter&lt;T, A&gt; extends TypeAdapter&lt;T&gt; &#123;</span><br><span class="line">	final Map&lt;String, BoundField&gt; boundFields;</span><br><span class="line"></span><br><span class="line">	Adapter(Map&lt;String, BoundField&gt; boundFields) &#123;</span><br><span class="line">		this.boundFields = boundFields;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void write(JsonWriter out, T value) throws IOException &#123;</span><br><span class="line">		// value为null，输出null</span><br><span class="line">		if (value == null) &#123;</span><br><span class="line">			out.nullValue();</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		// 生成json字符串&quot;&#123;&quot;</span><br><span class="line">		out.beginObject();</span><br><span class="line">		try &#123;</span><br><span class="line">			// 遍历boundFields中的所有字段，调用boundField.write()方法将字段的值序列化为JSON格式并输出</span><br><span class="line">			for (BoundField boundField : boundFields.values()) &#123;</span><br><span class="line">				boundField.write(out, value);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">			throw ReflectionHelper.createExceptionForUnexpectedIllegalAccess(e);</span><br><span class="line">		&#125;</span><br><span class="line">		// 生成json字符串&quot;&#125;&quot;</span><br><span class="line">		out.endObject();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public T read(JsonReader in) throws IOException &#123;</span><br><span class="line">		// null 值校验</span><br><span class="line">		if (in.peek() == JsonToken.NULL) &#123;</span><br><span class="line">			in.nextNull();</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		// 创建一个accumulator对象来存储字段的值</span><br><span class="line">		A accumulator = createAccumulator();</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			// 消费json字符串&quot;&#123;&quot;</span><br><span class="line">			in.beginObject();</span><br><span class="line">			// 遍历JSON的所有字段，若字段存在于boundFields中且标记为可反序列化</span><br><span class="line">			// 则调用readField()方法将JSON字段的值反序列化为对应的字段值，并存储到accumulator中</span><br><span class="line">			while (in.hasNext()) &#123;</span><br><span class="line">				String name = in.nextName();</span><br><span class="line">				BoundField field = boundFields.get(name);</span><br><span class="line">				if (field == null || !field.deserialized) &#123;</span><br><span class="line">					in.skipValue();</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					readField(accumulator, in, field);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (IllegalStateException e) &#123;</span><br><span class="line">			throw new JsonSyntaxException(e);</span><br><span class="line">		&#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">			throw ReflectionHelper.createExceptionForUnexpectedIllegalAccess(e);</span><br><span class="line">		&#125;</span><br><span class="line">		// 消费json字符串&quot;&#125;&quot;</span><br><span class="line">		in.endObject();</span><br><span class="line">		// 将accumulator转换为目标对象的实例并返回</span><br><span class="line">		return finalize(accumulator);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/** 用于创建用于存储字段值的中间对象 */</span><br><span class="line">	abstract A createAccumulator();</span><br><span class="line">	/**</span><br><span class="line">     * 用于将JSON字段的值反序列化为对应的字段值，并存储到中间对象中</span><br><span class="line">     */</span><br><span class="line">	abstract void readField(A accumulator, JsonReader in, BoundField field)</span><br><span class="line">	throws IllegalAccessException, IOException;</span><br><span class="line">	/** 用于将中间对象转换为目标对象的实例 */</span><br><span class="line">	abstract T finalize(A accumulator);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="Gson如何创建对象？"><a href="#Gson如何创建对象？" class="headerlink" title="Gson如何创建对象？"></a>Gson如何创建对象？</h3><p>与Gson解析一致，Gson创建也因对象类型的不同，分为4种情况：</p>
<ul>
<li>基础类型、以及基础类型的包装类型等由Gson提供的TypeAdapter通过 new 关键字创建；</li>
<li>枚举类型在EnumTypeAdapter中只是通过枚举名称切换不同的枚举常量，不涉及对象的创建；</li>
<li>集合和map等容器类型通过Gson内置的对象创建工厂，调用 new 关键字进行创建；</li>
<li>Java Bean对象的创建比较复杂，分为3种情况，优先级由上到下依次降低：<ul>
<li>开发者定义了对象创建工厂<code>InstanceCreator</code>，则使用该工厂创建；</li>
<li>存在默认的无参构造函数，通过反射构造函数创建；</li>
<li>使用<code>Unsafe API</code> 创建。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#ConstructorConstructor.java</span><br><span class="line">public &lt;T&gt; ObjectConstructor&lt;T&gt; get(TypeToken&lt;T&gt; typeToken) &#123;</span><br><span class="line">	// 1.获取TypeToken对应的类型(Type)和原始类型(Class&lt;? super T&gt;）</span><br><span class="line">	final Type type = typeToken.getType();</span><br><span class="line">	Class&lt;? super T&gt; rawType = typeToken.getRawType();</span><br><span class="line">	// 2.从instanceCreators中根据类型(Type)获取对应的实例创建器(InstanceCreator)</span><br><span class="line">	//   如果存在，则创建并返回一个新的对象构造器，该构造器使用该实例创建器来创建对象</span><br><span class="line">	final InstanceCreator&lt;T&gt; typeCreator = (InstanceCreator)this.instanceCreators.get(type);</span><br><span class="line">	if (typeCreator != null) &#123;</span><br><span class="line">		return new ObjectConstructor&lt;T&gt;() &#123;</span><br><span class="line">			public T construct() &#123;</span><br><span class="line">				return typeCreator.createInstance(type);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		// 3.如果步骤2中没有获取到实例创建器，则尝试根据原始类型(rawType)从instanceCreators中获取实例创建器</span><br><span class="line">		// 如果存在，则创建并返回一个新的对象构造器，该构造器使用该实例创建器来创建对象。</span><br><span class="line">		final InstanceCreator&lt;T&gt; rawTypeCreator = (InstanceCreator)this.instanceCreators.get(rawType);</span><br><span class="line">		if (rawTypeCreator != null) &#123;</span><br><span class="line">			return new ObjectConstructor&lt;T&gt;() &#123;</span><br><span class="line">				public T construct() &#123;</span><br><span class="line">					return rawTypeCreator.createInstance(type);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			// 4.如果步骤2和步骤3都没有获取到实例创建器，则尝试调用newDefaultConstructor方法创建一个默认构造器，如果存在，则返回该构造器（无参构造函数）</span><br><span class="line">			ObjectConstructor&lt;T&gt; defaultConstructor = this.newDefaultConstructor(rawType);</span><br><span class="line">			if (defaultConstructor != null) &#123;</span><br><span class="line">				return defaultConstructor;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				// 5.如果步骤4中没有创建到默认构造器，则尝试调用newDefaultImplementationConstructor方法创建一个默认实现构造器，如果存在，则返回该构造器（容器类型）</span><br><span class="line">				ObjectConstructor&lt;T&gt; defaultImplementation = this.newDefaultImplementationConstructor(type, rawType);</span><br><span class="line">				// 6.如果步骤5中没有创建到默认实现构造器，则尝试调用newUnsafeAllocator方法创建一个不安全的分配器构造器，最后返回该构造器（Unsafe）</span><br><span class="line">				return defaultImplementation != null ? defaultImplementation : this.newUnsafeAllocator(type, rawType);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="使用Gson需要注意⚠"><a href="#使用Gson需要注意⚠" class="headerlink" title="使用Gson需要注意⚠"></a>使用Gson需要注意⚠</h2><p>通过上文我们分析可知，当Java类未提供默认的无参构造函数时，Gson会使用 Unsafe API 来创建对象，这种创建对象的方式不会调用构造函数，因此会导致以下几个可能的问题：</p>
<ul>
<li>默认值丢失；</li>
<li>Kotlin 非空类型失效；</li>
<li>初始化块可能不会正常执行；</li>
</ul>
<h2 id="关于更优雅的使用Gson的一些经验之谈"><a href="#关于更优雅的使用Gson的一些经验之谈" class="headerlink" title="关于更优雅的使用Gson的一些经验之谈"></a>关于更优雅的使用Gson的一些经验之谈</h2><h3 id="正确的配置Gson"><a href="#正确的配置Gson" class="headerlink" title="正确的配置Gson"></a>正确的配置Gson</h3><p>正确配置Gson实例对于确保JSON的序列化和反序列化过程满足应用程序的需求至关重要。不恰当的配置可能导致数据丢失、格式错误或性能低下。下面几条是本人的经验之谈：</p>
<h4 id="注意null值"><a href="#注意null值" class="headerlink" title="注意null值"></a>注意null值</h4><p>默认情况下，Gson不会序列化值为null的字段。这可能会导致生成的JSON字符串缺少某些字段，特别是在与严格依赖JSON结构的外部系统交互时可能会出现问题。可以通过在创建Gson实例时使用GsonBuilder并调用serializeNulls()方法来改变这一行为。</p>
<h4 id="不区分大小写的枚举反序列化"><a href="#不区分大小写的枚举反序列化" class="headerlink" title="不区分大小写的枚举反序列化"></a>不区分大小写的枚举反序列化</h4><p>在反序列化枚举类型时，Gson默认不区分大小写，这可能会导致一些意外行为。如果JSON字符串中的枚举值和Java枚举常量在大小写上不一致，Gson仍然会将其成功反序列化，这可能不是所有场景下都期望的行为。</p>
<h4 id="合理设置FieldNamingPolicy"><a href="#合理设置FieldNamingPolicy" class="headerlink" title="合理设置FieldNamingPolicy"></a>合理设置FieldNamingPolicy</h4><p>使用FieldNamingPolicy来适应服务端不同的字段命名风格</p>
<h3 id="合理定义字段类型"><a href="#合理定义字段类型" class="headerlink" title="合理定义字段类型"></a>合理定义字段类型</h3><p>很多时候，服务端往往会通过String类型或者数字类型返回表示枚举的含义，这个时候我们如果按服务端返回类型定义字段就会对代码的可读性造成影响。例如电商app的商品类我们定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data class Good(</span><br><span class="line">    val id: Int,</span><br><span class="line">    val name: String,</span><br><span class="line">    val price: Double,</span><br><span class="line">    val type: String,</span><br><span class="line">) &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        public const val GOOD_TYPE_FRESH = &quot;fresh&quot;</span><br><span class="line">        public const val GOOD_TYPE_BOOK = &quot;book&quot;</span><br><span class="line">        public const val GOOD_TYPE_FOOD = &quot;food&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>其中type表示商品类型，我们按服务端返回类型将其定义成String类型，type可能有三个值，在使用type字段时，我们往往不知道这个值包含哪几种情况，需要跳转Good类查看代码才能了解到，如果我们将type直接定义为枚举类型呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data class Good(</span><br><span class="line">    val id: Int,</span><br><span class="line">    val name: String,</span><br><span class="line">    val price: Double,</span><br><span class="line">    val type: GoodType,</span><br><span class="line">)</span><br><span class="line">enum class GoodType &#123;</span><br><span class="line">    @SerializedName(&quot;fresh&quot;)FRESH,</span><br><span class="line">    @SerializedName(&quot;book&quot;)BOOK,</span><br><span class="line">    @SerializedName(&quot;food&quot;)FOOD,</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>两种代码的可读性就有了明显的差距。所以，<strong>合理定义字段类型很重要。</strong></p>
<h3 id="巧用TypeAdapter"><a href="#巧用TypeAdapter" class="headerlink" title="巧用TypeAdapter"></a>巧用TypeAdapter</h3><h4 id="结合自身产品服务端返回字段的规范合理使用TypeAdapter"><a href="#结合自身产品服务端返回字段的规范合理使用TypeAdapter" class="headerlink" title="结合自身产品服务端返回字段的规范合理使用TypeAdapter"></a>结合自身产品服务端返回字段的规范合理使用TypeAdapter</h4><p>服务端常常使用1表示true，0或者其他数字表示false。对于boolean类型，Gson默认是没有这样的解析规则的，所以我们往往只能将字段定义成int类型，再对getter方法做处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data class Good(</span><br><span class="line">	val id: Int,</span><br><span class="line">	val name: String,</span><br><span class="line">	val price: Double,</span><br><span class="line">	val type: GoodType,</span><br><span class="line">	// 是否为热销商品，1代表热销商品</span><br><span class="line">	val isHot: Int,</span><br><span class="line">) &#123;</span><br><span class="line">	fun isHot(): Boolean &#123;</span><br><span class="line">		return isHot == 1</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>如果服务端对于字段的返回规范就是1表示true其余表示false，那客户端项目中少不了类似的处理。这个时候我们不妨自定义一个<code>TypeAdapter</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class BooleanTypeAdapter: TypeAdapter&lt;Boolean&gt;() &#123;</span><br><span class="line">    override fun write(out: JsonWriter, value: Boolean) &#123;</span><br><span class="line">        out.value(value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun read(`in`: JsonReader): Boolean? &#123;</span><br><span class="line">        return when (`in`.peek()) &#123;</span><br><span class="line">            JsonToken.NULL -&gt; &#123;</span><br><span class="line">                `in`.nextNull()</span><br><span class="line">                null</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            JsonToken.STRING -&gt; &#123;</span><br><span class="line">                java.lang.Boolean.parseBoolean(`in`.nextString())</span><br><span class="line">            &#125;</span><br><span class="line">			// 对数字类型做解析，1为true，其余为false</span><br><span class="line">            JsonToken.NUMBER -&gt; &#123;</span><br><span class="line">                `in`.nextInt() == 1</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            else -&gt; `in`.nextBoolean()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>然后在配置Gson时全局应用下这个TypeAdapter：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val gson = GsonBuilder()</span><br><span class="line">	.registerTypeAdapter(Boolean::class.java, BooleanTypeAdapter())</span><br><span class="line">	.create() </span><br></pre></td></tr></table></figure>

<p>这样就可以使用boolean值定义<code>isHot</code>字段了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data class Good(</span><br><span class="line">	val id: Int,</span><br><span class="line">	val name: String,</span><br><span class="line">	val price: Double,</span><br><span class="line">	val type: GoodType,</span><br><span class="line">	val isHot: Boolean,</span><br><span class="line">) </span><br></pre></td></tr></table></figure>

<h4 id="结合平台特性合理使用TypeAdapter"><a href="#结合平台特性合理使用TypeAdapter" class="headerlink" title="结合平台特性合理使用TypeAdapter"></a>结合平台特性合理使用TypeAdapter</h4><p>对于Android开发者，我们往往需要为View设置颜色相关的属性，这些颜色有时是通过服务端返回字段控制的，如换肤相关的背景色，默认情况下，我们只能这么处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">data class Good(</span><br><span class="line">	val id: Int,</span><br><span class="line">	val name: String,</span><br><span class="line">	val price: Double,</span><br><span class="line">	val type: GoodType,</span><br><span class="line">	val isHot: Boolean,</span><br><span class="line">	val bgColor: String,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 使用时，需要将颜色字符串通过Color.parseColor方法解析成Android平台的色值Int类型I</span><br><span class="line">var bgColor: Int</span><br><span class="line">try &#123;</span><br><span class="line">	bgColor = Color.parseColor(good.bgColor)</span><br><span class="line">&#125; catch (e: Exception) &#123;</span><br><span class="line">	bgColor = Color.WHITE</span><br><span class="line">&#125;</span><br><span class="line">view.setBackgroundColor(bgColor) </span><br></pre></td></tr></table></figure>

<p>这个时候自定义TypeAdapter又可以派上用场了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class ColorTypeAdapter : TypeAdapter&lt;Int&gt;() &#123;</span><br><span class="line">	override fun write(out: JsonWriter, value: Int?) &#123;</span><br><span class="line">		if (value == null) &#123;</span><br><span class="line">			out.nullValue()</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			// 将Int颜色值转换为16进制字符串</span><br><span class="line">			val colorStr = &quot;#$&#123;Integer.toHexString(value).toUpperCase()&#125;&quot;</span><br><span class="line">			out.value(colorStr)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	override fun read(`in`: JsonReader): Int? &#123;</span><br><span class="line">		if (`in`.peek() == JsonToken.NULL) &#123;</span><br><span class="line">			`in`.nextNull()</span><br><span class="line">			return null</span><br><span class="line">		&#125;</span><br><span class="line">		// 从JSON读取字符串并转换为Int颜色值</span><br><span class="line">		val colorStr = `in`.nextString()</span><br><span class="line">		return try &#123;</span><br><span class="line">			// 使用Android的Color类来解析16进制颜色字符串</span><br><span class="line">			Color.parseColor(colorStr)</span><br><span class="line">		&#125; catch (e: IllegalArgumentException) &#123;</span><br><span class="line">			null</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>然后对<code>bgColor</code>字段应用<code>ColorTypeAdapter</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data class Good(</span><br><span class="line">	val id: Int,</span><br><span class="line">	val name: String,</span><br><span class="line">	val price: Double,</span><br><span class="line">	val type: GoodType,</span><br><span class="line">	val isHot: Boolean,</span><br><span class="line">	@JsonAdapter(ColorTypeAdapter::class)</span><br><span class="line">	val bgColor: String,</span><br><span class="line">)</span><br><span class="line">// 使用时，直接使用bgColor，无需手动解析</span><br><span class="line">view.setBackgroundColor(bgColor) </span><br></pre></td></tr></table></figure>

<p>所以，使用Gson时，结合平台特性，合理自定义TypeAdapte也能大大提升开发效率。</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://juejin.cn/post/7355800792073469992">https://juejin.cn/post/7355800792073469992</a>，如有侵权，请联系删除。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://juejin.cn/user/4019470242156759">沈剑心</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://juejin.cn/post/7355800792073469992">https://juejin.cn/post/7355800792073469992</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.lemongo97.com" target="_blank">LemonGo97のBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/JSON/">JSON</a></div><div class="post_share"><div class="social-share" data-image="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/all_default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/3373dbe/"><img class="prev-cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/build-your-applications-with-golang.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Go语言入门分享</div></div></a></div><div class="next-post pull-right"><a href="/posts/372de39a/"><img class="next-cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/3eb93c55a64067297eafa2aaa5b62a0f.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">10 款更先进的开源命令行工具</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/posts/7de3e7aa/" title="Curator实现Zookeeper注册中心（官方文档翻译）"><img class="relatedPosts_cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/20201225124820.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-24</div><div class="relatedPosts_title">Curator实现Zookeeper注册中心（官方文档翻译）</div></div></a></div><div class="relatedPosts_item"><a href="/posts/8662ab0e/" title="Java 网络编程之 SSL加密连接"><img class="relatedPosts_cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/default_cover_1.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-06</div><div class="relatedPosts_title">Java 网络编程之 SSL加密连接</div></div></a></div><div class="relatedPosts_item"><a href="/posts/d8676d75/" title="Netty In Action -- Netty的组件和设计"><img class="relatedPosts_cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/Snipaste_2024-05-06_00-33-28%202.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-06</div><div class="relatedPosts_title">Netty In Action -- Netty的组件和设计</div></div></a></div><div class="relatedPosts_item"><a href="/posts/dc761a4c/" title="Netty In Action -- 传输"><img class="relatedPosts_cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/Snipaste_2024-05-06_00-33-28%202.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-06</div><div class="relatedPosts_title">Netty In Action -- 传输</div></div></a></div><div class="relatedPosts_item"><a href="/posts/8aef8fee/" title="Netty In Action -- 核心组件"><img class="relatedPosts_cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/Snipaste_2024-05-06_00-33-28%202.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-06</div><div class="relatedPosts_title">Netty In Action -- 核心组件</div></div></a></div><div class="relatedPosts_item"><a href="/posts/a097aeed/" title="Zookeeper 入门"><img class="relatedPosts_cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/20200804150229.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-13</div><div class="relatedPosts_title">Zookeeper 入门</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By LemonGo97</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/instant.page/5.1.0/instantpage.min.js" type="module" defer></script><script src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.3.1/lazyload.iife.min.js" async></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'w7vT5VedMPyGHyDYppcacmtw-gzGzoHsz',
      appKey: 'YxBl09Aj50g5Ld621aydI4pz',
      placeholder: '来和大家一起讨论吧！',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div></div></body></html>