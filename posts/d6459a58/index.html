<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>无锁队列的几种实现及其性能对比 | LemonGo97のBlog</title><meta name="description" content="作者：juliatliu，腾讯 PCG 运营开发工程师 一、无锁队列用在什么样的场景？当需要处理的数据非常多，比如行情数据，一秒处理非常多的数据的时候，可以考虑用无锁队列。但是如果一秒只需要处理几百或者几千的数据，是没有必要考虑用无锁队列的。用互斥锁就能解决问题，数据量相对少的时候互斥锁与无锁队列之间差别并不是很明显。 二、为什么要用无锁队列？有锁队列会有哪些问题？ 1、Cache 的损坏，在线程"><meta name="keywords" content="Java,Linux,BigData,MySQL,MongoDB"><meta name="author" content="LemonGo97"><meta name="copyright" content="LemonGo97"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.lemongo97.com/posts/d6459a58/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><meta property="og:type" content="article"><meta property="og:title" content="无锁队列的几种实现及其性能对比"><meta property="og:url" content="https://blog.lemongo97.com/posts/d6459a58/"><meta property="og:site_name" content="LemonGo97のBlog"><meta property="og:description" content="作者：juliatliu，腾讯 PCG 运营开发工程师 一、无锁队列用在什么样的场景？当需要处理的数据非常多，比如行情数据，一秒处理非常多的数据的时候，可以考虑用无锁队列。但是如果一秒只需要处理几百或者几千的数据，是没有必要考虑用无锁队列的。用互斥锁就能解决问题，数据量相对少的时候互斥锁与无锁队列之间差别并不是很明显。 二、为什么要用无锁队列？有锁队列会有哪些问题？ 1、Cache 的损坏，在线程"><meta property="og:image" content="https://image.lemongo97.com/all_default.jpg"><meta property="article:published_time" content="2023-01-06T09:59:29.000Z"><meta property="article:modified_time" content="2023-01-06T09:59:29.000Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.1.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2023-01-06 17:59:29'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="LemonGo97のBlog" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="https://coding-net-production-static-ci.codehub.cn/d70d0fa9-08d5-4fc7-ba82-7b73fee22292.jpg?imageMogr2/auto-orient/format/jpeg/cut/700x700x0x0" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">65</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">39</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E7%94%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">一、无锁队列用在什么样的场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">二、为什么要用无锁队列？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">三、无锁队列的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E4%B8%80%E8%AF%BB%E4%B8%80%E5%86%99%E7%9A%84%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 一读一写的无锁队列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-1-yqueue%E2%80%94%E2%80%94%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1 yqueue——无锁队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-2-ypipe%E2%80%94%E2%80%94yqueue-%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2 ypipe——yqueue 的封装</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-3-ypipe-%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.1.3 ypipe 设计的目的</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%A4%9A%E8%AF%BB%E5%A4%9A%E5%86%99%E7%9A%84%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">四、多读多写的无锁队列实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-RingBuffer-ArrayLockFreeQueue"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 RingBuffer(ArrayLockFreeQueue)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-enqueue-%E5%85%A5%E9%98%9F%E5%88%97"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.2 enqueue 入队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-dequeue-%E5%87%BA%E9%98%9F%E5%88%97"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.3 dequeue 出队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-yielding-%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-number">4.1.3.</span> <span class="toc-text">4.4 yielding 处理器的必要性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5-%E5%A4%9A%E8%AF%BB%E5%A4%9A%E5%86%99%E7%9A%84-RingBuffer-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.4.</span> <span class="toc-text">4.5 多读多写的 RingBuffer 存在的问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-6-%E5%A4%9A%E8%AF%BB%E5%A4%9A%E5%86%99-RingBuffer-%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">4.1.5.</span> <span class="toc-text">4.6 多读多写 RingBuffer 的性能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-7-RingBuffer-%E7%BB%93%E8%AE%BA"><span class="toc-number">4.1.6.</span> <span class="toc-text">4.7 RingBuffer 结论</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-8-%E5%9B%9B%E7%A7%8D%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="toc-number">4.1.7.</span> <span class="toc-text">4.8 四种线程安全队列实现性能对比</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%814-%E5%86%99-1-%E8%AF%BB"><span class="toc-number">4.1.8.</span> <span class="toc-text">1、4 写 1 读</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%814-%E5%86%99-4-%E8%AF%BB"><span class="toc-number">4.1.9.</span> <span class="toc-text">2、4 写 4 读</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%811-%E5%86%99-4-%E8%AF%BB"><span class="toc-number">4.1.10.</span> <span class="toc-text">3、1 写 4 读</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://image.lemongo97.com/all_default.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">LemonGo97のBlog</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">【转载】 无锁队列的几种实现及其性能对比</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-06T09:59:29.000Z" title="发表于 2023-01-06 17:59:29">2023-01-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-06T09:59:29.000Z" title="更新于 2023-01-06 17:59:29">2023-01-06</time></span></div><div class="meta-secondline"> </div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>作者：juliatliu，腾讯 PCG 运营开发工程师</p>
<h3 id="一、无锁队列用在什么样的场景？"><a href="#一、无锁队列用在什么样的场景？" class="headerlink" title="一、无锁队列用在什么样的场景？"></a>一、无锁队列用在什么样的场景？</h3><p>当需要处理的数据非常多，比如行情数据，一秒处理非常多的数据的时候，可以考虑用无锁队列。但是如果一秒只需要处理几百或者几千的数据，是没有必要考虑用无锁队列的。用互斥锁就能解决问题，数据量相对少的时候互斥锁与无锁队列之间差别并不是很明显。</p>
<h3 id="二、为什么要用无锁队列？"><a href="#二、为什么要用无锁队列？" class="headerlink" title="二、为什么要用无锁队列？"></a>二、为什么要用无锁队列？</h3><p>有锁队列会有哪些问题？</p>
<p><strong>1、Cache 的损坏，在线程间频繁切换的时候会导致 Cache 中数据的丢失；</strong></p>
<p>CPU 的运行速度比主存快 N 倍，所以大量的处理器时间被浪费在处理器与主存的数据传输上，这就是在处理器与主存之间引入 Cache 的原因。Cache 是一种速度更快但容量更小的内存，当处理器要访问主存中的数据时，这些数据首先要被拷贝到 Cache 中，因为这些数据在不久的将来可能又会被处理器访问。Cache misses 对性能有非常大的影响，因为处理器访问 Cache 中的数据将比直接访问主存快得多。</p>
<p>线程被频繁抢占产生的 Cache 损坏将导致应用程序性能下降。</p>
<p><strong>2、在同步机制上争抢队列；</strong></p>
<p>CPU 会将大量的时间浪费在保护队列数据的互斥锁，而不是处理队列中的数据。</p>
<p>然后非阻塞的机制使用了 CAS 的特殊操作，使得任务之间可以不争抢任何资源，然后在队列中预定的位置上，插入或者提取数据。</p>
<p><strong>3、多线程动态内存分配性能下降；</strong></p>
<p>多线程同时分配内存时，会涉及到线程分配同一块相同地址内存的问题，这个时候会用锁来进行同步。显然频繁分配内存会导致应用程序性能下降。</p>
<h3 id="三、无锁队列的实现"><a href="#三、无锁队列的实现" class="headerlink" title="三、无锁队列的实现"></a>三、无锁队列的实现</h3><h4 id="3-1-一读一写的无锁队列"><a href="#3-1-一读一写的无锁队列" class="headerlink" title="3.1 一读一写的无锁队列"></a>3.1 一读一写的无锁队列</h4><p>yqueue 是用来设计队列，ypipe 用来设计队列的写入时机、回滚以及 flush，首先我们来看 yqueue 的设计。</p>
<h5 id="3-1-1-yqueue——无锁队列"><a href="#3-1-1-yqueue——无锁队列" class="headerlink" title="3.1.1 yqueue——无锁队列"></a>3.1.1 yqueue——无锁队列</h5><p><strong>1、内存分配</strong></p>
<p>首先我们需要考虑队列的内存分配，yqueue 中的数据结构使用的 chunk 块机制，每次批量分配一批元素，这样可以减少内存的分配和释放：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, <span class="type">int</span> N&gt;  </span><br><span class="line">    <span class="comment">// 链表结点称之为chunk_t  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk_t</span>  </span></span><br><span class="line"><span class="class">    &#123;</span>  </span><br><span class="line">        T values[N]; <span class="comment">//每个chunk_t可以容纳N个T类型的元素，以后就以一个chunk_t为单位申请内存  </span></span><br><span class="line">        <span class="type">chunk_t</span> *prev;  </span><br><span class="line">        <span class="type">chunk_t</span> *next;  </span><br><span class="line">    &#125;;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/74a3fd96f4b8ba476cdd2d8dfc2ba91a.jpeg" alt=""></p>
<p>当队列不足的时候每次分配一个 chunk_t，每个 chunk_t 能存储 N 个元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Adds an element to the back end of the queue.  </span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">push</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    back_chunk = end_chunk;  </span><br><span class="line">    back_pos = end_pos; <span class="comment">//  </span></span><br><span class="line">    <span class="keyword">if</span> (++end_pos != N) <span class="comment">//end_pos!=N表明这个chunk节点还没有满  </span></span><br><span class="line">         <span class="keyword">return</span>;  </span><br><span class="line">    </span><br><span class="line">     <span class="type">chunk_t</span> *sc = spare_chunk.xchg(<span class="literal">NULL</span>); <span class="comment">// 为什么设置为NULL？ 因为如果把之前值取出来了则没有spare chunk了，所以设置为NULL  </span></span><br><span class="line">     <span class="keyword">if</span> (sc)                               <span class="comment">// 如果有spare chunk则继续复用它  </span></span><br><span class="line">     &#123;  </span><br><span class="line">         end_chunk-&gt;next = sc;  </span><br><span class="line">         sc-&gt;prev = end_chunk;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">else</span> <span class="comment">// 没有则重新分配  </span></span><br><span class="line">     &#123;  </span><br><span class="line">         <span class="comment">// static int s_cout = 0;  </span></span><br><span class="line">         <span class="comment">// printf(&quot;s_cout:%d\n&quot;, ++s_cout);  </span></span><br><span class="line">         end_chunk-&gt;next = (<span class="type">chunk_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">chunk_t</span>)); <span class="comment">// 分配一个chunk  </span></span><br><span class="line">         alloc_assert(end_chunk-&gt;next);  </span><br><span class="line">         end_chunk-&gt;next-&gt;prev = end_chunk;  </span><br><span class="line">     &#125;  </span><br><span class="line">     end_chunk = end_chunk-&gt;next;  </span><br><span class="line">     end_pos = <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到 112 行，在要 push 一个元素的时候，首先看最后一个 chunk，也就是 back_chunk 的 back_pos 是不是该 chunk 的最后一个元素，如果是，则重新分配一个 chunk，将这个 chunk 加到 chunk 链表的下一个节点。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/0082c810c4aa7a3307f6a62fd39d6086.jpeg" alt=""></p>
<p>这个逻辑相对来说还是比较简单的。唯一需要关注的，就是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">chunk_t</span> *sc = spare_chunk.xchg(<span class="literal">NULL</span>);  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这一行，这个 spare_chunk 是怎么来的？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Removes an element from the front end of the queue.  </span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (++begin_pos == N) <span class="comment">// 删除满一个chunk才回收chunk  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="type">chunk_t</span> *o = begin_chunk;  </span><br><span class="line">        begin_chunk = begin_chunk-&gt;next;  </span><br><span class="line">        begin_chunk-&gt;prev = <span class="literal">NULL</span>;  </span><br><span class="line">        begin_pos = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//  &#x27;o&#x27; has been more recently used than spare_chunk,  </span></span><br><span class="line">        <span class="comment">//  so for cache reasons we&#x27;ll get rid of the spare and  </span></span><br><span class="line">        <span class="comment">//  use &#x27;o&#x27; as the spare.  </span></span><br><span class="line">        <span class="type">chunk_t</span> *cs = spare_chunk.xchg(o); <span class="comment">//由于局部性原理，总是保存最新的空闲块而释放先前的空闲快  </span></span><br><span class="line">        <span class="built_in">free</span>(cs);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当 pop 的时候，如果删除一个 chunk 里面没有元素了，这个时候会需要将这个 chunk 所开辟的空间释放掉，但是这里使用了一个技巧即：将这个 chunk 先不释放，先放到 spare_chunk 里面，等到下次需要开辟新的空间的时候再把这个 spare_chunk 拿来用。</p>
<p>我们再来看 ypipe。</p>
<h5 id="3-1-2-ypipe——yqueue-的封装"><a href="#3-1-2-ypipe——yqueue-的封装" class="headerlink" title="3.1.2 ypipe——yqueue 的封装"></a>3.1.2 ypipe——yqueue 的封装</h5><p>yqueue 负责元素内存的分配与释放，入队以及出队列；ypipe 负责 yqueue 读写指针的变化。</p>
<p>ypipe 是在 yqueue_t 的基础上再构建一个单读单写的无锁队列。</p>
<p>这里有三个指针：</p>
<ul>
<li><p>T* w:指向第一个未刷新的元素，只被写线程使用；</p>
</li>
<li><p>T* r:指向第一个没有被预提取的元素，只被读线程使用；</p>
</li>
<li><p>T*f:指向下一轮要被刷新的一批元素的第一个。</p>
</li>
</ul>
<p>ypipe 的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Initialises the pipe.  </span></span><br><span class="line"><span class="keyword">inline</span> <span class="title function_">ypipe_t</span><span class="params">()</span>  </span><br><span class="line"><span class="comment">//  The destructor doesn&#x27;t have to be virtual. It is mad virtual  </span></span><br><span class="line"><span class="comment">//  just to keep ICC and code checking tools from complaining.  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> virtual ~<span class="title function_">ypipe_t</span><span class="params">()</span>&#123;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入数据，incomplete参数表示写入是否还没完成，在没完成的时候不会修改flush指针，即这部分数据不会让读线程看到。  </span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">write</span><span class="params">(<span class="type">const</span> T &amp;value_, <span class="type">bool</span> incomplete_)</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">unwrite</span><span class="params">(T *value_)</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新所有已经完成的数据到管道，返回false意味着读线程在休眠，在这种情况下调用者需要唤醒读线程。  </span></span><br><span class="line"><span class="comment">// 批量刷新的机制， 写入批量后唤醒读线程；  </span></span><br><span class="line"><span class="comment">// 反悔机制 unwrite  </span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">flush</span><span class="params">()</span>;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Check whether item is available for reading.  </span></span><br><span class="line"><span class="comment">// 这里面有两个点，一个是检查是否有数据可读，一个是预取  </span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">check_read</span><span class="params">()</span>;  </span><br><span class="line"><span class="comment">//  Reads an item from the pipe. Returns false if there is no value.  </span></span><br><span class="line"><span class="comment">//  available.  </span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">read</span><span class="params">(T *value_)</span>  </span><br><span class="line"><span class="comment">//  Applies the function fn to the first elemenent in the pipe  </span></span><br><span class="line"><span class="comment">//  and returns the value returned by the fn.  </span></span><br><span class="line"><span class="comment">//  The pipe mustn&#x27;t be empty or the function crashes.  </span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">probe</span><span class="params">(<span class="type">bool</span> (*fn)(T &amp;))</span>  </span><br><span class="line">protected:  </span><br><span class="line">    <span class="comment">//  Allocation-efficient queue to store pipe items.  </span></span><br><span class="line">    <span class="comment">//  Front of the queue points to the first prefetched item, back of  </span></span><br><span class="line">    <span class="comment">//  the pipe points to last un-flushed item. Front is used only by  </span></span><br><span class="line">    <span class="comment">//  reader thread, while back is used only by writer thread.  </span></span><br><span class="line">    <span class="type">yqueue_t</span>&lt;T, N&gt; <span class="built_in">queue</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Points to the first un-flushed item. This variable is used  </span></span><br><span class="line">    <span class="comment">//  exclusively by writer thread.  </span></span><br><span class="line">    T *w; <span class="comment">//指向第一个未刷新的元素,只被写线程使用  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Points to the first un-prefetched item. This variable is used  </span></span><br><span class="line">    <span class="comment">//  exclusively by reader thread.  </span></span><br><span class="line">    T *r; <span class="comment">//指向第一个还没预提取的元素，只被读线程使用  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Points to the first item to be flushed in the future.  </span></span><br><span class="line">    T *f; <span class="comment">//指向下一轮要被刷新的一批元素中的第一个  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  The single point of contention between writer and reader thread.  </span></span><br><span class="line">    <span class="comment">//  Points past the last flushed item. If it is NULL,  </span></span><br><span class="line">    <span class="comment">//  reader is asleep. This pointer should be always accessed using  </span></span><br><span class="line">    <span class="comment">//  atomic operations.  </span></span><br><span class="line">    <span class="type">atomic_ptr_t</span>&lt;T&gt; c; <span class="comment">//读写线程共享的指针，指向每一轮刷新的起点（看代码的时候会详细说）。当c为空时，表示读线程睡眠（只会在读线程中被设置为空）  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Disable copying of ypipe object.  </span></span><br><span class="line">    <span class="type">ypipe_t</span>(<span class="type">const</span> <span class="type">ypipe_t</span> &amp;);  </span><br><span class="line">    <span class="type">const</span> <span class="type">ypipe_t</span> &amp;operator=(<span class="type">const</span> <span class="type">ypipe_t</span> &amp;);  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-1-3-ypipe-设计的目的"><a href="#3-1-3-ypipe-设计的目的" class="headerlink" title="3.1.3 ypipe 设计的目的"></a>3.1.3 ypipe 设计的目的</h5><p>为了批量读写，即用户可以自主的决定写了多少数据之后开启读。那因为有了生产者和消费者，就会涉及到同步的问题，ypipe 这里测试发现，用锁和条件变量性能最佳。</p>
<p>我们来分两种情况看一下读写的具体步骤。第一种情况：批量写，第一轮写：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/25f2df0f3e89ab7fb54b72dded3d477a.jpeg" alt=""></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/74a3fd96f4b8ba476cdd2d8dfc2ba91a.jpeg" alt=""></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/744db6107fb85f6bb3b5717cfe656c2b.jpeg" alt=""></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/01d3f4e079cfd35f8d96baf3064ca0f3.jpeg" alt=""></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/aa8a11244103b5c76e97978a0c41573a.jpeg" alt=""></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/f313bdad477455e3022a0dfb81ff8b08.jpeg" alt=""></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/0ee654722a652bce8e2ca2201f275367.jpeg" alt=""></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/bbffe5af3c1a786398b3c37b1fb6229d.jpeg" alt=""></p>
<p>在这个时候才能开始读数据：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/150f0a35e7c019e9cef60bdbbd7fb0a7.jpeg" alt=""></p>
<p>img</p>
<p>第二种方式：条件变量+互斥锁：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/7098a73568197431ecff5e7fea721c5e.jpeg" alt=""></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/c5ec6c74192109b4df1ed106348c105f.jpeg" alt=""></p>
<p><strong>flush 函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Flush all the completed items into the pipe. Returns false if  </span></span><br><span class="line"><span class="comment">//  the reader thread is sleeping. In that case, caller is obliged to  </span></span><br><span class="line"><span class="comment">//  wake the reader up before using the pipe again.  </span></span><br><span class="line"><span class="comment">// 刷新所有已经完成的数据到管道，返回false意味着读线程在休眠，在这种情况下调用者需要唤醒读线程。  </span></span><br><span class="line"><span class="comment">// 批量刷新的机制， 写入批量后唤醒读线程；  </span></span><br><span class="line"><span class="comment">// 反悔机制 unwrite  </span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">flush</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="comment">//  If there are no un-flushed items, do nothing.  </span></span><br><span class="line">    <span class="keyword">if</span> (w == f) <span class="comment">// 不需要刷新，即是还没有新元素加入  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Try to set &#x27;c&#x27; to &#x27;f&#x27;.  </span></span><br><span class="line">    <span class="comment">// read时如果没有数据可以读取则c的值会被置为NULL  </span></span><br><span class="line">    <span class="keyword">if</span> (c.cas(w, f) != w) <span class="comment">// 尝试将c设置为f，即是准备更新w的位置  </span></span><br><span class="line">    &#123;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//  Compare-and-swap was unseccessful because &#x27;c&#x27; is NULL.  </span></span><br><span class="line">        <span class="comment">//  This means that the reader is asleep. Therefore we don&#x27;t  </span></span><br><span class="line">        <span class="comment">//  care about thread-safeness and update c in non-atomic  </span></span><br><span class="line">        <span class="comment">//  manner. We&#x27;ll return false to let the caller know  </span></span><br><span class="line">        <span class="comment">//  that reader is sleeping.  </span></span><br><span class="line">        c.<span class="built_in">set</span>(f); <span class="comment">// 更新为新的f位置  </span></span><br><span class="line">        w = f;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//线程看到flush返回false之后会发送一个消息给读线程，这需要写业务去做处理  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 读端还有数据可读取  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//  Reader is alive. Nothing special to do now. Just move  </span></span><br><span class="line">        <span class="comment">//  the &#x27;first un-flushed item&#x27; pointer to &#x27;f&#x27;.  </span></span><br><span class="line">        w = f;             <span class="comment">// 更新f的位置  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>flush 的目的就是将改变 w 的值，同时改变 c 的值，这里有两种情况：</p>
<p>1、c 的值与 w 的值相等</p>
<p>说明队列的 w 值没有更新，不对队列的数据进行读取：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/2bc149fdcf4f068ab53d9ce99eac0461.jpeg" alt=""></p>
<p>这发生在 flush 第一次发生的时候以及 w 的值还未更新时，此时返回 true，表示队列不可读。</p>
<p>2、c 的值与 w 的值不相等</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/f93d96825f2aca4d148699608d9277a7.jpeg" alt=""></p>
<p>这发生在 c 在 w 位置后面，此时更新 c 与 w 的值，并返回 false，表示队列可读。</p>
<p><strong>write 函数</strong></p>
<p>write 函数相对简单:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Write an item to the pipe.  Don&#x27;t flush it yet. If incomplete is  </span></span><br><span class="line"><span class="comment">//  set to true the item is assumed to be continued by items  </span></span><br><span class="line"><span class="comment">//  subsequently written to the pipe. Incomplete items are neverflushed down the stream.  </span></span><br><span class="line"><span class="comment">// 写入数据，incomplete参数表示写入是否还没完成，在没完成的时候不会修改flush指针，即这部分数据不会让读线程看到。  </span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">write</span><span class="params">(<span class="type">const</span> T &amp;value_, <span class="type">bool</span> incomplete_)</span> &#123;  </span><br><span class="line">    <span class="comment">//  Place the value to the queue, add new terminator element.  </span></span><br><span class="line">    <span class="built_in">queue</span>.back() = value_;  </span><br><span class="line">    <span class="built_in">queue</span>.push();  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Move the &quot;flush up to here&quot; poiter.  </span></span><br><span class="line">    <span class="keyword">if</span> (!incomplete_)  </span><br><span class="line">    &#123;  </span><br><span class="line">        f = &amp;<span class="built_in">queue</span>.back(); <span class="comment">// 记录要刷新的位置  </span></span><br><span class="line">        <span class="comment">// printf(&quot;1 f:%p, w:%p\n&quot;, f, w);  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//  printf(&quot;0 f:%p, w:%p\n&quot;, f, w);  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>write 只更新 f 的位置。write 并不能决定该队列是否能读，因为 write 并不能改变 w 指针，如果要队列能读，需要 w 指针改变位置才行。</p>
<p>从 write 和 flush 可以看出，在更新 w 和 f 的时候并没有互斥的保护，所以该无锁队列的设计并不适合多线程场景。</p>
<p><strong>read 函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">check_read</span><span class="params">()</span> &#123;  </span><br><span class="line">     <span class="comment">//  Was the value prefetched already? If so, return.  </span></span><br><span class="line">     <span class="keyword">if</span> (&amp;<span class="built_in">queue</span>.front() != r &amp;&amp; r) <span class="comment">//判断是否在前几次调用read函数时已经预取数据了return true;  </span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line"></span><br><span class="line">     <span class="comment">//  There&#x27;s no prefetched value, so let us prefetch more values.  </span></span><br><span class="line">     <span class="comment">//  Prefetching is to simply retrieve the  </span></span><br><span class="line">     <span class="comment">//  pointer from c in atomic fashion. If there are no  </span></span><br><span class="line">     <span class="comment">//  items to prefetch, set c to NULL (using compare-and-swap).  </span></span><br><span class="line">     <span class="comment">// 两种情况  </span></span><br><span class="line">     <span class="comment">// 1. 如果c值和queue.front()， 返回c值并将c值置为NULL，此时没有数据可读  </span></span><br><span class="line">     <span class="comment">// 2. 如果c值和queue.front()， 返回c值，此时可能有数据度的去  </span></span><br><span class="line">     r = c.cas(&amp;<span class="built_in">queue</span>.front(), <span class="literal">NULL</span>); <span class="comment">//尝试预取数据  </span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//  If there are no elements prefetched, exit.  </span></span><br><span class="line">     <span class="comment">//  During pipe&#x27;s lifetime r should never be NULL, however,  </span></span><br><span class="line">     <span class="comment">//  it can happen during pipe shutdown when items are being deallocated.  </span></span><br><span class="line">     <span class="keyword">if</span> (&amp;<span class="built_in">queue</span>.front() == r || !r) <span class="comment">//判断是否成功预取数据  </span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line"></span><br><span class="line">     <span class="comment">//  There was at least one value prefetched.  </span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"> <span class="comment">//  Reads an item from the pipe. Returns false if there is no value.  </span></span><br><span class="line"> <span class="comment">//  available.  </span></span><br><span class="line"> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">read</span><span class="params">(T *value_)</span> &#123;  </span><br><span class="line">     <span class="comment">//  Try to prefetch a value.  </span></span><br><span class="line">     <span class="keyword">if</span> (!check_read())  </span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line"></span><br><span class="line">     <span class="comment">//  There was at least one value prefetched.  </span></span><br><span class="line">     <span class="comment">//  Return it to the caller.  </span></span><br><span class="line">     *value_ = <span class="built_in">queue</span>.front();  </span><br><span class="line">     <span class="built_in">queue</span>.pop();  </span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里也是有两种情况：</p>
<p>1、r 不为空且 r 不等于&amp;queue.front()</p>
<p>说明此时队列中有可读数据，直接读取即可。</p>
<p>2、r 指针指向队头元素(r==&amp;queue.front())或者 r 为空</p>
<p>说明队列中并没有可读的数据，此时将 r 指针更新成 c 的值，这个过程我们叫做预取。预取的指令就是:</p>
<p>r=c;</p>
<p>c 在 flush 的时候会被设置为 w。而 w 与&amp;queue.front()之间都是有距离的。这一段距离中间的数据就是预取数据，所以每次 read 都能取出一段数据。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/9986ba9fe095d4ceb31db780acfdc8eb.jpeg" alt=""></p>
<p>当&amp;queue.front() == c 时，代表数据被取完了，这时把 c 指向 NULL，接着读线程会睡眠，这也是给写线程检查读线程是否睡眠的标志。</p>
<p>我们可以测试一下结果，对一个数据加 200 万次，分别用环形数组、链表、互斥锁、ypipe 队列分别是什么样的性能。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/37503aef6f9421eab6798158fbb3185a.jpeg" alt=""></p>
<p>通过测试发现在一读一写的情况下，ypipe 的优势是非常大的。</p>
<p>那多读多写的场景呢？</p>
<h3 id="四、多读多写的无锁队列实现"><a href="#四、多读多写的无锁队列实现" class="headerlink" title="四、多读多写的无锁队列实现"></a><strong>四、多读多写的无锁队列实现</strong></h3><p>上面我们介绍的是一读一写的场景，用 ypipe 的方式会性能比较快，但是 ypipe 不适用于多读多写的场景，因为在读的时候是没有对 r 指针加锁，在写的时候也没有对 w 指针加锁。</p>
<p>多读多写的线程安全队列有以下几种实现方式：</p>
<p>1、互斥锁</p>
<p>2、互斥锁+条件变量：BlockQueue</p>
<p>3、内存屏障：SimpleLockFreeQueue</p>
<p>4、CAS 原子操作：ArrayLockFreeQueue（也可以理解成 RingBuffer）</p>
<p>其中互斥锁的性能是几种方式里面性能最低的，没什么讲的必要，这里就不对比这种实现方式了。</p>
<h4 id="4-1-RingBuffer-ArrayLockFreeQueue"><a href="#4-1-RingBuffer-ArrayLockFreeQueue" class="headerlink" title="4.1 RingBuffer(ArrayLockFreeQueue)"></a>4.1 RingBuffer(ArrayLockFreeQueue)</h4><p>下面我们来看基于循环数组的无锁队列，也就是 RingBuffer 如何解决多线程竞争的问题。</p>
<p>首先看下 RingBuffer 的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename ELEM_T, QUEUE_INT Q_SIZE = ARRAY_LOCK_FREE_Q_DEFAULT_SIZE&gt;  </span><br><span class="line">class ArrayLockFreeQueue &#123;  </span><br><span class="line">public:  </span><br><span class="line"> </span><br><span class="line">    ArrayLockFreeQueue();  </span><br><span class="line">    virtual ~ArrayLockFreeQueue();  </span><br><span class="line"> </span><br><span class="line">    QUEUE_INT <span class="title function_">size</span><span class="params">()</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="type">bool</span> <span class="title function_">enqueue</span><span class="params">(<span class="type">const</span> ELEM_T &amp;a_data)</span>;<span class="comment">//入队列  </span></span><br><span class="line"> </span><br><span class="line">    <span class="type">bool</span> <span class="title function_">dequeue</span><span class="params">(ELEM_T &amp;a_data)</span>;<span class="comment">//出队列  </span></span><br><span class="line"> </span><br><span class="line">    <span class="type">bool</span> <span class="title function_">try_dequeue</span><span class="params">(ELEM_T &amp;a_data)</span>;  </span><br><span class="line"> </span><br><span class="line">private:  </span><br><span class="line"> </span><br><span class="line">    ELEM_T m_thequeue[Q_SIZE];  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">volatile</span> QUEUE_INT m_count;  </span><br><span class="line">    <span class="keyword">volatile</span> QUEUE_INT m_writeIndex;  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">volatile</span> QUEUE_INT m_readIndex;  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">volatile</span> QUEUE_INT m_maximumReadIndex;  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">inline</span> QUEUE_INT <span class="title function_">countToIndex</span><span class="params">(QUEUE_INT a_count)</span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>m_count: // 队列的元素个数</p>
<p>我们先来看三种不同的下标：</p>
<ul>
<li><p>m_writeIndex: // 新元素入队列时存放位置在数组中的下标；</p>
</li>
<li><p>m_readIndex: // 下一个出列的元素在数组中的下标；</p>
</li>
<li><p>m_maximumReadIndex: // 这个值非常关键，表示最后一个已经完成入队列操作的元素在数组中的下标。如果它的值跟 m_writeIndex 不一致，表明有写请求尚未完成。这意味着，有写请求成功申请了空间但数据还没完全写进队列。所以如果有线程要读取，必须要等到写线程将数据完全写入到队列之后。</p>
</li>
</ul>
<p>以上三种不同的下标都是必须的，因为队列允许任意数量的生产者和消费者围绕着它工作。已经存在一种基于循环数组的无锁队列，使得唯一的生产者和唯一的消费者可以良好的工作。它的实现相当简洁非常值得阅读。该程序使用 gcc 内置的__sync_bool_compare_and_swap，但重新做了宏定义封装。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CAS(a_ptr, a_oldVal, a_newVal) __sync_bool_compare_and_swap(a_ptr, a_oldVal, a_newVal)  </span></span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/d8950b94a92bcf233f29192e4c4d306c.jpeg" alt=""></p>
<p>队列已满判断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(m_writeIndex+<span class="number">1</span>) % Q_SIZE == m_readIndex  </span><br></pre></td></tr></table></figure>

<p>对应代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">countToIndex(currentWriteIndex + <span class="number">1</span>) == countToIndex(currentReadIndex)  </span><br></pre></td></tr></table></figure>

<p>队列为空判断：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_readIndex == m_maximumReadIndex</span><br></pre></td></tr></table></figure>

<p>该 RingBuffer 的重点主要是以下四个方面的问题：</p>
<p>1、多线程写入的时候，m_writeIndex 如何更新?</p>
<p>2、m_maximumReadIndex 这个变量为什么会需要？它有什么作用？</p>
<p>3、多线程读的恶时候，m_readIndex 如何更新？</p>
<p>4、m_maximumReadIndex 在什么时候改变？</p>
<h5 id="4-2-enqueue-入队列"><a href="#4-2-enqueue-入队列" class="headerlink" title="4.2 enqueue 入队列"></a>4.2 enqueue 入队列</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename ELEM_T, QUEUE_INT Q_SIZE&gt;  </span><br><span class="line"><span class="type">bool</span> ArrayLockFreeQueue&lt;ELEM_T, Q_SIZE&gt;::enqueue(<span class="type">const</span> ELEM_T &amp;a_data) &#123;  </span><br><span class="line">    QUEUE_INT currentWriteIndex;        <span class="comment">// 获取写指针的位置  </span></span><br><span class="line">    QUEUE_INT currentReadIndex;  </span><br><span class="line">    <span class="comment">// 1. 获取可写入的位置  </span></span><br><span class="line">    <span class="keyword">do</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        currentWriteIndex = m_writeIndex;  </span><br><span class="line">        currentReadIndex = m_readIndex;  </span><br><span class="line">        <span class="keyword">if</span>(countToIndex(currentWriteIndex + <span class="number">1</span>) ==  </span><br><span class="line">            countToIndex(currentReadIndex))  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// 队列已经满了  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 目的是为了获取一个能写入的位置  </span></span><br><span class="line">    &#125; <span class="keyword">while</span>(!CAS(&amp;m_writeIndex, currentWriteIndex, (currentWriteIndex+<span class="number">1</span>)));  </span><br><span class="line">    <span class="comment">// 获取写入位置后 currentWriteIndex 是一个临时变量，保存我们写入的位置  </span></span><br><span class="line">    <span class="comment">// We know now that this index is reserved for us. Use it to save the data  </span></span><br><span class="line">    m_thequeue[countToIndex(currentWriteIndex)] = a_data;  <span class="comment">// 把数据更新到对应的位置  </span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 2. 更新可读的位置，按着m_maximumReadIndex+1的操作  </span></span><br><span class="line">    <span class="comment">// update the maximum read index after saving the data. It wouldn&#x27;t fail if there is only one thread  </span></span><br><span class="line">    <span class="comment">// inserting in the queue. It might fail if there are more than 1 producer threads because this  </span></span><br><span class="line">    <span class="comment">// operation has to be done in the same order as the previous CAS  </span></span><br><span class="line">    <span class="keyword">while</span>(!CAS(&amp;m_maximumReadIndex, currentWriteIndex, (currentWriteIndex + <span class="number">1</span>)))  </span><br><span class="line">    &#123;  </span><br><span class="line">         <span class="comment">// this is a good place to yield the thread in case there are more  </span></span><br><span class="line">        <span class="comment">// software threads than hardware processors and you have more  </span></span><br><span class="line">        <span class="comment">// than 1 producer thread  </span></span><br><span class="line">        <span class="comment">// have a look at sched_yield (POSIX.1b)  </span></span><br><span class="line">        sched_yield();      <span class="comment">// 当线程超过cpu核数的时候如果不让出cpu导致一直循环在此。  </span></span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    AtomicAdd(&amp;m_count, <span class="number">1</span>);  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line"> </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>图示（非常重要）：</p>
<p>以下插图展示了对队列执行操作时各个下标时如何变化的。如果一个位置被标记为 X，表示这个位置里面存放了数据。空白表示位置是空的。对于下图的情况，队列中存放了两个元素。WriteIndex 指示的位置是新元素将会被插入的位置。ReadIndex 指向的位置中的元素将会在下一次 pop 操作中被弹出。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/598e27110c2d1c56f1c2b2e4447e442d.jpeg" alt=""></p>
<p>当生产者准备将数据插入到队列中时，它首先通过增加 WriteIndex 的值来申请空间。MaximumReadIndex 指向最后一个存放有效数据的位置（也就是实际的读的队列尾）。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/1e59f606860004f76521a2e09505d888.jpeg" alt=""></p>
<p>一旦空间的申请完成，生产者就可以将数据拷贝到刚刚申请的位置中。完成之后增加 MaximumReadIndex 使得它与 WriteIndex 一致。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/93825b87f77c8c20cd58f0044080309a.jpeg" alt=""></p>
<p>现在队列中有 3 个元素，接着又有一个生产者尝试向队列中插入元素。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/eb677ecad74451051f93e3cac0255580.jpeg" alt=""></p>
<p>在第一个生产者完成数据拷贝之前，又有另外一个生产者申请了一个新的空间准备拷贝元素。现在有两个生产者同时向队列插入数据。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/822881ff0e0f71ae00f1dd7e3c51d138.jpeg" alt=""></p>
<p>现在生产者开始拷贝数据，在完成拷贝之后，对 MaximumReadIndex 的递增操作必须严格遵循一个顺序：第一个生产者线程首先递增 MaximumReadIndex，接着才轮到第二个生产者。这个顺序必须被严格遵守的原因是，我们必须保证数据被完全拷贝到队列之后才允许消费者线程将其出列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(!CAS(&amp;m_maximumReadIndex, currentWriteIndex, (currentWriteIndex + 1))&#123;  </span><br><span class="line">sched_yield();      // 当线程超过cpu核数的时候如果不让出cpu导致一直循环在此。  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/dfc114a5343019f9c7e9f593818e5d6b.jpeg" alt=""></p>
<p>第一个生产者完成了数据拷贝，并对 MaximumReadIndex 完成了递增，现在第二个生产者可以递增 MaximumReadIndex 了。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/b389235fe59539b240294fceb22c0ea1.jpeg" alt=""></p>
<p>第二个生产者完成了对 MaximumReadIndex 的递增，现在队列中有 5 个元素。</p>
<h5 id="4-3-dequeue-出队列"><a href="#4-3-dequeue-出队列" class="headerlink" title="4.3 dequeue 出队列"></a>4.3 dequeue 出队列</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename ELEM_T, QUEUE_INT Q_SIZE&gt;  </span><br><span class="line"><span class="type">bool</span> ArrayLockFreeQueue&lt;ELEM_T, Q_SIZE&gt;::dequeue(ELEM_T &amp;a_data) &#123;  </span><br><span class="line">    QUEUE_INT currentMaximumReadIndex;  </span><br><span class="line">    QUEUE_INT currentReadIndex;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">do</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">         <span class="comment">// to ensure thread-safety when there is more than 1 producer thread  </span></span><br><span class="line">        <span class="comment">// a second index is defined (m_maximumReadIndex)  </span></span><br><span class="line">        currentReadIndex = m_readIndex;  </span><br><span class="line">        currentMaximumReadIndex = m_maximumReadIndex;  </span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span>(countToIndex(currentReadIndex) ==  </span><br><span class="line">            countToIndex(currentMaximumReadIndex))      <span class="comment">// 如果不为空，获取到读索引的位置  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">// the queue is empty or  </span></span><br><span class="line">            <span class="comment">// a producer thread has allocate space in the queue but is  </span></span><br><span class="line">            <span class="comment">// waiting to commit the data into it  </span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// retrieve the data from the queue  </span></span><br><span class="line">        a_data = m_thequeue[countToIndex(currentReadIndex)]; <span class="comment">// 从临时位置读取的  </span></span><br><span class="line">   </span><br><span class="line">        <span class="comment">// try to perfrom now the CAS operation on the read index. If we succeed  </span></span><br><span class="line">        <span class="comment">// a_data already contains what m_readIndex pointed to before we  </span></span><br><span class="line">        <span class="comment">// increased it  </span></span><br><span class="line">        <span class="keyword">if</span>(CAS(&amp;m_readIndex, currentReadIndex, (currentReadIndex + <span class="number">1</span>)))  </span><br><span class="line">        &#123;  </span><br><span class="line">            AtomicSub(&amp;m_count, <span class="number">1</span>); <span class="comment">// 真正读取到了数据，元素-1  </span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="literal">true</span>);  </span><br><span class="line">   </span><br><span class="line">    assert(<span class="number">0</span>);  </span><br><span class="line">     <span class="comment">// Add this return statement to avoid compiler warnings  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以下插入展示了元素出列的时候各种下标是如何变化的，队列中初始有 2 个元素。WriteIndex 指示的位置是新元素将会被插入的位置。ReadIndex 指向的位置中的元素将会在下一次 pop 操作中被弹出。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/9ce2f3c4508a2d2e911f83bdae754d00.jpeg" alt=""></p>
<p>消费者线程拷贝数组 ReadIndex 位置的元素，然后尝试 CAS 操作将 ReadIndex 加 1.如果操作成功消费者成功地将数据出列。因为 CAS 操作是原子的，所以只有唯一的线程可以在同一时刻更新 ReadIndex 的值。</p>
<p>如果操作失败，读取新的 ReadIndex 的值，重复以上操作(copy 数据，CAS)。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/29fd7cb51d74d66bf56136f01ba6b265.jpeg" alt=""></p>
<p>现在又有一个消费者将元素出列，队列变成空。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/733a4637cd48fb05bd7a415e06af8837.jpeg" alt=""></p>
<p>现在有一个生产者正在向队列中添加元素。它已经成功的申请了空间，但尚未完成数据拷贝。任何其他企图从队列中移除元素的消费者都会发现队列非空(因为 writeIndex 不等于 readIndex)。但它不能读取 readIndex 所指向位置中的数据，因为 readIndex 与 MaximumReadIndex 相等。这个时候读数据失败，需要等到生产者完成数据拷贝增加 MaximumReadIndex 的值才可以读。</p>
<p>当生产者完成数据拷贝，队列的大小是 1，消费者线程就可以读取这个数据了。</p>
<h5 id="4-4-yielding-处理器的必要性"><a href="#4-4-yielding-处理器的必要性" class="headerlink" title="4.4 yielding 处理器的必要性"></a>4.4 yielding 处理器的必要性</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(!CAS(&amp;m_maximumReadIndex, currentWriteIndex, (currentWriteIndex + 1))) &#123;  </span><br><span class="line">    // this is a good place to yield the thread in case there are more  </span><br><span class="line">    // software threads than hardware processors and you have more  </span><br><span class="line">    // than 1 producer thread  </span><br><span class="line">    // have a look at sched_yield (POSIX.1b)  </span><br><span class="line">    sched_yield();      // 当线程超过cpu核数的时候如果不让出cpu导致一直循环在此。  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 enqueue 的第二个 CAS 里面有一个 sched_yield()来主动让出处理器的操作，对于一个声称无锁的算法而言，这个调用看起来有点儿奇怪。多线程环境下影响性能的其中一个因素就是 Cache 损坏。而产生 Cache 损坏的一种情况就是一个线程被抢占，操作系统需要保存被抢占线程的上下文，然后被选中作为下一个调度线程的上下文载入。此时 Cache 中缓存的数据都会失效，因为它是被抢占线程的数据而不是新线程的数据。</p>
<p>无锁算法和通过阻塞机制同步的算法的一个主要区别在于无锁算法不会阻塞在线程同步上。那这里的让出 CPU，与阻塞在线程同步上有啥区别？为什么不直接自旋？</p>
<p>首先说下 sched_yield 的必要性：sched_yield 的调用与有多少个生产者线程在并发地往队列中存放数据有关：每个生产者线程所执行的 CAS 操作都必须严格遵循 FIFO 次序,一个用于申请空间,另一个用于通知消费者数据已经写入完成可以被读取了.如果我们的应用程序只有唯一的生产者这个操作队列，sched_yield 将永远没有机会被调用，因为 enqueue 的第二个 CAS 操作永远不会失败。因为一个生产者的情况下没人能破坏生产者执行这两个 CAS 操作的 FIFO 顺序。</p>
<p>而对于多个生产者线程往队列中存放数据的时候，问题就出现了。概括来说，一个生产者通过第 1 个 CAS 操作申请空间,然后将数据写入到申请到的空间中,然后执行第 2 个 CAS 操作通知消费者数据准备完毕可供读取了.这第 2 个 CAS 操作必须遵循 FIFO 顺序,也就是说,如果 A 线程第首先执行完第一个 CAS 操作,那么它也要第 1 个执行完第 2 个 CAS 操作,如果 A 线程在执行完第一个 CAS 操作之后停止,然后 B 线程执行完第 1 个 CAS 操作,那么 B 线程将无法完成第 2 个 CAS 操作,因为它要等待 A 先完成第 2 个 CAS 操作.而这就是问题产生的根源.让我们考虑如下场景,3 个消费者线程和 1 个消费者线程:</p>
<ol>
<li><p>线程 1,2,3 按顺序调用第 1 个 CAS 操作申请了空间.那么它们完成第 2 个 CAS 操作的顺序也应该与这个顺序一致,1,2,3；</p>
</li>
<li><p>线程 2 首先尝试执行第 2 个 CAS,但它会失败,因为线程 1 还没完成它的第 2 此 CAS 操作呢.同样对于线程 3 也是一样的；</p>
</li>
<li><p>线程 2 和 3 将会不断的调用它们的第 2 个 CAS 操作,直到线程 1 完成它的第 2 个 CAS 操作为止；</p>
</li>
<li><p>线程 1 最终完成了它的第 2 个 CAS,现在线程 3 必须等线程 2 先完成它的第 2 个 CAS；</p>
</li>
<li><p>线程 2 也完成了,最终线程 3 也完成。</p>
</li>
</ol>
<p>在上面的场景中,生产者可能会在第 2 个 CAS 操作上自旋一段时间,用于等待先于它执行第 1 个 CAS 操作的线程完成它的第 2 次 CAS 操作.在一个物理处理器数量大于操作队列线程数量的系统上,这不会有太严重的问题:因为每个线程都可以分配在自己的处理器上执行,它们最终都会很快完成各自的第 2 次 CAS 操作.虽然算法导致线程处理忙等状态,但这正是我们所期望的,因为这使得操作更快的完成.也就是说在这种情况下我们是不需要 sche_yield()的,它完全可以从代码中删除。</p>
<p>但是,在一个物理处理器数量少于线程数量的系统上,sche_yield()就变得至关重要了.让我们再次考查上面 3 个线程的场景,当线程 3 准备向队列中插入数据:如果线程 1 在执行完第 1 个 CAS 操作,在执行第 2 个 CAS 操作之前被抢占,那么线程 2,3 就会一直在它们的第 2 个 CAS 操作上忙等(它们忙等,不让出处理器,线程 1 也就没机会执行,它们就只能继续忙等),直到线程 1 重新被唤醒,完成它的第 2 个 CAS 操作。这就是需要 sche_yield()的场合了,操作系统应该避免让线程 2,3 处于忙等状态.它们应该尽快的让出处理器让线程 1 执行,使得线程 1 可以把它的第 2 个 CAS 操作完成.这样线程 2 和 3 才能继续完成它们的操作。</p>
<p>也就是说，如果不适用 sched_yield，一直自旋，那么可能多个线程同时阻塞在第二个 CAS 那儿。</p>
<h5 id="4-5-多读多写的-RingBuffer-存在的问题"><a href="#4-5-多读多写的-RingBuffer-存在的问题" class="headerlink" title="4.5 多读多写的 RingBuffer 存在的问题"></a><strong>4.5</strong> 多读多写的 RingBuffer 存在的问题</h5><p>1、多于一个生产者线程性能提升不明显</p>
<p>如果有多于一个的生产者线程,那么将它们很可能花费大量的时间用于等待更新 MaximumReadIndex(第 2 个 CAS).这个队列最初的设计场景是满足单一消费者,所以不用怀疑在多生产者的情形下会比单一生产者有大幅的性能下降。</p>
<p>另外如果你只打算将此队列用于单一生产者的场合,那么第 2 个 CAS 操作可以去除.同样 m_maximumReadIndex 也可以一同被移除了,所有对 m_maximumReadIndex 的引用都改成 m_writeIndex.所以,在这样的场合下 push 和 pop 可以被改写如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename ELEM_T&gt;  </span><br><span class="line"><span class="type">bool</span> ArrayLockFreeQueue&lt;ELEM_T&gt;::push(<span class="type">const</span> ELEM_T &amp;a_data) &#123;  </span><br><span class="line">    <span class="type">uint32_t</span> currentReadIndex;  </span><br><span class="line">    <span class="type">uint32_t</span> currentWriteIndex;  </span><br><span class="line"></span><br><span class="line">    currentWriteIndex = m_writeIndex;  </span><br><span class="line">    currentReadIndex  = m_readIndex;  </span><br><span class="line">    <span class="keyword">if</span> (countToIndex(currentWriteIndex + <span class="number">1</span>) ==  </span><br><span class="line">        countToIndex(currentReadIndex)) &#123;  </span><br><span class="line">        <span class="comment">// the queue is full  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// save the date into the q  </span></span><br><span class="line">    m_theQueue[countToIndex(currentWriteIndex)] = a_data;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// increment atomically write index. Now a consumer thread can read  </span></span><br><span class="line">    <span class="comment">// the piece of data that was just stored  </span></span><br><span class="line">    AtomicAdd(&amp;m_writeIndex, <span class="number">1</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">template &lt;typename ELEM_T&gt;  </span><br><span class="line"><span class="type">bool</span> ArrayLockFreeQueue&lt;ELEM_T&gt;::pop(ELEM_T &amp;a_data) &#123;  </span><br><span class="line">    <span class="type">uint32_t</span> currentMaximumReadIndex;  </span><br><span class="line">    <span class="type">uint32_t</span> currentReadIndex;  </span><br><span class="line">    <span class="keyword">do</span> &#123;  </span><br><span class="line">        <span class="comment">// m_maximumReadIndex doesn&#x27;t exist when the queue is set up as  </span></span><br><span class="line">        <span class="comment">// single-producer. The maximum read index is described by the current  </span></span><br><span class="line">        <span class="comment">// write index  </span></span><br><span class="line">        currentReadIndex        = m_readIndex;  </span><br><span class="line">        currentMaximumReadIndex = m_writeIndex;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (countToIndex(currentReadIndex) ==  </span><br><span class="line">            countToIndex(currentMaximumReadIndex)) &#123;  </span><br><span class="line">            <span class="comment">// the queue is empty or  </span></span><br><span class="line">            <span class="comment">// a producer thread has allocate space in the queue but is  </span></span><br><span class="line">            <span class="comment">// waiting to commit the data into it  </span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// retrieve the data from the queue  </span></span><br><span class="line">        a_data = m_theQueue[countToIndex(currentReadIndex)];  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// try to perfrom now the CAS operation on the read index. If we succeed  </span></span><br><span class="line">        <span class="comment">// a_data already contains what m_readIndex pointed to before we  </span></span><br><span class="line">        <span class="comment">// increased it  </span></span><br><span class="line">        <span class="keyword">if</span> (CAS(&amp;m_readIndex, currentReadIndex, (currentReadIndex + <span class="number">1</span>)))  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// it failed retrieving the element off the queue. Someone else must  </span></span><br><span class="line">        <span class="comment">// have read the element stored at countToIndex(currentReadIndex)  </span></span><br><span class="line">        <span class="comment">// before we could perform the CAS operation  </span></span><br><span class="line">  </span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="number">1</span>); <span class="comment">// keep looping to try again!  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Something went wrong. it shouldn&#x27;t be possible to reach here  </span></span><br><span class="line">    assert(<span class="number">0</span>);  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Add this return statement to avoid compiler warnings  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是如果是单读单写的场景，没有必要用这个无锁队列，可以看以上单读单写的无锁队列。</p>
<p><strong>2、与智能指针一起使用，内存无法得到释放</strong></p>
<p>如果你打算用这个队列来存放智能指针对象.需要注意,将一个智能指针存入队列之后,如果它所占用的位置没有被另一个智能指针覆盖,那么它所指向的内存是无法被释放的(因为它的引用计数器无法下降为 0).这对于一个操作频繁的队列来说没有什么问题,但是程序员需要注意的是,一旦队列被填满过一次那么应用程序所占用的内存就不会下降,即使队列被清空.除非自己做改动，每次 pop 手动 delete。</p>
<p><strong>3、计算队列的大小存在 ABA 问题</strong></p>
<p>size 函数可能会返回一个不正确的值,size 的实现如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename ELEM_T&gt;  </span><br><span class="line"><span class="keyword">inline</span> <span class="type">uint32_t</span> ArrayLockFreeQueue&lt;ELEM_T&gt;::size() &#123;  </span><br><span class="line">    <span class="type">uint32_t</span> currentWriteIndex = m_writeIndex;  </span><br><span class="line">    <span class="type">uint32_t</span> currentReadIndex  = m_readIndex;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (currentWriteIndex &gt;= currentReadIndex) &#123;  </span><br><span class="line">        <span class="keyword">return</span> (currentWriteIndex - currentReadIndex);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> (m_totalSize + currentWriteIndex - currentReadIndex);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>下面的场景描述了 size 为何会返回一个不正确的值:</p>
<ol>
<li><p>当 currentWriteIndex = m_writeIndex 执行之后,m_writeIndex=3,m_readIndex = 2 那么实际 size 是 1；</p>
</li>
<li><p>之后操作线程被抢占,且在它停止运行的这段时间内,有 2 个元素被插入和从队列中移除。所以 m_writeIndex=5,m_readIndex = 4,而 size 还是 1；</p>
</li>
<li><p>现在被抢占的线程恢复执行,读取 m_readIndex 值,这个时候 currentReadIndex=4,currentWriteIndex=3；</p>
</li>
<li><p>currentReadIndex &gt; currentWriteIndex’所以 m_totalSize + currentWriteIndex - currentReadIndex`被返回,这个值意味着队列几乎是满的,而实际上队列几乎是空的。</p>
</li>
</ol>
<p>实际上也就是 ABA 的一个场景。与本文一起上传的代码中包含了处理这个问题的解决方案。</p>
<p>解决方案：添加一个用于保存队列中元素数量的成员 count.这个成员可以通过 AtomicAdd/AtomicSub 来实现原子的递增和递减。</p>
<p>但需要注意的是这增加了一定开销,因为原子递增,递减操作比较昂贵也很难被编译器优化。</p>
<p>例如,在 core 2 duo E6400 2.13 Ghz 的机器上,单生产者单消费者,队列数组的初始大小是 1000,测试执行 10,000k 次的插入,没有 count 成员的版本用时 2.64 秒,而维护了 count 成员的版本用时 3.42 秒.而对于 2 消费者,1 生产者的情况,没有 count 成员的版本用时 3.98 秒,维护 count 的版本用时 5.15 秒。</p>
<p>这也就是为什么我把是否启用此成员变量的选择交给实际的使用者.使用者可以根据自己的使用场合选择是否承受额外的运行时开销。</p>
<p>在 array_lock_free_queue.h 中有一个名为 ARRAY_LOCK_FREE_Q_KEEP_REAL_SIZE 的宏变量,如果它被定义那么将启用 count 变量,否则将 size 函数将有可能返回不正确的值。</p>
<h5 id="4-6-多读多写-RingBuffer-的性能"><a href="#4-6-多读多写-RingBuffer-的性能" class="headerlink" title="4.6 多读多写 RingBuffer 的性能"></a><strong>4.6</strong> 多读多写 RingBuffer 的性能</h5><p><strong>无锁</strong> <strong>vs</strong> <strong>阻塞队列</strong></p>
<p>并发的插入和移除 100W 元素所花费的时间(越小越好,队列的数组大小初始为 16384)。在单生产者的情况下,无锁队列战胜了阻塞队列.而随着生产者数量的增加,无锁队列的效率迅速下降。因为在多个生产者的情况下，第 2 个 CAS 将对性能产生影响。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/3f29ccc3f38a37b777c2101b5737ae91.jpeg" alt=""></p>
<p>然后我们来看代码中的情况：</p>
<p>再来看看消费者线程数量对性能的影响。</p>
<p>1、一个生产者线程</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/ab7d2f8a751d17975a19d6c6c5d4ba32.jpeg" alt=""></p>
<p>2、两个生产者</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/efe92c22f2657d0966fc5e413cc49813.jpeg" alt=""></p>
<p>3、三个生产者</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/684427c77dfd1b078f03c91718b908ba.jpeg" alt=""></p>
<h5 id="4-7-RingBuffer-结论"><a href="#4-7-RingBuffer-结论" class="headerlink" title="4.7 RingBuffer 结论"></a>4.7 RingBuffer 结论</h5><p>1、CAS 操作是原子的，线程并行执行 push/pop 不会导致死锁；</p>
<p>2、多生产者同时向队列 push 数据的时候不会将数据写入到同一个位置,产生数据覆盖；</p>
<p>3、多消费者同时执行 pop 不会导致一个元素被出列多于 1 次；</p>
<p>4、线程不能将数据 push 进已经满的队列中,不能从空的队列中 pop 元素；</p>
<p>5、push 和 pop 都没有 ABA 问题。</p>
<p>但是，虽然这个队列是线程安全的,但是在多生产者线程的环境下它的性能还是不如阻塞队列.因此,在符合下述条件的情况下可以考虑使用这个队列来代替阻塞队列:</p>
<p>1、只有一个生产者线程；</p>
<p>2、只有一个频繁操作队列的生产者,但偶尔会有其它生产者向队列 push 数据；</p>
<p>在 reactor 网络框架中，如果只有一个 reactor 在处理 client 的话，用数组实现的 RingBuffer 来存储消息是比较合适的。</p>
<h5 id="4-8-四种线程安全队列实现性能对比"><a href="#4-8-四种线程安全队列实现性能对比" class="headerlink" title="4.8 四种线程安全队列实现性能对比"></a>4.8 四种线程安全队列实现性能对比</h5><p>互斥锁队列 vs 互斥锁+条件变量队列 vs 内存屏障链表 vs RingBuffer CAS 实现。</p>
<h5 id="1、4-写-1-读"><a href="#1、4-写-1-读" class="headerlink" title="1、4 写 1 读"></a>1、4 写 1 读</h5><p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/f685973c7103b3f66e733a6d5cfd33df.jpeg" alt=""></p>
<h5 id="2、4-写-4-读"><a href="#2、4-写-4-读" class="headerlink" title="2、4 写 4 读"></a>2、4 写 4 读</h5><p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/d30d3cd79667ed4144867d8a4e02645b.jpeg" alt=""></p>
<h5 id="3、1-写-4-读"><a href="#3、1-写-4-读" class="headerlink" title="3、1 写 4 读"></a>3、1 写 4 读</h5><p><img src= "/img/loading.gif" data-lazy-src="https://image.lemongo97.com/3564ee3bbb46513d96f9193d55cbf2a9.jpeg" alt=""></p>
<p>可以发现 RingBuffer 的实现性能在几个场景中都是比较好的，但是相对而言，在 1 写 4 读的场景下性能是最明显的，几乎是内存屏障的 3 倍性能了。</p>
<p>为什么链表的方式性能相对 BlockQueue 没有很大的提升呢？</p>
<p>1、链表的方式需要不断的申请和释放元素。当然，用内存池可以适当改善这个影响，但是内存池在分配内存与释放内存的时候也会涉及到线程间的数据竞争，所以用链表的方式性能相对提升不多。</p>
<p>入队：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename U&gt;  </span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">enqueue</span><span class="params">(U &amp;&amp;item)</span> &#123;  </span><br><span class="line">  <span class="type">idx_t</span> nodeIdx = allocate_node_for(<span class="built_in">std</span>::forward&lt;U&gt;(item));  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> tail_ = tail.load(<span class="built_in">std</span>::memory_order_relaxed);  </span><br><span class="line">  <span class="keyword">while</span> (!tail.compare_exchange_weak(tail_, nodeIdx, <span class="built_in">std</span>::memory_order_release, <span class="built_in">std</span>::memory_order_relaxed))  </span><br><span class="line">    <span class="keyword">continue</span>;  </span><br><span class="line">  get_node_at(tail_)-&gt;next.store(nodeIdx, <span class="built_in">std</span>::memory_order_release);  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>出队：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">try_dequeue</span><span class="params">(T &amp;item)</span> &#123;  </span><br><span class="line">……</span><br><span class="line">  add_node_to_free_list(head_, headNode);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、链表需要不断地去更新头节点和尾节点指针的位置，在一个 while 循环里面反复去执行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!tail.compare_exchange_weak(tail_, nodeIdx, <span class="built_in">std</span>::memory_order_release, <span class="built_in">std</span>::memory_order_relaxed))  </span><br><span class="line">  <span class="keyword">continue</span>;  </span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.codeproject.com/Articles/43510/Lock-Free-Single-Producer-Single-Consumer-Circular">https://www.codeproject.com/Articles/43510/Lock-Free-Single-Producer-Single-Consumer-Circular</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33985732">https://zhuanlan.zhihu.com/p/33985732</a></p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/HdP5NcQIdzfznGwcHLTvMw">https://mp.weixin.qq.com/s/HdP5NcQIdzfznGwcHLTvMw</a>，如有侵权，请联系删除。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">juliatliu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/HdP5NcQIdzfznGwcHLTvMw">https://mp.weixin.qq.com/s/HdP5NcQIdzfznGwcHLTvMw</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.lemongo97.com" target="_blank">LemonGo97のBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://image.lemongo97.com/all_default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/d422a896/"><img class="prev-cover" data-lazy-src="https://image.lemongo97.com/default_cover_1.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis 知识总结</div></div></a></div><div class="next-post pull-right"><a href="/posts/44d9a313/"><img class="next-cover" data-lazy-src="https://image.lemongo97.com/all_default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">异步编程指北</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By LemonGo97</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/instant.page/5.1.0/instantpage.min.js" type="module" defer></script><script src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.3.1/lazyload.iife.min.js" async></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'w7vT5VedMPyGHyDYppcacmtw-gzGzoHsz',
      appKey: 'YxBl09Aj50g5Ld621aydI4pz',
      placeholder: '来和大家一起讨论吧！',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div></div></body></html>