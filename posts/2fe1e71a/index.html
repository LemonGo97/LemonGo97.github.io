<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Golang与Java全方位对比总结 | LemonGo97のBlog</title><meta name="description" content="作者：xindong  本文针对Golang与Java的基础语法、结构体函数、异常处理、并发编程及垃圾回收、资源消耗等各方面的差异进行对比总结，有不准确、不到位的地方还请大家不吝赐教。  一 、基础语法Golang: 编码风格及可见域规则严格且简单；Java: 来说层次接口清晰、规范，主要表现有以下这些。 1、变量a、变量声明及使用在Java中：变量可以声明了却不使用 1234public sta"><meta name="keywords" content="Golang"><meta name="author" content="LemonGo97"><meta name="copyright" content="LemonGo97"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.lemongo97.com/posts/2fe1e71a/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><meta property="og:type" content="article"><meta property="og:title" content="Golang与Java全方位对比总结"><meta property="og:url" content="https://blog.lemongo97.com/posts/2fe1e71a/"><meta property="og:site_name" content="LemonGo97のBlog"><meta property="og:description" content="作者：xindong  本文针对Golang与Java的基础语法、结构体函数、异常处理、并发编程及垃圾回收、资源消耗等各方面的差异进行对比总结，有不准确、不到位的地方还请大家不吝赐教。  一 、基础语法Golang: 编码风格及可见域规则严格且简单；Java: 来说层次接口清晰、规范，主要表现有以下这些。 1、变量a、变量声明及使用在Java中：变量可以声明了却不使用 1234public sta"><meta property="og:image" content="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/build-your-applications-with-golang.jpeg"><meta property="article:published_time" content="2024-04-24T05:52:54.000Z"><meta property="article:modified_time" content="2024-04-24T05:52:54.000Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.1.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2024-04-24 13:52:54'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="LemonGo97のBlog" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="https://coding-net-production-static-ci.codehub.cn/d70d0fa9-08d5-4fc7-ba82-7b73fee22292.jpg?imageMogr2/auto-orient/format/jpeg/cut/700x700x0x0" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">54</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">36</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E3%80%81%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">一 、基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.</span> <span class="toc-text">1、变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a%E3%80%81%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%8F%8A%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">a、变量声明及使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b%E3%80%81%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%8F%8A%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.2.</span> <span class="toc-text">b、变量声明及初始化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99"><span class="toc-number">1.2.</span> <span class="toc-text">2、作用域规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E9%80%97%E5%8F%B7-ok-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">3、逗号 ok 模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">4、结构体、函数以及方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%A3%B0%E6%98%8E%E5%8F%8A%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">a、结构体声明及使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b%E3%80%81%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.2.</span> <span class="toc-text">b、函数和方法的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%80%BC%E7%B1%BB%E5%9E%8B%E3%80%81%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E6%8C%87%E9%92%88"><span class="toc-number">1.5.</span> <span class="toc-text">5、值类型、引用类型以及指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a%E3%80%81%E6%95%B0%E7%BB%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.5.1.</span> <span class="toc-text">a、数组对比</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b%E3%80%81%E5%AF%B9%E8%B1%A1%E5%AF%B9%E6%AF%94"><span class="toc-number">1.5.2.</span> <span class="toc-text">b、对象对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E3%80%81%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">c、指针的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text">二、面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81Java%E7%9A%84OOP%E4%B8%8EGolang%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E7%BB%84%E5%90%88"><span class="toc-number">3.1.</span> <span class="toc-text">1、Java的OOP与Golang的结构体组合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E4%BE%B5%E5%85%A5%E5%BC%8F%E4%B8%8E%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.2.</span> <span class="toc-text">2、侵入式与非侵入式接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">三、异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81Java%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%9A"><span class="toc-number">4.1.</span> <span class="toc-text">1、Java的异常处理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Golang%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%9A"><span class="toc-number">4.2.</span> <span class="toc-text">2、Golang的异常处理：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">四、并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81Java-%E5%92%8C-Golang-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">5.1.</span> <span class="toc-text">1、Java 和 Golang 的基本实现：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Java-%E5%92%8C-Golang-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">5.2.</span> <span class="toc-text">2、Java 和 Golang 的区别：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a%E3%80%81Java-synchronized-%E4%B8%8EGolang-Mutex"><span class="toc-number">5.2.1.</span> <span class="toc-text">a、Java synchronized 与Golang Mutex</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b%E3%80%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">5.2.2.</span> <span class="toc-text">b、条件变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c%E3%80%81CAS-Atomic"><span class="toc-number">5.2.3.</span> <span class="toc-text">c、CAS&#x2F;Atomic</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#d%E3%80%81Once-%E4%B8%8E%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.2.4.</span> <span class="toc-text">d、Once 与单例模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">6.</span> <span class="toc-text">五、垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81Java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BD%93%E7%B3%BB"><span class="toc-number">6.1.</span> <span class="toc-text">1、Java的垃圾回收体系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Golang-GC%E7%89%B9%E5%BE%81"><span class="toc-number">6.2.</span> <span class="toc-text">2、Golang GC特征</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a%E3%80%81%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0"><span class="toc-number">6.2.1.</span> <span class="toc-text">a、三色标记</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b%E3%80%81%E9%9D%9E%E5%88%86%E4%BB%A3"><span class="toc-number">6.2.2.</span> <span class="toc-text">b、非分代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c%E3%80%81%E9%9D%9E%E7%B4%A7%E7%BC%A9"><span class="toc-number">6.2.3.</span> <span class="toc-text">c、非紧缩</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#d%E3%80%81%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="toc-number">6.2.4.</span> <span class="toc-text">d、写屏障</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97%E5%AF%B9%E6%AF%94"><span class="toc-number">7.</span> <span class="toc-text">六、资源消耗对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81Java%E7%9A%84JIT%E7%AD%96%E7%95%A5%E6%AF%94Golang%E7%9A%84AOT%E7%AD%96%E7%95%A5"><span class="toc-number">7.1.</span> <span class="toc-text">1、Java的JIT策略比Golang的AOT策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">7.2.</span> <span class="toc-text">2、内存分配和垃圾回收器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%B9%B6%E5%8F%91"><span class="toc-number">7.3.</span> <span class="toc-text">3、并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%8F%8D%E5%B0%84"><span class="toc-number">7.4.</span> <span class="toc-text">4、反射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E7%94%9F%E6%80%81"><span class="toc-number">8.</span> <span class="toc-text">七、生态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">9.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/build-your-applications-with-golang.jpeg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">LemonGo97のBlog</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">【转载】 Golang与Java全方位对比总结</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-24T05:52:54.000Z" title="发表于 2024-04-24 13:52:54">2024-04-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-24T05:52:54.000Z" title="更新于 2024-04-24 13:52:54">2024-04-24</time></span></div><div class="meta-secondline"> </div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>作者：xindong</p>
<blockquote>
<p>本文针对Golang与Java的基础语法、结构体函数、异常处理、并发编程及垃圾回收、资源消耗等各方面的差异进行对比总结，有不准确、不到位的地方还请大家不吝赐教。</p>
</blockquote>
<h3 id="一-、基础语法"><a href="#一-、基础语法" class="headerlink" title="一 、基础语法"></a><strong>一 、基础语法</strong></h3><p>Golang: 编码风格及可见域规则严格且简单；Java: 来说层次接口清晰、规范，主要表现有以下这些。</p>
<h4 id="1、变量"><a href="#1、变量" class="headerlink" title="1、变量"></a>1、变量</h4><h5 id="a、变量声明及使用"><a href="#a、变量声明及使用" class="headerlink" title="a、变量声明及使用"></a>a、变量声明及使用</h5><p>在Java中：变量可以声明了却不使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(<span class="type">int</span> num)</span> &#123; </span><br><span class="line">	<span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> num; </span><br><span class="line">	<span class="keyword">return</span> String.valueOf(num); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Golang中：声明的变量必须被使用，否则需要使用_来替代掉变量名，表明该变量不会比使用到</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toString</span><span class="params">(num <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	data := num     <span class="comment">// data没有使用者，无法编译  </span></span><br><span class="line">	<span class="keyword">return</span> strconv.Itoa(num)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toString</span><span class="params">(num <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	_ := num       <span class="comment">// 正常编译  </span></span><br><span class="line">	<span class="keyword">return</span> strconv.Itoa(num)  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="b、变量声明及初始化"><a href="#b、变量声明及初始化" class="headerlink" title="b、变量声明及初始化"></a>b、变量声明及初始化</h5><p>在Java中：如果在方法内部声明一个变量但不初始化，在使用时会出现编译错误；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compareVariable</span><span class="params">()</span> &#123;  </span><br><span class="line">	<span class="type">int</span> age;  </span><br><span class="line">    Object object;  </span><br><span class="line">    System.out.println(age); <span class="comment">// 编译错误  </span></span><br><span class="line">    System.out.println(object); <span class="comment">// 编译错误  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在Golang中：对于基本类型来讲，声明即初始化;对于引用类型，声明则初始化为nil。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compareVariable</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> age <span class="type">int</span>  </span><br><span class="line">    <span class="keyword">var</span> hashMap *<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>  </span><br><span class="line">    fmt.Println(num) <span class="comment">// num = 0  </span></span><br><span class="line">    fmt.Println(hashMap) <span class="comment">//  &amp;hashMap== nil  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2、作用域规则"><a href="#2、作用域规则" class="headerlink" title="2、作用域规则"></a>2、作用域规则</h4><p>Java: 对方法、变量及类的可见域规则是通过private、protected、public关键字来控制的,具体如下</p>
<table>
<thead>
<tr>
<th>作用域</th>
<th>当前类</th>
<th>同一package</th>
<th>子孙类</th>
<th>其他package</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>default（无修饰词）</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>Golang: 控制可见域的方式只有一个，当字段首字母开头是大写时说明其是对外可见的、小写时只对包内成员可见。</p>
<h4 id="3、逗号-ok-模式"><a href="#3、逗号-ok-模式" class="headerlink" title="3、逗号 ok 模式"></a>3、逗号 ok 模式</h4><p>在使用Golang编写代码的过程中，许多方法经常在一个表达式返回2个参数时使用这种模式：,ok，第一个参数是一个值或者nil，第二个参数是true/false或者一个错误error。在一个需要赋值的if条件语句中，使用这种模式去检测第二个参数值会让代码显得优雅简洁。这种模式在Golang编码规范中非常重要。这是Golang自身的函数多返回值特性的体现。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> _, ok := conditionMap[<span class="string">&quot;page&quot;</span>]; ok &#123;</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="4、结构体、函数以及方法"><a href="#4、结构体、函数以及方法" class="headerlink" title="4、结构体、函数以及方法"></a><strong>4、结构体、函数以及方法</strong></h4><h5 id="a、结构体声明及使用"><a href="#a、结构体声明及使用" class="headerlink" title="a、结构体声明及使用"></a>a、结构体声明及使用</h5><p>在Golang中区别与Java最显著的一点是，Golang不存在“类”这个概念，组织数据实体的结构在Golang中被称为结构体。函数可以脱离“类”而存在，函数可以依赖于结构体来调用或者依赖于包名调用。Golang中的结构体放弃了继承、实现等多态概念，结构体之间可使用组合来达到复用方法或者字段的效果。</p>
<p>Golang 声明一个结构体并使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User  定义User结构体  </span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;  </span><br><span class="line">    Name <span class="type">string</span>  </span><br><span class="line">    Age  <span class="type">int</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 使用一个结构体  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    personPoint := <span class="built_in">new</span>(User) <span class="comment">// 通过new方法创建结构体指针  </span></span><br><span class="line">    person1 := User&#123;&#125;        <span class="comment">// 通过Person&#123;&#125;创建默认字段的结构体  </span></span><br><span class="line">    person2 := User&#123;  </span><br><span class="line">        Name: <span class="string">&quot;xiaoHong&quot;</span>,  </span><br><span class="line">        Age:  <span class="number">21</span>,  </span><br><span class="line">    &#125;  </span><br><span class="line">    fmt.Println(personPoint) <span class="comment">// &amp;&#123; 0 &#125;  </span></span><br><span class="line">    fmt.Println(person1)     <span class="comment">// &#123; 0 &#125;  </span></span><br><span class="line">    fmt.Println(person2)     <span class="comment">// &#123;xiaoHong 21 &#125;  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Java声明实体并使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.name = name;  </span><br><span class="line">        <span class="built_in">this</span>.age = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.age = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> age;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">print</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;name = &quot;</span> + name + <span class="string">&quot;,age = &quot;</span> + age + <span class="string">&quot;&#125;&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;xiaohong&quot;</span>, <span class="number">29</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;user信息：&quot;</span> + user.print());     </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//执行结果  </span></span><br><span class="line">user信息：&#123;name = xiaohong,age = <span class="number">29</span>&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="b、函数和方法的区别"><a href="#b、函数和方法的区别" class="headerlink" title="b、函数和方法的区别"></a>b、函数和方法的区别</h5><p>在Java中：所有的“函数”都是基于“类”这个概念构建的，也就是只有在“类”中才会包含所谓的“函数”，这里的“函数”被称为“方法”，可见上方声明实体并使用。</p>
<p>在Golang中：“函数”和“方法”的最基本区别是：函数不基于结构体而是基于包名调用，方法基于结构体调用。如下实例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> entity  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;  </span><br><span class="line">    Name <span class="type">string</span>  </span><br><span class="line">    Age  <span class="type">int</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// User结构体/指针可调用的&quot;方法&quot;，属于User结构体  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(user *User)</span></span> Solve() &#123;  </span><br><span class="line">    fmt.Println(user)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 任何地方都可调用的&quot;函数&quot;，不属于任何结构体，可通过entity.Solve调用  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Solve</span><span class="params">(user *User)</span></span> &#123;  </span><br><span class="line">    fmt.Println(user)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    userPoint := <span class="built_in">new</span>(entity.User) <span class="comment">// 通过new方法创建结构体指针  </span></span><br><span class="line">    entity.Solve(userPoint) <span class="comment">// 函数调用  </span></span><br><span class="line">    userPoint.Solve()    <span class="comment">// 方法调用  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5、值类型、引用类型以及指针"><a href="#5、值类型、引用类型以及指针" class="headerlink" title="5、值类型、引用类型以及指针"></a>5、值类型、引用类型以及指针</h4><p>Java：在Java中不存在显式的指针操作；8种基本数据类型是值类型，数组和对象属于引用类型。</p>
<p>Golang：而Golang中存在显式的指针操作，但是Golang的指针不像C那么复杂，不能进行指针运算；所有的基本类型都属于值类型，但是有几个类型比较特殊，表现出引用类型的特征，分别是slice、map、channel、interface，除赋值以外它们都可以当做引用类型来使用，因此当我们这样做时,可以直接使用变量本身而不用指针。</p>
<p>注：slice与数组的区别为是否有固定长度，slice无固定长度，数组有固定长度。值得注意的是，在Golang中，只有同长度、同类型的数组才可视为“同一类型”，譬如<code>[]int</code>和<code>[3]int</code>则会被视为不同的类型，这在参数传递的时候会造成编译错误。</p>
<h5 id="a、数组对比"><a href="#a、数组对比" class="headerlink" title="a、数组对比"></a>a、数组对比</h5><p>在Java中：当向方法中传递数组时，可以直接通过该传入的数组修改原数组内部值（浅拷贝）。 在Golang中：则有两种情况：在不限定数组长度(为slice)时也直接改变原数组的值，当限定数组长度时会完全复制出一份副本来进行修改（深拷贝）：</p>
<p>Java的数组实践:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">       <span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  </span><br><span class="line">       change(array);  </span><br><span class="line">       System.out.println(Arrays.toString(array)); <span class="comment">// -1,2,3  </span></span><br><span class="line">   &#125;  </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;  </span><br><span class="line">       array[<span class="number">0</span>] = -<span class="number">1</span>;  </span><br><span class="line">   &#125;`</span><br></pre></td></tr></table></figure>

<p>Golang的数组实践:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  不限定长度（即slice）:  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> array = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  </span><br><span class="line">    change(array)  </span><br><span class="line">    fmt.Println(array)    <span class="comment">// [-1 2 3]  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(array []<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">-1</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//  限定长度（即数组）：   </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> array = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  </span><br><span class="line">    change(array)  </span><br><span class="line">    fmt.Println(array)    <span class="comment">//[1 2 3]  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(array [3]<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">-1</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="b、对象对比"><a href="#b、对象对比" class="headerlink" title="b、对象对比"></a>b、对象对比</h5><p>在Golang中：传入函数参数的是原对象的一个全新的copy（有自己的内存地址）;go对象之间赋值是把对象内存的 内容（字段值等） copy过去，所以才会看到globalUser修改前后的地址不变，但是对象的内容变了。 在Java中：传入函数参数的是原对象的引用的copy（指向的是同样的内存地址）; Java对象之间的赋值是把对象的引用 copy过去，因为引用指向的地址变了，所以对象的内容也变了。</p>
<p>Golang的对象实践：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//User 定义User结构体  </span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;  </span><br><span class="line">   Name <span class="type">string</span>  </span><br><span class="line">   Age <span class="type">int</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 定义一个全局的User  </span></span><br><span class="line"><span class="keyword">var</span> globalUser = User &#123;  </span><br><span class="line">   <span class="string">&quot;xiaoming&quot;</span>,  </span><br><span class="line">   <span class="number">28</span>,  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// modifyUser 定义一个函数，参数为User结构体“对象”，将全局globalUser指向传递过来的User结构体“对象”  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyUser</span><span class="params">(user User)</span></span> &#123;  </span><br><span class="line">   fmt.Printf(<span class="string">&quot;参数user的地址 = %p\n&quot;</span>,&amp;user)   </span><br><span class="line">   fmt.Printf(<span class="string">&quot;globalUser修改前的地址 = %p\n&quot;</span>,&amp;globalUser)  </span><br><span class="line">   fmt.Println(<span class="string">&quot;globalUser修改前 = &quot;</span>,globalUser)  </span><br><span class="line">   <span class="comment">// 修改指向  </span></span><br><span class="line">   globalUser = user  </span><br><span class="line">   fmt.Printf(<span class="string">&quot;globalUser修改后的地址 = %p\n&quot;</span>,&amp;globalUser)  </span><br><span class="line">   fmt.Println(<span class="string">&quot;globalUser修改后 = &quot;</span>,globalUser)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   <span class="keyword">var</span> u User = User &#123;  </span><br><span class="line">      <span class="string">&quot;xiaohong&quot;</span>,  </span><br><span class="line">      <span class="number">29</span>,  </span><br><span class="line">   &#125;  </span><br><span class="line">   fmt.Printf(<span class="string">&quot;将要传递的参数u的地址 = %p\n&quot;</span>,&amp;u)  </span><br><span class="line">   modifyUser(u)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 执行结果  </span></span><br><span class="line"><span class="comment">// 将要传递的参数u的地址 = 0xc0000ac018  </span></span><br><span class="line"><span class="comment">// 参数user的地址 = 0xc0000ac030  </span></span><br><span class="line"><span class="comment">// globalUser修改前的地址 = 0x113a270  </span></span><br><span class="line"><span class="comment">// globalUser修改前 = &#123;xiaoming 28&#125;  </span></span><br><span class="line"><span class="comment">// globalUser修改后的地址 = 0x113a270  </span></span><br><span class="line"><span class="comment">// globalUuser修改后 = &#123;xiaohong 29&#125; </span></span><br></pre></td></tr></table></figure>

<p>Java的对象实践验证：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.name = name;  </span><br><span class="line">        <span class="built_in">this</span>.age = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.age = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> age;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">print</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;name = &quot;</span> + name + <span class="string">&quot;,age = &quot;</span> + age + <span class="string">&quot;&#125;&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">User</span> <span class="variable">globalUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;xiaoming&quot;</span>,<span class="number">28</span>);  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">modifyUser</span><span class="params">(User user)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;参数globalUser的地址 = &quot;</span> + user);  </span><br><span class="line">        System.out.println(<span class="string">&quot;globalUser修改前的地址 = &quot;</span> + globalUser);  </span><br><span class="line">        System.out.println(<span class="string">&quot;globalUser修改前 = &quot;</span> + globalUser.print());  </span><br><span class="line">        globalUser = user;  </span><br><span class="line">        System.out.println(<span class="string">&quot;globalUser修改后的地址 = &quot;</span> + globalUser);  </span><br><span class="line">        System.out.println(<span class="string">&quot;globalUser修改后 = &quot;</span> + globalUser.print());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;xiaohong&quot;</span>, <span class="number">29</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;将要传递的参数user的地址 = &quot;</span> + user);  </span><br><span class="line">        modifyUser(user);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 执行结果  </span></span><br><span class="line"><span class="comment">// 将要传递的参数user的地址 = com.example.demo.User@5abca1e0  </span></span><br><span class="line"><span class="comment">// 参数globalUser的地址 = com.example.demo.User@5abca1e0  </span></span><br><span class="line"><span class="comment">// globalUser修改前的地址 = com.example.demo.User@2286778  </span></span><br><span class="line"><span class="comment">// globalUser修改前 = &#123;name = xiaoming,age = 28&#125;  </span></span><br><span class="line"><span class="comment">// globalUser修改后的地址 = com.example.demo.User@5abca1e0  </span></span><br><span class="line"><span class="comment">// globalUser修改后 = &#123;name = xiaohong,age = 29&#125;  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="c、指针的区别"><a href="#c、指针的区别" class="headerlink" title="c、指针的区别"></a>c、指针的区别</h3><p>在Java中：如果传递了引用类型（对象、数组等）会复制其指针进行传递 在Golang中：必须要显式传递Person的指针，不然只是传递了该对象的一个副本。</p>
<p>Golang的指针：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User  定义User结构体  </span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;  </span><br><span class="line">    Name <span class="type">string</span>  </span><br><span class="line">    Age  <span class="type">int</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    p1 := User&#123;  </span><br><span class="line">        Name: <span class="string">&quot;xiaohong&quot;</span>,  </span><br><span class="line">        Age:  <span class="number">21</span>,  </span><br><span class="line">    &#125;  </span><br><span class="line">    changePerson(p1)  </span><br><span class="line">    fmt.Println(p1.Name) <span class="comment">// xiaohong  </span></span><br><span class="line">    changePersonByPointer(&amp;p1)  </span><br><span class="line">    fmt.Println(p1.Name) <span class="comment">// xiaoming  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changePersonByPointer</span><span class="params">(user *User)</span></span> &#123;  </span><br><span class="line">    cuser.Name = <span class="string">&quot;xiaoming&quot;</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changePerson</span><span class="params">(user User)</span></span> &#123;  </span><br><span class="line">    user.Name = <span class="string">&quot;xiaoming&quot;</span>  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Java的指针：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changePerson</span><span class="params">(User user)</span> &#123;  </span><br><span class="line">        user.setName(<span class="string">&quot;xiaoming&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;xiaohong&quot;</span>, <span class="number">29</span>);  </span><br><span class="line">        changePerson(user);  </span><br><span class="line">        System.out.println(<span class="string">&quot;user信息：&quot;</span> + user.getName());      <span class="comment">// xiaoming  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.name = name;  </span><br><span class="line">        <span class="built_in">this</span>.age = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.age = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> age;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二、面向对象"><a href="#二、面向对象" class="headerlink" title="二、面向对象"></a>二、面向对象</h3><p>在Golang中：没有明确的OOP概念，Go语言只提供了两个关键类型：<code>struct</code>，<code>interface</code>。 在Java中： 面向对象语言的封装、继承、多态的特性以及“继承（<code>extends</code>）、实现（<code>implements</code>）”等关键字。</p>
<h4 id="1、Java的OOP与Golang的结构体组合"><a href="#1、Java的OOP与Golang的结构体组合" class="headerlink" title="1、Java的OOP与Golang的结构体组合"></a>1、Java的OOP与Golang的结构体组合</h4><p>假设有这么一个场景：动物（Animal）具备名字（Name）、年龄（Age）的基本特性，现在需要实现一个狗(Dog)，且Dog需要具备Animal所需的所有特性，并且自身具备犬吠（bark()）的动作。</p>
<p>首先来看看最熟悉的Java要如何写，很简单，使用抽象类描述Animal作为所有动物的超类，Dog extends Animal：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    String name;  </span><br><span class="line">    <span class="type">int</span> age;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(age + <span class="string">&quot;岁的&quot;</span> + name + <span class="string">&quot;在汪汪叫&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();  </span><br><span class="line">        dog.name = <span class="string">&quot;小龙&quot;</span>;  </span><br><span class="line">        dog.age = <span class="number">2</span>;  </span><br><span class="line">        dog.bark(); <span class="comment">// 2岁的小龙在汪汪叫  </span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Golang中，可以这样通过结构体的组合来实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;  </span><br><span class="line">    Name <span class="type">string</span>  </span><br><span class="line">    Age  <span class="type">int</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;  </span><br><span class="line">    *Animal  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dog *Dog)</span></span> Bark() &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d岁的%s在汪汪叫&quot;</span>, dog.Age, dog.Name)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    dog := &amp;Dog&#123;&amp;Animal&#123;  </span><br><span class="line">        Name: <span class="string">&quot;小龙&quot;</span>,  </span><br><span class="line">        Age:  <span class="number">2</span>,  </span><br><span class="line">    &#125;&#125;  </span><br><span class="line">    dog.Bark() <span class="comment">// 2岁的小龙在汪汪叫...  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2、侵入式与非侵入式接口"><a href="#2、侵入式与非侵入式接口" class="headerlink" title="2、侵入式与非侵入式接口"></a>2、侵入式与非侵入式接口</h4><p>在Java中：接口主要作为不同组件之间的契约存在。对契约的实现是强制的，你必须声明你的确实现了该接口。这类接口我们称为侵入式接口。“侵入式”的主要表现在于实现类需要明确声明自己实现了某个接口。</p>
<p>在Golang中：非侵入式接口不需要通过任何关键字声明类型与接口之间的实现关系，只要一个类型实现了接口的所有方法，那么这个类型就是这个接口的实现类型。</p>
<p>Java：管理狗的行为，可以通过以下接口实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Dog</span> &#123;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">Bark</span><span class="params">()</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DogImpl</span> <span class="keyword">implements</span> <span class="title class_">Dog</span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Bark</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;汪汪叫&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DogImpl</span>();  </span><br><span class="line">        dog.Bark();    <span class="comment">// 汪汪叫  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Golang: 假设现在有一个Factory接口，该接口中定义了Produce()方法及Consume()方法，CafeFactory结构体作为其实现类型，那么可以通过以下代码实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> entity  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> Factory <span class="keyword">interface</span> &#123;  </span><br><span class="line">    Produce() <span class="type">bool</span>  </span><br><span class="line">    Consume() <span class="type">bool</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> CarFactory <span class="keyword">struct</span> &#123;  </span><br><span class="line">    ProductName <span class="type">string</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CarFactory)</span></span> Produce() <span class="type">bool</span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;CarFactory生产%s成功&quot;</span>, c.ProductName)  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CarFactory)</span></span> Consume() <span class="type">bool</span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;CarFactory消费%s成功&quot;</span>, c.ProductName)  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// --------------  </span></span><br><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    factory := &amp;entity.CarFactory&#123;<span class="string">&quot;Car&quot;</span>&#125;  </span><br><span class="line">    doProduce(factory)  </span><br><span class="line">    doConsume(factory)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doProduce</span><span class="params">(factory entity.Factory)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> factory.Produce()  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doConsume</span><span class="params">(factory entity.Factory)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> factory.Consume()  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Golang的非侵入式接口优点：简单、高效、按需实现</p>
<p>在Go中，类没有继承的概念，只需要知道这个类型实现了哪些方法，每个方法是啥行为。</p>
<p>实现类型的时候，只需要关心自己应该提供哪些方法，不用再纠结接口需要拆得多细才合理。接口由使用方按需定义，而不用事前规划</p>
<p>减少包的引入，因为多引用一个外部的包，就意味着更多的耦合。接口由使用方按自身需求来定义，使用方无需关心是否有其他模块定义过类似的接口</p>
<p>Java的侵入式接口优点: 层次结构清晰，对类型的动作行为有严格的管理</p>
<h3 id="三、异常处理"><a href="#三、异常处理" class="headerlink" title="三、异常处理"></a>三、异常处理</h3><p>在Java中: 通过try..catch..finally的方式进行异常处理，有可能出现异常的代码会被try块给包裹起来，在catch中捕获相关的异常并进行处理，最后通过finally块来统一执行最后的结束操作（释放资源）。</p>
<p>在Golang中：错误处理方式有两种方式：<strong>ok模式</strong> 与 <strong>defer、panic及recover的组合</strong></p>
<h4 id="1、Java的异常处理："><a href="#1、Java的异常处理：" class="headerlink" title="1、Java的异常处理："></a>1、Java的异常处理：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>);  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;  </span><br><span class="line">            System.out.println(e.getMessage());  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span>(fileInputStream!=<span class="literal">null</span>)&#123;  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    fileInputStream.close();  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            System.out.println(<span class="string">&quot;回收资源&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2、Golang的异常处理："><a href="#2、Golang的异常处理：" class="headerlink" title="2、Golang的异常处理："></a>2、Golang的异常处理：</h4><p>Golang的<strong>ok模式</strong>。所有可能出现异常的方法或者代码直接把错误当作第二个响应值进行返回，程序中对返回值进行判断，非空则进行处理并且立即中断程序的执行。 优点：这种比Java的简单很多，是Golang在异常处理方式上的一大特色。</p>
<p>缺点：代码冗余，所有的异常都需要通过<code>if err != nil &#123;&#125;</code>去做判断和处理，不能做到统一捕捉和处理，容易遗漏。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    value, err := Bark()  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">        <span class="comment">// 返回了异常，进行处理  </span></span><br><span class="line">        log.<span class="type">error</span>(<span class="string">&quot;...异常：&quot;</span>, err)  </span><br><span class="line">        <span class="keyword">return</span> err  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Bark方法执行正确，继续执行后续代码  </span></span><br><span class="line">    Process(value)  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Golang的<strong>defer、panic及recover</strong></p>
<p>defer是Golang错误处理中常用的关键字，pannic及recover是Golang中的内置函数，通常与defer结合进行错误处理，它们各自的用途为:</p>
<p>defer的作用是延迟执行某段代码，一般用于关闭资源或者执行必须执行的收尾操作，无论是否出现错误defer代码段都会执行，类似于Java中的finally代码块的作用；defer也可以执行函数或者是匿名函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line"> <span class="comment">// 清理工作  </span></span><br><span class="line">&#125; ()  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 这是传递参数给匿名函数时的写法  </span></span><br><span class="line"><span class="keyword">var</span> num := <span class="number">1</span>  </span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(num <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line"> <span class="comment">// 做你复杂的清理工作  </span></span><br><span class="line">&#125; (num)  </span><br><span class="line">  </span><br><span class="line"> 需要注意的是，<span class="keyword">defer</span>使用一个栈来维护需要执行的代码，所以<span class="keyword">defer</span>函数所执行的顺序是和<span class="keyword">defer</span>声明的顺序相反的。  </span><br><span class="line"><span class="keyword">defer</span> fmt.Println(a)     </span><br><span class="line"><span class="keyword">defer</span> fmt.Println(b)  </span><br><span class="line"><span class="keyword">defer</span> fmt.Println(c)  </span><br><span class="line">  </span><br><span class="line">执行结果：  </span><br><span class="line">c  </span><br><span class="line">b  </span><br><span class="line">a  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>panic的作用是抛出错误，制造系统运行时恐慌，当在一个函数执行过程中调用panic()函数时，正常的函数执行流程将立即终止，但函数中之前使用defer关键字延迟执行的语句将正常展开执行，之后该函数将返回到调用函数，并导致逐层向上执行 panic流程，直至所属的goroutine中所有正在执行的函数被终止，panic和Java中的throw关键字类似，用于抛出错误，阻止程序执行。</p>
<p>recover的作用是捕捉panic抛出的错误并进行处理，需要联合defer来使用，类似于Java中的catch代码块：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">      fmt.Println(<span class="string">&quot;main begin&quot;</span>)  </span><br><span class="line">      <span class="comment">// 必须要先声明defer，否则不能捕获到panic异常  </span></span><br><span class="line">      <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;   </span><br><span class="line">        fmt.Println(<span class="string">&quot;defer begin&quot;</span>)  </span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">            <span class="comment">// 这里的err其实就是panic传入的内容  </span></span><br><span class="line">            fmt.Println(err)   </span><br><span class="line">        &#125;  </span><br><span class="line">         fmt.Println(<span class="string">&quot;defer end&quot;</span>)  </span><br><span class="line">      &#125;()  </span><br><span class="line">      test()  </span><br><span class="line">      <span class="comment">// test中出现错误，这里开始下面代码不会再执行  </span></span><br><span class="line">      fmt.Println(<span class="string">&quot;main end&quot;</span>)   </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   fmt.Println(<span class="string">&quot;test begin&quot;</span>)  </span><br><span class="line">   <span class="built_in">panic</span>(<span class="string">&quot;error&quot;</span>)  </span><br><span class="line">   <span class="comment">//这里开始下面代码不会再执行  </span></span><br><span class="line">   fmt.Println(<span class="string">&quot;test end&quot;</span>)   </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//执行结果  </span></span><br><span class="line">main begin  </span><br><span class="line">test begin  </span><br><span class="line"><span class="keyword">defer</span> begin  </span><br><span class="line"><span class="type">error</span>  </span><br><span class="line"><span class="keyword">defer</span> end  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注：利用recover处理panic指令，defer必须在panic之前声明，否则当panic时，recover无法捕获到panic。</p>
<h3 id="四、并发编程"><a href="#四、并发编程" class="headerlink" title="四、并发编程"></a>四、并发编程</h3><p>Java 中 CPU 资源分配对象是 Thread，Go 中 CPU 资源分配对象是 goroutine。Java Thread 与系统线程为一一对应关系，goroutine 是 Go 实现的用户级线程，与系统线程是 m:n 关系。</p>
<h4 id="1、Java-和-Golang-的基本实现："><a href="#1、Java-和-Golang-的基本实现：" class="headerlink" title="1、Java 和 Golang 的基本实现："></a>1、Java 和 Golang 的基本实现：</h4><p>在 Java 中，如要获得 CPU 资源并异步执行代码单元，需要将代码单元包装成 Runnable，并创建可以运行代码单元的 Thread ,执行 start 方法启动线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> ()-&gt; System.out.println(<span class="string">&quot;task running&quot;</span>);  </span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);  </span><br><span class="line">t.start();  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Java 应用一般使用线程池集中处理任务，以避免线程反复创建回收带来的开销。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> ()-&gt; System.out.println(<span class="string">&quot;task running&quot;</span>);  </span><br><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();  </span><br><span class="line">executor.execute(task);  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 Golang 中，则需要将代码包装成函数。使用 <code>go</code> 关键字调用函数之后，便创建了一个可以运行代码单元的 goroutine。一旦 CPU 资源就绪，对应的代码单元便会在 goroutine 中执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  fmt.Println(<span class="string">&quot;test task running&quot;</span>)  </span><br><span class="line">&#125;()  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2、Java-和-Golang-的区别："><a href="#2、Java-和-Golang-的区别：" class="headerlink" title="2、Java 和 Golang 的区别："></a>2、Java 和 Golang 的区别：</h4><p>Golang语言采用了CSP（Communicating Sequential Processes）的模型，其中以goroutine和channel作为主要实现手段。 Java则采用了多线程模型，其中以Thread和Synchronization作为主要实现手段。 Golang语言的goroutine是一种轻量级的线程，它们的创建和销毁速度比Java中的线程快得多。在Java中，创建和销毁线程都需要相当大的开销。</p>
<p>Golang语言的channel是一种同步数据传递的机制，它可以方便地解决多道程序之间的通信问题。Java中则需要使用同步工具（如Semaphore、CountDownLatch等）来解决多线程之间的通信问题。</p>
<p><strong>Java 和 Go 官方库中同步方式的对应关系</strong></p>
<p>|<br> | <strong>Java</strong> | <strong>Golang</strong> |<br>| — | — | — |<br>| 锁 | synchronized,ReentrantLock | sync.Mutex, one unit buffered channel |<br>| 读写锁 | ReentrantReadWriteLock, StampedLock | sync.RWMutex |<br>| 条件变量 | condition | sync.Cond |<br>| CAS/Atomic | Varhandle、volatile，Atomic 类 | atomic.Value，atomic 包 |<br>| once | 单例模式 | sync.Once |</p>
<h5 id="a、Java-synchronized-与Golang-Mutex"><a href="#a、Java-synchronized-与Golang-Mutex" class="headerlink" title="a、Java synchronized 与Golang Mutex"></a>a、Java synchronized 与Golang Mutex</h5><p>Java synchronized：线程 A 在 t1 时刻释放 JVM 锁后（monitor exit)，在随后的 t2 时刻，若任意线程 B 获取到 JVM 锁（monintor enter），则线程 A 在 t1 时刻之前发生的所有写入均对 B 可见。synchronized 是 JVM 内置锁实现，写入 volatile 变量相当于 monitor exit，读取 volatile 变量相当于 monintor enter。（即一把锁只能同时被一个线程获取，没有获得锁的线程只能阻塞等待）</p>
<p>synchronized的使用： 修饰一个代码块，被修饰的代码块称为同步代码块，作用范围是大括号{}括起来的代码；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">   <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;  </span><br><span class="line">     <span class="comment">// todo some thing   </span></span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修饰一个方法，被修饰的方法称为同步方法，其作用范围是整个方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">   <span class="comment">// todo some thing  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改一个静态方法，作用范围是整个静态方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;  </span><br><span class="line">   <span class="comment">// todo some thing  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改一个类，作用范围是synchronized后面括号括起来的部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DemoClass</span> &#123;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;  </span><br><span class="line">      <span class="keyword">synchronized</span>(DemoClass.class) &#123;  </span><br><span class="line">         <span class="comment">// todo some thing  </span></span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Go Mutex：Go 并未像 Java 一样提供 volatile 这样基础的关键字，但其 Mutex 相关内存模型和 synchronized 或 Java 官方库 Lock 实现有十分接近语义。若 goroutine A 在 t1 时刻释放 sync.Mutex 或 sync.RWMutex 后，在随后的 t2 时刻，若任意 goroutine B 获取到锁，则 goroutine A 在 t1 时刻之前发生的所有写入均对 B 可见。</p>
<p>Mutex的使用：</p>
<p>修饰关键代码：每次只有一个线程对这个关键变量进行修改，避免多个线程同时这个关键代码进行操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  </span><br><span class="line"> <span class="keyword">var</span> mutex sync.Mutex  </span><br><span class="line">  </span><br><span class="line"> count := <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;  </span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   mutex.Lock() <span class="comment">// 加锁  </span></span><br><span class="line">   count += <span class="number">1</span>  </span><br><span class="line">   mutex.Unlock() <span class="comment">// 解锁  </span></span><br><span class="line">  &#125;()  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 休眠，等待2s  </span></span><br><span class="line"> time.Sleep(time.Second * <span class="number">2</span>)  </span><br><span class="line"> <span class="comment">// 100，没有加锁结果不正确  </span></span><br><span class="line"> fmt.Println(<span class="string">&quot;count = &quot;</span>, count)  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修饰结构体： 带锁结构体初始化后，直接调用对应的线程安全函数就可以。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> count <span class="keyword">struct</span> &#123;  </span><br><span class="line"> lock  sync.Mutex  </span><br><span class="line"> value <span class="type">int</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 结构体对应的结构方法  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver *count)</span></span> countOne() &#123;  </span><br><span class="line"> receiver.lock.Lock()  </span><br><span class="line"> <span class="keyword">defer</span> receiver.lock.Unlock()  </span><br><span class="line"> receiver.value++  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  </span><br><span class="line"> c := count&#123;  </span><br><span class="line">  lock:  sync.Mutex&#123;&#125;,  </span><br><span class="line">  value: <span class="number">0</span>,  </span><br><span class="line"> &#125;  </span><br><span class="line"> group := sync.WaitGroup&#123;&#125;  </span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;  </span><br><span class="line">  group.Add(<span class="number">1</span>)  </span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(count2 *count)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">defer</span> group.Done()  </span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;  </span><br><span class="line">    count2.countOne()  </span><br><span class="line">   &#125;  </span><br><span class="line">  &#125;(&amp;c)  </span><br><span class="line"> &#125;  </span><br><span class="line"> group.Wait()  </span><br><span class="line"> fmt.Printf(<span class="string">&quot;The count value is %d&quot;</span>, c.value)    <span class="comment">// The count value is 1000  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="b、条件变量"><a href="#b、条件变量" class="headerlink" title="b、条件变量"></a>b、条件变量</h5><p>Java 和 Golang 相似点：一般来说，条件变量衍生于锁，不同条件变量只是同一锁空间下的不同等待队列。Java 可以使用 synchronized 代码块保护特定代码路径，兼而可以在 synchronized 代码块中使用 Object wait 和 notify、notifyall 方法实现单一条件等待。如果需要多个条件，可以使用官方库提供的 Lock 实现和 Condition 实现。</p>
<p>Java 和 Golang 区别点：Java 创建条件变量的方式是调用 Lock 接口 newCondition 方法。Go sync.Cond 结构体需设置 sync.Mutex 字段才能工作，挂起方法为 Wait，唤醒方法为 Braodcast。Go 语言里面条件变量的通知 Signal() 和 Broadcast()，并没有在锁的保护下执行，而是在 Unlock() 之后执行。</p>
<h5 id="c、CAS-Atomic"><a href="#c、CAS-Atomic" class="headerlink" title="c、CAS/Atomic"></a>c、CAS/Atomic</h5><p>原子性：一个或者多个操作在 CPU 执行的过程中不被中断的特性，称为原子性（atomicity）。CAS是乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。Java 和 Go 均支持 CAS 及原子操作。</p>
<p>在Java中： CAS 操作由 volatile 关键字和 VarHandle（9 之前是 UnSafe）支持，在此基础上有了 Atomic 类和并发包中的大量无锁实现（如 ConcurrentHashMap, AQS 队列等）。</p>
<p>在Golang中：atomic.Value 提供了 CAS 操作基础，它保证任意类型（interface {}) 的 Load 和 Store 为原子操作，在此基础上有 atomic 包。</p>
<h5 id="d、Once-与单例模式"><a href="#d、Once-与单例模式" class="headerlink" title="d、Once 与单例模式"></a>d、Once 与单例模式</h5><p>sync.Once 是 Golang 标准库提供的使函数只执行一次的实现，常应用于单例模式，例如初始化配置、保持数据库连接等。它有 2 个特性：</p>
<p>保证程序运行期间某段代码只会执行一次</p>
<p>如果多个 goroutine 同时执行 Once 守护代码，只有 1 个 goroutine 会获得执行机会，其他 goroutine 会阻塞直至代码执行完毕。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="keyword">var</span> once = sync.Once&#123;&#125;  </span><br><span class="line">  f := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Millisecond)  </span><br><span class="line">    fmt.Println(<span class="string">&quot;do once&quot;</span>)  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;do once start&quot;</span>)  </span><br><span class="line">    once.Do(f)  </span><br><span class="line">    fmt.Println(<span class="string">&quot;do once finish&quot;</span>)  </span><br><span class="line">  &#125;()  </span><br><span class="line">  time.Sleep(<span class="number">1</span> * time.Millisecond)  </span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;  </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">      fmt.Println(<span class="string">&quot;block...&quot;</span>)  </span><br><span class="line">      once.Do(f)  </span><br><span class="line">      fmt.Println(<span class="string">&quot;resume&quot;</span>)  </span><br><span class="line">    &#125;()  </span><br><span class="line">  &#125;  </span><br><span class="line">  time.Sleep(<span class="number">10</span> * time.Millisecond)  </span><br><span class="line">&#125;<span class="comment">//~  </span></span><br><span class="line">do once start  </span><br><span class="line">block...  </span><br><span class="line">block...  </span><br><span class="line">do once  </span><br><span class="line">do once finish  </span><br><span class="line">resume  </span><br><span class="line">resume  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>java中单例模式的写法有好几种，主要是懒汉式单例、饿汉式单例。</p>
<p>懒汉式单例: 懒汉式单例的实现没有考虑线程安全问题，需要结合synchronized，保证线程安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式单例类.在第一次调用的时候实例化自己   </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton single=<span class="literal">null</span>;  </span><br><span class="line">    <span class="comment">//静态工厂方法   </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">         <span class="keyword">if</span> (single == <span class="literal">null</span>) &#123;    </span><br><span class="line">             single = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">         &#125;    </span><br><span class="line">        <span class="keyword">return</span> single;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>饿汉式单例：饿汉式在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以天生是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式单例类.在类初始化时，已经自行实例化   </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">single</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    <span class="comment">//静态工厂方法   </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> single;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="五、垃圾回收"><a href="#五、垃圾回收" class="headerlink" title="五、垃圾回收"></a>五、垃圾回收</h3><p>GC(Garbage Collection)垃圾回收是一种自动管理内存的方式，支持GC的语言无需手动管理内存，程序后台自动判断对象是否存活并回收其内存空间，使开发人员从内存管理上解脱出来。 因为支持更多的特性和更灵活多样的GC策略, 比如分代,对象可移动,各种参数调节等等. 而Go只做了一种GC方案,不分代,不可移动,没什么参数能调节,而且更注重暂停时间的优化,执行GC的时机更频繁, 所以Go通常更占更少的内存,但代价就是GC性能比JVM差了不少。</p>
<h4 id="1、Java的垃圾回收体系"><a href="#1、Java的垃圾回收体系" class="headerlink" title="1、Java的垃圾回收体系"></a>1、Java的垃圾回收体系</h4><p>Java基于JVM完成了垃圾收集的功能，其体系很庞大，包括了垃圾回收器（G1、CMS、Serial、ParNew等）、垃圾回收算法(标记-清除、标记-整理、复制、分代收集)、可达性算法(可达性分析、引用计数法)、引用类型、JVM内存模型等内容。经过多代发展，Java的垃圾回收机制较为完善，Java划分新生代、老年代来存储对象。对象通常会在新生代分配内存，多次存活的对象会被移到老年代，由于新生代存活率低，产生空间碎片的可能性高，通常选用“标记-复制”作为回收算法，而老年代存活率高，通常选用“标记-清除”或“标记-整理”作为回收算法，压缩整理空间。</p>
<h4 id="2、Golang-GC特征"><a href="#2、Golang-GC特征" class="headerlink" title="2、Golang GC特征"></a>2、Golang GC特征</h4><p>三色标记、并发标记和清扫、非分代、非紧缩、写屏障</p>
<h5 id="a、三色标记"><a href="#a、三色标记" class="headerlink" title="a、三色标记"></a>a、三色标记</h5><p>a、程序开始时有黑白灰三个集合，初始时所有对象都是白色； b、从root对象开始标记，将所有可达对象标记为灰色； c、从灰色对象集合取出对象，将其引用对象标记为灰色，放入灰色集合，并将自己标记为黑色； d、重复第三步，直到灰色集合为空，即所有可达对象全部都被标记； e、标记结束后，不可达白色对象即为垃圾，对内存进行迭代清扫，回收白色对象； f、重置GC状态；</p>
<h5 id="b、非分代"><a href="#b、非分代" class="headerlink" title="b、非分代"></a>b、非分代</h5><p>Java采用分代回收（按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，短的放入新生代，不同代有不同的回收算法和回收频率），Golang没有分代，一视同仁；</p>
<h5 id="c、非紧缩"><a href="#c、非紧缩" class="headerlink" title="c、非紧缩"></a>c、非紧缩</h5><p>在垃圾回收之后不会进行内存整理以清除内存碎片；</p>
<h5 id="d、写屏障"><a href="#d、写屏障" class="headerlink" title="d、写屏障"></a>d、写屏障</h5><p>在并发标记的过程中，如果应用程序修改了对象图，就可能出现标记遗漏的可能，写屏障是为了处理标记遗漏的问题。</p>
<h3 id="六、资源消耗对比"><a href="#六、资源消耗对比" class="headerlink" title="六、资源消耗对比"></a>六、资源消耗对比</h3><p>在内存利用效率上，Go语言确实比Java做得更好，在4个不同的角度来总结：</p>
<h4 id="1、Java的JIT策略比Golang的AOT策略"><a href="#1、Java的JIT策略比Golang的AOT策略" class="headerlink" title="1、Java的JIT策略比Golang的AOT策略"></a>1、Java的JIT策略比Golang的AOT策略</h4><p>Java在运行时相比Golang多占用了一些内存。原因在于：</p>
<p>Java运行态中包含了一个完整的解释器、一个JIT编译期以及一个垃圾回收器，这会显著地增加内存。</p>
<p>Golang语言直接编译到机器码，运行态只包含机器码和一个垃圾回收器。</p>
<p>因此Golang的运行态相对消耗内存较少。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/715ff217ac371c04928aff5fd2f85695.png" alt=""></p>
<h4 id="2、内存分配和垃圾回收器"><a href="#2、内存分配和垃圾回收器" class="headerlink" title="2、内存分配和垃圾回收器"></a>2、内存分配和垃圾回收器</h4><p>Java确实在起步占用上偏多，毕竟jvm需要更多内存做jit，默认的gc算法对内存要求偏高，但这不能代表后续占用仍然线性增长。如果目标是启动成百上千个内存需求较少的进程，那Java确实不擅长。</p>
<h4 id="3、并发"><a href="#3、并发" class="headerlink" title="3、并发"></a>3、并发</h4><p>协程模型比线程模型更加节省内存。</p>
<h4 id="4、反射"><a href="#4、反射" class="headerlink" title="4、反射"></a>4、反射</h4><p>Golang的反射更加简单，导致框架的内存消耗Golang程序比Java程序优秀。主要是因为： Java的框架实现中大量使用反射，并使用hashmap缓存信息，这2个都是极度消耗内存的行为。 Golang的框架中也使用reflect、map。但是Golang是面向interface和值类型的，这导致Golang的反射模型要比Java的反射模型简单非常多，反射过程要产生的对象数量也少非常多。</p>
<h3 id="七、生态"><a href="#七、生态" class="headerlink" title="七、生态"></a>七、生态</h3><p>Java 在生态这方面简直是无敌的存在，这主要得益于 Spring 全家桶，Spring 让 Java 走上了神座。Golang 语言知名的框架也很多，但是远远没有 Spring 影响那么大。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>Golang</td>
<td>代码简洁性 静态类型可编译成机器码直接运行 天生多核并行 垃圾收集 跨平台且不依赖运行时环境 简洁的泛型</td>
<td>有限的库支持 泛型不够完善 灵活度没Java高(这个可算优点也可算缺点)</td>
</tr>
<tr>
<td>Java</td>
<td>优秀的生态 优秀的三方库 多线程 灵活性高 平台独立性 完善的语言特性 代码结构层次清晰</td>
<td>大量冗余的陈旧实现导致性能不佳 生态的复杂性 复杂的继承机制</td>
</tr>
</tbody></table>
<p>本文转自 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/-N4eqdXb9a93uvOWfE4ScQ">https://mp.weixin.qq.com/s/-N4eqdXb9a93uvOWfE4ScQ</a>，如有侵权，请联系删除。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">xindong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/-N4eqdXb9a93uvOWfE4ScQ">https://mp.weixin.qq.com/s/-N4eqdXb9a93uvOWfE4ScQ</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.lemongo97.com" target="_blank">LemonGo97のBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Golang/">Golang</a></div><div class="post_share"><div class="social-share" data-image="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/build-your-applications-with-golang.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/6b50a5f8/"><img class="prev-cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/build-your-applications-with-golang.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Golang 整洁架构实践</div></div></a></div><div class="next-post pull-right"><a href="/posts/3373dbe/"><img class="next-cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/build-your-applications-with-golang.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Go语言入门分享</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/posts/4895093/" title="Golang异步编程方式和技巧"><img class="relatedPosts_cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/build-your-applications-with-golang.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-24</div><div class="relatedPosts_title">Golang异步编程方式和技巧</div></div></a></div><div class="relatedPosts_item"><a href="/posts/6b50a5f8/" title="Golang 整洁架构实践"><img class="relatedPosts_cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/build-your-applications-with-golang.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-24</div><div class="relatedPosts_title">Golang 整洁架构实践</div></div></a></div><div class="relatedPosts_item"><a href="/posts/3373dbe/" title="Go语言入门分享"><img class="relatedPosts_cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/build-your-applications-with-golang.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-24</div><div class="relatedPosts_title">Go语言入门分享</div></div></a></div><div class="relatedPosts_item"><a href="/posts/da348609/" title="如何真正写好Golang代码?"><img class="relatedPosts_cover" data-lazy-src="https://lemongo97-blog-img.oss-cn-beijing.aliyuncs.com/build-your-applications-with-golang.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-24</div><div class="relatedPosts_title">如何真正写好Golang代码?</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By LemonGo97</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/instant.page/5.1.0/instantpage.min.js" type="module" defer></script><script src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.3.1/lazyload.iife.min.js" async></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'w7vT5VedMPyGHyDYppcacmtw-gzGzoHsz',
      appKey: 'YxBl09Aj50g5Ld621aydI4pz',
      placeholder: '来和大家一起讨论吧！',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div></div></body></html>